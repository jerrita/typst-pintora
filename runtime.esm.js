var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i2 = 0; i2 < 64; i2++)
    table[i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 * 4 - 205] = i2;
  return (base64) => {
    var n2 = base64.length, bytes = new Uint8Array((n2 - (base64[n2 - 1] == "=") - (base64[n2 - 2] == "=")) * 3 / 4 | 0);
    for (var i3 = 0, j = 0; i3 < n2; ) {
      var c0 = table[base64.charCodeAt(i3++)], c1 = table[base64.charCodeAt(i3++)];
      var c2 = table[base64.charCodeAt(i3++)], c3 = table[base64.charCodeAt(i3++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// ../../node_modules/.pnpm/deepmerge@4.2.2/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.2.2/node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property3) {
      try {
        return property3 in object;
      } catch (_3) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module2.exports = deepmerge_1;
  }
});

// ../../node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "../../node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js"(exports2, module2) {
    var toString5 = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray3(val))
        return "array";
      if (isBuffer3(val))
        return "buffer";
      if (isArguments3(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString5.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray3(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name, val) {
      return ctorName(name) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments3(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err) {
        if (err.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer3(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// ../../node_modules/.pnpm/shallow-clone@3.0.1/node_modules/shallow-clone/index.js
var require_shallow_clone = __commonJS({
  "../../node_modules/.pnpm/shallow-clone@3.0.1/node_modules/shallow-clone/index.js"(exports2, module2) {
    "use strict";
    var valueOf = Symbol.prototype.valueOf;
    var typeOf = require_kind_of();
    function clone3(val, deep) {
      switch (typeOf(val)) {
        case "array":
          return val.slice();
        case "object":
          return Object.assign({}, val);
        case "date":
          return new val.constructor(Number(val));
        case "map":
          return new Map(val);
        case "set":
          return new Set(val);
        case "buffer":
          return cloneBuffer2(val);
        case "symbol":
          return cloneSymbol2(val);
        case "arraybuffer":
          return cloneArrayBuffer2(val);
        case "float32array":
        case "float64array":
        case "int16array":
        case "int32array":
        case "int8array":
        case "uint16array":
        case "uint32array":
        case "uint8clampedarray":
        case "uint8array":
          return cloneTypedArray2(val);
        case "regexp":
          return cloneRegExp2(val);
        case "error":
          return Object.create(val);
        default: {
          return val;
        }
      }
    }
    function cloneRegExp2(val) {
      const flags = val.flags !== void 0 ? val.flags : /\w+$/.exec(val) || void 0;
      const re = new val.constructor(val.source, flags);
      re.lastIndex = val.lastIndex;
      return re;
    }
    function cloneArrayBuffer2(val) {
      const res = new val.constructor(val.byteLength);
      new Uint8Array(res).set(new Uint8Array(val));
      return res;
    }
    function cloneTypedArray2(val, deep) {
      return new val.constructor(val.buffer, val.byteOffset, val.length);
    }
    function cloneBuffer2(val) {
      const len2 = val.length;
      const buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len2) : Buffer.from(len2);
      val.copy(buf);
      return buf;
    }
    function cloneSymbol2(val) {
      return valueOf ? Object(valueOf.call(val)) : {};
    }
    module2.exports = clone3;
  }
});

// ../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js
var require_isobject = __commonJS({
  "../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject3(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// ../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js"(exports2, module2) {
    "use strict";
    var isObject3 = require_isobject();
    function isObjectObject(o) {
      return isObject3(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module2.exports = function isPlainObject(o) {
      var ctor, prot;
      if (isObjectObject(o) === false)
        return false;
      ctor = o.constructor;
      if (typeof ctor !== "function")
        return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/clone-deep@4.0.1/node_modules/clone-deep/index.js
var require_clone_deep = __commonJS({
  "../../node_modules/.pnpm/clone-deep@4.0.1/node_modules/clone-deep/index.js"(exports2, module2) {
    "use strict";
    var clone3 = require_shallow_clone();
    var typeOf = require_kind_of();
    var isPlainObject = require_is_plain_object();
    function cloneDeep3(val, instanceClone) {
      switch (typeOf(val)) {
        case "object":
          return cloneObjectDeep(val, instanceClone);
        case "array":
          return cloneArrayDeep(val, instanceClone);
        default: {
          return clone3(val);
        }
      }
    }
    function cloneObjectDeep(val, instanceClone) {
      if (typeof instanceClone === "function") {
        return instanceClone(val);
      }
      if (instanceClone || isPlainObject(val)) {
        const res = new val.constructor();
        for (let key in val) {
          res[key] = cloneDeep3(val[key], instanceClone);
        }
        return res;
      }
      return val;
    }
    function cloneArrayDeep(val, instanceClone) {
      const res = new val.constructor(val.length);
      for (let i2 = 0; i2 < val.length; i2++) {
        res[i2] = cloneDeep3(val[i2], instanceClone);
      }
      return res;
    }
    module2.exports = cloneDeep3;
  }
});

// ../../node_modules/.pnpm/tinycolor2@1.4.2/node_modules/tinycolor2/tinycolor.js
var require_tinycolor = __commonJS({
  "../../node_modules/.pnpm/tinycolor2@1.4.2/node_modules/tinycolor2/tinycolor.js"(exports2, module2) {
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor2(color2, opts) {
        color2 = color2 ? color2 : "";
        opts = opts || {};
        if (color2 instanceof tinycolor2) {
          return color2;
        }
        if (!(this instanceof tinycolor2)) {
          return new tinycolor2(color2, opts);
        }
        var rgb2 = inputToRGB(color2);
        this._originalInput = color2, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb2.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb2.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor2.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb2 = this.toRgb();
          return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb2 = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb2.r / 255;
          GsRGB = rgb2.g / 255;
          BsRGB = rgb2.b / 255;
          if (RsRGB <= 0.03928) {
            R = RsRGB / 12.92;
          } else {
            R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G = GsRGB / 12.92;
          } else {
            G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B = BsRGB / 12.92;
          } else {
            B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl2 = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl2.h * 360, s: hsl2.s, l: hsl2.l, a: this._a };
        },
        toHslString: function() {
          var hsl2 = rgbToHsl(this._r, this._g, this._b);
          var h = mathRound(hsl2.h * 360), s = mathRound(hsl2.s * 100), l = mathRound(hsl2.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor2(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor2(this.toString());
        },
        _applyModification: function(fn, args) {
          var color2 = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color2._r;
          this._g = color2._g;
          this._b = color2._b;
          this.setAlpha(color2._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor2.fromRatio = function(color2, opts) {
        if (typeof color2 == "object") {
          var newColor = {};
          for (var i2 in color2) {
            if (color2.hasOwnProperty(i2)) {
              if (i2 === "a") {
                newColor[i2] = color2[i2];
              } else {
                newColor[i2] = convertToPercentage(color2[i2]);
              }
            }
          }
          color2 = newColor;
        }
        return tinycolor2(color2, opts);
      };
      function inputToRGB(color2) {
        var rgb2 = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color2 == "string") {
          color2 = stringInputToObject(color2);
        }
        if (typeof color2 == "object") {
          if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
            rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
            ok = true;
            format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
            s = convertToPercentage(color2.s);
            v = convertToPercentage(color2.v);
            rgb2 = hsvToRgb(color2.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
            s = convertToPercentage(color2.s);
            l = convertToPercentage(color2.l);
            rgb2 = hslToRgb(color2.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (color2.hasOwnProperty("a")) {
            a = color2.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color2.format || format,
          r: mathMin(255, mathMax(rgb2.r, 0)),
          g: mathMin(255, mathMax(rgb2.g, 0)),
          b: mathMin(255, mathMax(rgb2.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b10) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b10, 255) * 255
        };
      }
      function rgbToHsl(r, g, b10) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b10 = bound01(b10, 255);
        var max4 = mathMax(r, g, b10), min4 = mathMin(r, g, b10);
        var h, s, l = (max4 + min4) / 2;
        if (max4 == min4) {
          h = s = 0;
        } else {
          var d = max4 - min4;
          s = l > 0.5 ? d / (2 - max4 - min4) : d / (max4 + min4);
          switch (max4) {
            case r:
              h = (g - b10) / d + (g < b10 ? 6 : 0);
              break;
            case g:
              h = (b10 - r) / d + 2;
              break;
            case b10:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, l };
      }
      function hslToRgb(h, s, l) {
        var r, g, b10;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        if (s === 0) {
          r = g = b10 = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b10 = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b10 * 255 };
      }
      function rgbToHsv(r, g, b10) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b10 = bound01(b10, 255);
        var max4 = mathMax(r, g, b10), min4 = mathMin(r, g, b10);
        var h, s, v = max4;
        var d = max4 - min4;
        s = max4 === 0 ? 0 : d / max4;
        if (max4 == min4) {
          h = 0;
        } else {
          switch (max4) {
            case r:
              h = (g - b10) / d + (g < b10 ? 6 : 0);
              break;
            case g:
              h = (b10 - r) / d + 2;
              break;
            case b10:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return { h, s, v };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i2 = Math2.floor(h), f = h - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod2 = i2 % 6, r = [v, q, p, p, t, v][mod2], g = [t, v, v, q, p, p][mod2], b10 = [p, p, t, v, v, q][mod2];
        return { r: r * 255, g: g * 255, b: b10 * 255 };
      }
      function rgbToHex(r, g, b10, allow3Char) {
        var hex2 = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b10).toString(16))
        ];
        if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToHex(r, g, b10, a, allow4Char) {
        var hex2 = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b10).toString(16)),
          pad2(convertDecimalToHex(a))
        ];
        if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToArgbHex(r, g, b10, a) {
        var hex2 = [
          pad2(convertDecimalToHex(a)),
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b10).toString(16))
        ];
        return hex2.join("");
      }
      tinycolor2.equals = function(color1, color2) {
        if (!color1 || !color2) {
          return false;
        }
        return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
      };
      tinycolor2.random = function() {
        return tinycolor2.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.s -= amount / 100;
        hsl2.s = clamp01(hsl2.s);
        return tinycolor2(hsl2);
      }
      function saturate(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.s += amount / 100;
        hsl2.s = clamp01(hsl2.s);
        return tinycolor2(hsl2);
      }
      function greyscale(color2) {
        return tinycolor2(color2).desaturate(100);
      }
      function lighten(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.l += amount / 100;
        hsl2.l = clamp01(hsl2.l);
        return tinycolor2(hsl2);
      }
      function brighten(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb2 = tinycolor2(color2).toRgb();
        rgb2.r = mathMax(0, mathMin(255, rgb2.r - mathRound(255 * -(amount / 100))));
        rgb2.g = mathMax(0, mathMin(255, rgb2.g - mathRound(255 * -(amount / 100))));
        rgb2.b = mathMax(0, mathMin(255, rgb2.b - mathRound(255 * -(amount / 100))));
        return tinycolor2(rgb2);
      }
      function darken(color2, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.l -= amount / 100;
        hsl2.l = clamp01(hsl2.l);
        return tinycolor2(hsl2);
      }
      function spin(color2, amount) {
        var hsl2 = tinycolor2(color2).toHsl();
        var hue = (hsl2.h + amount) % 360;
        hsl2.h = hue < 0 ? 360 + hue : hue;
        return tinycolor2(hsl2);
      }
      function complement(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        hsl2.h = (hsl2.h + 180) % 360;
        return tinycolor2(hsl2);
      }
      function triad(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h + 120) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h + 240) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function tetrad(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h + 90) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h + 180) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h + 270) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function splitcomplement(color2) {
        var hsl2 = tinycolor2(color2).toHsl();
        var h = hsl2.h;
        return [
          tinycolor2(color2),
          tinycolor2({ h: (h + 72) % 360, s: hsl2.s, l: hsl2.l }),
          tinycolor2({ h: (h + 216) % 360, s: hsl2.s, l: hsl2.l })
        ];
      }
      function analogous(color2, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl2 = tinycolor2(color2).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor2(color2)];
        for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl2.h = (hsl2.h + part) % 360;
          ret.push(tinycolor2(hsl2));
        }
        return ret;
      }
      function monochromatic(color2, results) {
        results = results || 6;
        var hsv = tinycolor2(color2).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor2({ h, s, v }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor2.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor2(color1).toRgb();
        var rgb2 = tinycolor2(color2).toRgb();
        var p = amount / 100;
        var rgba2 = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor2(rgba2);
      };
      tinycolor2.readability = function(color1, color2) {
        var c1 = tinycolor2(color1);
        var c2 = tinycolor2(color2);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor2.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor2.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor2.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size4;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size4 = args.size;
        for (var i2 = 0; i2 < colorList.length; i2++) {
          readability = tinycolor2.readability(baseColor, colorList[i2]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor2(colorList[i2]);
          }
        }
        if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size4 }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor2.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor2.hexNames = flip(names);
      function flip(o) {
        var flipped = {};
        for (var i2 in o) {
          if (o.hasOwnProperty(i2)) {
            flipped[o[i2]] = i2;
          }
        }
        return flipped;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function bound01(n2, max4) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var processPercent = isPercentage(n2);
        n2 = mathMin(max4, mathMax(0, parseFloat(n2)));
        if (processPercent) {
          n2 = parseInt(n2 * max4, 10) / 100;
        }
        if (Math2.abs(n2 - max4) < 1e-6) {
          return 1;
        }
        return n2 % max4 / parseFloat(max4);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n2) {
        return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          n2 = n2 * 100 + "%";
        }
        return n2;
      }
      function convertDecimalToHex(d) {
        return Math2.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color2) {
        return !!matchers.CSS_UNIT.exec(color2);
      }
      function stringInputToObject(color2) {
        color2 = color2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named2 = false;
        if (names[color2]) {
          color2 = names[color2];
          named2 = true;
        } else if (color2 == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match;
        if (match = matchers.rgb.exec(color2)) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color2)) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color2)) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color2)) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color2)) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color2)) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color2)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named2 ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color2)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named2 ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color2)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named2 ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color2)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named2 ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size4;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size4 = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size4 !== "small" && size4 !== "large") {
          size4 = "small";
        }
        return { "level": level, "size": size4 };
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = tinycolor2;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return tinycolor2;
        });
      } else {
        window.tinycolor = tinycolor2;
      }
    })(Math);
  }
});

// ../../node_modules/.pnpm/@hikerpig+moo@0.5.2-beta.2/node_modules/@hikerpig/moo/moo.js
var require_moo = __commonJS({
  "../../node_modules/.pnpm/@hikerpig+moo@0.5.2-beta.2/node_modules/@hikerpig/moo/moo.js"(exports2, module2) {
    (function(root3, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root3.moo = factory();
      }
    })(exports2, function() {
      "use strict";
      var hasOwnProperty3 = Object.prototype.hasOwnProperty;
      var toString5 = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString5.call(o) === "[object RegExp]";
      }
      function isObject3(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length)
          return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase)
            throw new Error("RegExp /i flag not allowed");
          if (obj.global)
            throw new Error("RegExp /g flag is implied");
          if (obj.sticky)
            throw new Error("RegExp /y flag is implied");
          if (obj.multiline)
            throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function objectToRules(object) {
        var keys3 = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i2 = 0; i2 < keys3.length; i2++) {
          var key = keys3[i2];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject3(rule)) {
              if (match.length)
                result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length)
            result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          var obj = array[i2];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject3(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty3.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b10) {
          return isRegExp(a) && isRegExp(b10) ? 0 : isRegExp(b10) ? -1 : isRegExp(a) ? 1 : b10.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          if (rules[i2].fallback) {
            fastAllowed = false;
          }
        }
        for (var i2 = 0; i2 < rules.length; i2++) {
          var options = rules[i2];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true)
          flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile2(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map4) {
        var state = g && (g.push || g.next);
        if (state && !map4[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states8, start) {
        var all = states8.$all ? toRules(states8.$all) : [];
        delete states8.$all;
        var keys3 = Object.getOwnPropertyNames(states8);
        if (!start)
          start = keys3[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys3.length; i2++) {
          var key = keys3[i2];
          ruleMap[key] = toRules(states8[key]).concat(all);
        }
        for (var i2 = 0; i2 < keys3.length; i2++) {
          var key = keys3[i2];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include)
              continue;
            var splice5 = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1)
                  continue;
                splice5.push(newRule);
              }
            }
            rules.splice.apply(rules, splice5);
            j--;
          }
        }
        var map4 = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0; i2 < keys3.length; i2++) {
          var key = keys3[i2];
          map4[key] = compileRules(ruleMap[key], true);
        }
        for (var i2 = 0; i2 < keys3.length; i2++) {
          var name = keys3[i2];
          var state = map4[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map4);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map4);
          }
        }
        return new Lexer(map4, start);
      }
      function keywordTransform(map4) {
        var reverseMap = /* @__PURE__ */ Object.create(null);
        var byLength = /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map4);
        for (var i2 = 0; i2 < types.length; i2++) {
          var tokenType = types[i2];
          var item = map4[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            reverseMap[keyword] = tokenType;
          });
        }
        function str3(x2) {
          return JSON.stringify(x2);
        }
        var source = "";
        source += "switch (value.length) {\n";
        for (var length3 in byLength) {
          var keywords = byLength[length3];
          source += "case " + length3 + ":\n";
          source += "switch (value) {\n";
          keywords.forEach(function(keyword) {
            var tokenType2 = reverseMap[keyword];
            source += "case " + str3(keyword) + ": return " + str3(tokenType2) + "\n";
          });
          source += "default: return\n";
          source += "}\n";
        }
        source += "}\n";
        return Function("value", source);
      }
      var Lexer = function(states8, state) {
        this.startState = state;
        this.states = states8;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        this.queuedGroup = null;
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state)
          return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i2 = 0; i2 < groupCount; i2++) {
          if (match[i2 + 1] !== void 0) {
            return this.groups[i2];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index2 = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index2);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index2 === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index2)];
        if (group) {
          return this._token(group, buffer.charAt(index2), index2);
        }
        var re = this.re;
        re.lastIndex = index2;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index2, buffer.length), index2);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index2) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index2, match.index), index2);
        }
        return this._token(group, text, index2);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl2 = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl2 = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size4 = text.length;
        this.index += size4;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size4 - nl2 + 1;
        } else {
          this.col += size4;
        }
        if (group.shouldThrow) {
          throw new Error(this.formatError(token, "invalid syntax"));
        }
        if (group.pop)
          this.popState();
        else if (group.push)
          this.pushState(group.push);
        else if (group.next)
          this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer9) {
          this.lexer = lexer9;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var start = Math.max(0, token.offset - token.col + 1);
        var eol = token.lineBreaks ? token.text.indexOf("\n") : token.text.length;
        var firstLine = this.buffer.substring(start, token.offset + eol);
        message += " at line " + token.line + " col " + token.col + ":\n\n";
        message += "  " + firstLine + "\n";
        message += "  " + Array(token.col).join(" ") + "^";
        return message;
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile: compile2,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// ../../node_modules/.pnpm/@hikerpig+nearley@2.21.0-beta.1/node_modules/@hikerpig/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "../../node_modules/.pnpm/@hikerpig+nearley@2.21.0-beta.1/node_modules/@hikerpig/nearley/lib/nearley.js"(exports2, module2) {
    (function(root3, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root3.nearley = factory();
      }
    })(exports2, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State(rule, dot2, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot2;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node2 = this;
        do {
          children.push(node2.right.data);
          node2 = node2.left;
        } while (node2.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar9, index2) {
        this.grammar = grammar9;
        this.index = index2;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states8 = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states8.length; w++) {
          var state = states8[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i2 = wantedBy.length; i2--; ) {
                var left = wantedBy[i2];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i2 = 0; i2 < nulls.length; i2++) {
                  var right = nulls[i2];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          var r = rules[i2];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy4 = left.nextState(right);
        this.states.push(copy4);
      };
      function Grammar(rules, start, options) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        this.options = options || {};
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer9 = rules.Lexer;
        var options = rules.ParserOptions;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start, options);
        g.lexer = lexer9;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1)
            nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i2) {
            return pad2(this.line - lines.length + i2 + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad2("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad2(n2, length3) {
          var s = String(n2);
          return Array(length3 - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar9 = rules;
          var options = start;
        } else {
          var grammar9 = Grammar.fromCompiled(rules, start, {});
        }
        this.grammar = grammar9;
        this.options = {
          keepHistory: false,
          lexer: grammar9.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar9, 0);
        var table = this.table = [column];
        column.wants[grammar9.start] = [];
        column.predict(grammar9.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer9 = this.lexer;
        lexer9.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer9.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n2 = this.current + 1;
          var nextColumn = new Column(this.grammar, n2);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer9.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n2 - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            if (nextColumn.grammar.options.skipUnmatchSymbols.length) {
              const shouldIgnore = nextColumn.grammar.options.skipUnmatchSymbols.some(function name(s) {
                if (s.test ? s.test(value) : s.type ? s.type === token.type : s.literal === literal) {
                  return true;
                }
              });
              if (shouldIgnore) {
                this.table.pop();
                continue;
              }
            }
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer9.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer9.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index2 = column.index;
        this.current = index2;
        this.table[index2] = column;
        this.table.splice(index2 + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index2) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index2]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// ../../node_modules/.pnpm/dayjs@1.10.7/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../../node_modules/.pnpm/dayjs@1.10.7/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n2 = 36e5, r = "millisecond", i2 = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $2 = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e3, n3) {
        var r2 = String(t2);
        return !r2 || r2.length >= e3 ? t2 : "" + Array(e3 + 1 - r2.length).join(n3) + t2;
      }, g = { s: m, z: function(t2) {
        var e3 = -t2.utcOffset(), n3 = Math.abs(e3), r2 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e3 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i3, 2, "0");
      }, m: function t2(e3, n3) {
        if (e3.date() < n3.date())
          return -t2(n3, e3);
        var r2 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r2, f), s2 = n3 - i3 < 0, u2 = e3.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n3 - i3) / (s2 ? i3 - u2 : u2 - i3)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i2, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, D = "en", v = {};
      v[D] = M;
      var p = function(t2) {
        return t2 instanceof _3;
      }, S = function(t2, e3, n3) {
        var r2;
        if (!t2)
          return D;
        if ("string" == typeof t2)
          v[t2] && (r2 = t2), e3 && (v[t2] = e3, r2 = t2);
        else {
          var i3 = t2.name;
          v[i3] = t2, r2 = i3;
        }
        return !n3 && r2 && (D = r2), r2 || !n3 && D;
      }, w = function(t2, e3) {
        if (p(t2))
          return t2.clone();
        var n3 = "object" == typeof e3 ? e3 : {};
        return n3.date = t2, n3.args = arguments, new _3(n3);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e3) {
        return w(t2, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
      };
      var _3 = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e3 = t3.date, n3 = t3.utc;
            if (null === e3)
              return /* @__PURE__ */ new Date(NaN);
            if (O.u(e3))
              return /* @__PURE__ */ new Date();
            if (e3 instanceof Date)
              return new Date(e3);
            if ("string" == typeof e3 && !/Z$/i.test(e3)) {
              var r2 = e3.match(l);
              if (r2) {
                var i3 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e3);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $2);
        }, m2.isSame = function(t2, e3) {
          var n3 = w(t2);
          return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
        }, m2.isAfter = function(t2, e3) {
          return w(t2) < this.startOf(e3);
        }, m2.isBefore = function(t2, e3) {
          return this.endOf(e3) < w(t2);
        }, m2.$g = function(t2, e3, n3) {
          return O.u(t2) ? this[e3] : this.set(n3, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e3) {
          var n3 = this, r2 = !!O.u(e3) || e3, h2 = O.p(t2), $3 = function(t3, e4) {
            var i3 = O.w(n3.$u ? Date.UTC(n3.$y, e4, t3) : new Date(n3.$y, e4, t3), n3);
            return r2 ? i3 : i3.endOf(a);
          }, l2 = function(t3, e4) {
            return O.w(n3.toDate()[t3].apply(n3.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
          }, y3 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $3(1, 0) : $3(31, 11);
            case f:
              return r2 ? $3(1, M3) : $3(0, M3 + 1);
            case o:
              var D2 = this.$locale().weekStart || 0, v2 = (y3 < D2 ? y3 + 7 : y3) - D2;
              return $3(r2 ? m3 - v2 : m3 + (6 - v2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i2:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e3) {
          var n3, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $3 = (n3 = {}, n3[a] = h2 + "Date", n3[d] = h2 + "Date", n3[f] = h2 + "Month", n3[c] = h2 + "FullYear", n3[u] = h2 + "Hours", n3[s] = h2 + "Minutes", n3[i2] = h2 + "Seconds", n3[r] = h2 + "Milliseconds", n3)[o2], l2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
          if (o2 === f || o2 === c) {
            var y3 = this.clone().set(d, 1);
            y3.$d[$3](l2), y3.init(), this.$d = y3.set(d, Math.min(this.$D, y3.daysInMonth())).$d;
          } else
            $3 && this.$d[$3](l2);
          return this.init(), this;
        }, m2.set = function(t2, e3) {
          return this.clone().$set(t2, e3);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $3 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y3 = function(t2) {
            var e3 = w($3);
            return O.w(e3.date(e3.date() + Math.round(t2 * r2)), $3);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y3(1);
          if (l2 === o)
            return y3(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n2, d2[i2] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e3) {
          return this.add(-1 * t2, e3);
        }, m2.format = function(t2) {
          var e3 = this, n3 = this.$locale();
          if (!this.isValid())
            return n3.invalidDate || $2;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n3.weekdays, f2 = n3.months, h2 = function(t3, n4, i4, s3) {
            return t3 && (t3[n4] || t3(e3, r2)) || i4[n4].substr(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n3.meridiem || function(t3, e4, n4) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n4 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n3.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n3.weekdaysMin, this.$W, o2, 2), ddd: h2(n3.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i3 };
          return r2.replace(y2, function(t3, e4) {
            return e4 || l2[t3] || i3.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $3) {
          var l2, y3 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, D2 = O.m(this, M3);
          return D2 = (l2 = {}, l2[c] = D2 / 12, l2[f] = D2, l2[h] = D2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n2, l2[s] = g2 / e, l2[i2] = g2 / t, l2)[y3] || g2, $3 ? D2 : O.a(D2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return v[this.$L];
        }, m2.locale = function(t2, e3) {
          if (!t2)
            return this.$L;
          var n3 = this.clone(), r2 = S(t2, e3, true);
          return r2 && (n3.$L = r2), n3;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), b10 = _3.prototype;
      return w.prototype = b10, [["$ms", r], ["$s", i2], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        b10[t2[1]] = function(e3) {
          return this.$g(e3, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e3) {
        return t2.$i || (t2(e3, _3, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = v[D], w.Ls = v, w.p = {}, w;
    });
  }
});

// aliases/canvas.js
var require_canvas = __commonJS({
  "aliases/canvas.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports2, module2) {
    "use strict";
    function assertPath(path4) {
      if (typeof path4 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path4));
      }
    }
    function normalizeStringPosix(path4, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots2 = 0;
      var code;
      for (var i2 = 0; i2 <= path4.length; ++i2) {
        if (i2 < path4.length)
          code = path4.charCodeAt(i2);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i2 - 1 || dots2 === 1) {
          } else if (lastSlash !== i2 - 1 && dots2 === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i2;
                  dots2 = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i2;
                dots2 = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path4.slice(lastSlash + 1, i2);
            else
              res = path4.slice(lastSlash + 1, i2);
            lastSegmentLength = i2 - lastSlash - 1;
          }
          lastSlash = i2;
          dots2 = 0;
        } else if (code === 46 && dots2 !== -1) {
          ++dots2;
        } else {
          dots2 = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
          var path4;
          if (i2 >= 0)
            path4 = arguments[i2];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path4 = cwd;
          }
          assertPath(path4);
          if (path4.length === 0) {
            continue;
          }
          resolvedPath = path4 + "/" + resolvedPath;
          resolvedAbsolute = path4.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize4(path4) {
        assertPath(path4);
        if (path4.length === 0)
          return ".";
        var isAbsolute = path4.charCodeAt(0) === 47;
        var trailingSeparator = path4.charCodeAt(path4.length - 1) === 47;
        path4 = normalizeStringPosix(path4, !isAbsolute);
        if (path4.length === 0 && !isAbsolute)
          path4 = ".";
        if (path4.length > 0 && trailingSeparator)
          path4 += "/";
        if (isAbsolute)
          return "/" + path4;
        return path4;
      },
      isAbsolute: function isAbsolute(path4) {
        assertPath(path4);
        return path4.length > 0 && path4.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i2 = 0; i2 < arguments.length; ++i2) {
          var arg = arguments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length3 = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i2 = 0;
        for (; i2 <= length3; ++i2) {
          if (i2 === length3) {
            if (toLen > length3) {
              if (to.charCodeAt(toStart + i2) === 47) {
                return to.slice(toStart + i2 + 1);
              } else if (i2 === 0) {
                return to.slice(toStart + i2);
              }
            } else if (fromLen > length3) {
              if (from.charCodeAt(fromStart + i2) === 47) {
                lastCommonSep = i2;
              } else if (i2 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i2);
          var toCode = to.charCodeAt(toStart + i2);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i2;
        }
        var out = "";
        for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
          if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path4) {
        return path4;
      },
      dirname: function dirname2(path4) {
        assertPath(path4);
        if (path4.length === 0)
          return ".";
        var code = path4.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i2 = path4.length - 1; i2 >= 1; --i2) {
          code = path4.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path4.slice(0, end);
      },
      basename: function basename(path4, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path4);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path4.length) {
          if (ext.length === path4.length && ext === path4)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i2 = path4.length - 1; i2 >= 0; --i2) {
            var code = path4.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path4.length;
          return path4.slice(start, end);
        } else {
          for (i2 = path4.length - 1; i2 >= 0; --i2) {
            if (path4.charCodeAt(i2) === 47) {
              if (!matchedSlash) {
                start = i2 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i2 + 1;
            }
          }
          if (end === -1)
            return "";
          return path4.slice(start, end);
        }
      },
      extname: function extname(path4) {
        assertPath(path4);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i2 = path4.length - 1; i2 >= 0; --i2) {
          var code = path4.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path4.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse9(path4) {
        assertPath(path4);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path4.length === 0)
          return ret;
        var code = path4.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i2 = path4.length - 1;
        var preDotState = 0;
        for (; i2 >= start; --i2) {
          code = path4.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path4.slice(1, end);
            else
              ret.base = ret.name = path4.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path4.slice(1, startDot);
            ret.base = path4.slice(1, end);
          } else {
            ret.name = path4.slice(startPart, startDot);
            ret.base = path4.slice(startPart, end);
          }
          ret.ext = path4.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path4.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module2.exports = posix;
  }
});

// ../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/.pnpm/punycode@1.4.1/node_modules/punycode/punycode.js"(exports2, module2) {
    (function(root3) {
      var freeExports3 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule3 = typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var freeGlobal3 = typeof global == "object" && global;
      if (freeGlobal3.global === freeGlobal3 || freeGlobal3.window === freeGlobal3 || freeGlobal3.self === freeGlobal3) {
        root3 = freeGlobal3;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter2 = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor2 = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map4(array, fn) {
        var length3 = array.length;
        var result = [];
        while (length3--) {
          result[length3] = fn(array[length3]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map4(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length3 = string.length, value, extra;
        while (counter < length3) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length3) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map4(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor2(delta / damp) : delta >> 1;
        delta += floor2(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor2(delta / baseMinusTMin);
        }
        return floor2(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j, index2, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter2);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
          for (oldi = i2, w = 1, k = base; ; k += base) {
            if (index2 >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index2++));
            if (digit >= base || digit > floor2((maxInt - i2) / w)) {
              error("overflow");
            }
            i2 += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor2(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor2(i2 / out) > maxInt - n2) {
            error("overflow");
          }
          n2 += floor2(i2 / out);
          i2 %= out;
          output.splice(i2++, 0, n2);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n2, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n2 = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter2);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n2 && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n2 > floor2((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n2) * handledCPCountPlusOne;
          n2 = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n2 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n2) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor2(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports3 && freeModule3) {
        if (module2.exports == freeExports3) {
          freeModule3.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports3[key] = punycode[key]);
          }
        }
      } else {
        root3.punycode = punycode;
      }
    })(exports2);
  }
});

// ../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../node_modules/.pnpm/has-proto@1.0.1/node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max4 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b10) {
      var arr2 = [];
      for (var i2 = 0; i2 < a.length; i2 += 1) {
        arr2[i2] = a[i2];
      }
      for (var j = 0; j < b10.length; j += 1) {
        arr2[j + a.length] = b10[j];
      }
      return arr2;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr2 = [];
      for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
        arr2[j] = arrLike[i2];
      }
      return arr2;
    };
    var joiny = function(arr2, joiner) {
      var str3 = "";
      for (var i2 = 0; i2 < arr2.length; i2 += 1) {
        str3 += arr2[i2];
        if (i2 + 1 < arr2.length) {
          str3 += joiner;
        }
      }
      return str3;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max4(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs[i2] = "$" + i2;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/.pnpm/hasown@2.0.0/node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.2.2/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.2.2/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
      return x2.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar3 = /\\(\\)?/g;
    var stringToPath3 = function stringToPath4(string) {
      var first = $strSlice(string, 0, 1);
      var last4 = $strSlice(string, -1);
      if (first === "%" && last4 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last4 === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName3, function(match, number4, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar3, "$1") : number4 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath3(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last4 = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last4 === '"' || last4 === "'" || last4 === "`")) && first !== last4) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice2.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice2.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i2 = 0; i2 < boundLength; i2++) {
        boundArgs.push("$" + i2);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind2 = __commonJS({
  "../../node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind2();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/.pnpm/get-intrinsic@1.1.2/node_modules/get-intrinsic/index.js
var require_get_intrinsic2 = __commonJS({
  "../../node_modules/.pnpm/get-intrinsic@1.1.2/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind2();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName3 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar3 = /\\(\\)?/g;
    var stringToPath3 = function stringToPath4(string) {
      var first = $strSlice(string, 0, 1);
      var last4 = $strSlice(string, -1);
      if (first === "%" && last4 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last4 === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName3, function(match, number4, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar3, "$1") : number4 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/g, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath3(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
        var part = parts[i2];
        var first = $strSlice(part, 0, 1);
        var last4 = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last4 === '"' || last4 === "'" || last4 === "`")) && first !== last4) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i2 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/.pnpm/has-property-descriptors@1.0.0/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/.pnpm/has-property-descriptors@1.0.0/node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic2();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/.pnpm/gopd@1.0.1/node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../../node_modules/.pnpm/define-data-property@1.1.1/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/.pnpm/define-data-property@1.1.1/node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property3, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property3 !== "string" && typeof property3 !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property3);
      if ($defineProperty) {
        $defineProperty(obj, property3, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property3] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../../node_modules/.pnpm/set-function-length@1.1.1/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/.pnpm/set-function-length@1.1.1/node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length3) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length3 !== "number" || length3 < 0 || length3 > 4294967295 || $floor(length3) !== length3) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(fn, "length", length3, true, true);
        } else {
          define2(fn, "length", length3);
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/.pnpm/call-bind@1.0.5/node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):../../node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../../node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/util.inspect"() {
  }
});

// ../../node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString3 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str3) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str3)) {
        return str3;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str3, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str3, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol3(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has3(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str3 = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str3) : str3;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray3(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf2(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has3(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys3 = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
      }
      if (isSymbol3(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i2 = 0; i2 < attrs.length; i2++) {
          s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray3(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap2(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet2(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber3(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString3(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag3 = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag2 = constructorTag + (stringTag3 || protoTag ? "[" + $join.call($concat.call([], stringTag3 || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag2 + "{}";
        }
        if (indent) {
          return tag2 + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag2 + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray3(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString3(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber3(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol3(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has3(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString3.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf2(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i2 = 0, l = xs.length; i2 < l; i2++) {
        if (xs[i2] === x2) {
          return i2;
        }
      }
      return -1;
    }
    function isMap2(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet2(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str3, opts) {
      if (str3.length > opts.maxStringLength) {
        var remaining = str3.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str3, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str3, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n2 = c.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n2];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
    }
    function markBoxed(str3) {
      return "Object(" + str3 + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size4, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size4 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i2 = 0; i2 < xs.length; i2++) {
        if (indexOf2(xs[i2], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray3(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i2 = 0; i2 < obj.length; i2++) {
          xs[i2] = has3(obj, i2) ? inspect(obj[i2], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has3(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node2 = listGetNode(objects, key);
      return node2 && node2.value;
    };
    var listSet = function(objects, key, value) {
      var node2 = listGetNode(objects, key);
      if (node2) {
        node2.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i2 = 0; i2 < 256; ++i2) {
        array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray3(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i2 = 0; i2 < source.length; ++i2) {
        if (typeof source[i2] !== "undefined") {
          obj[i2] = source[i2];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray3(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has3.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray3(target) && !isArray3(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray3(target) && isArray3(source)) {
        source.forEach(function(item, i2) {
          if (has3.call(target, i2)) {
            var targetItem = target[i2];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i2] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i2] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has3.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str3, decoder, charset) {
      var strWithoutPlus = str3.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str3, defaultEncoder, charset, kind, format) {
      if (str3.length === 0) {
        return str3;
      }
      var string = str3;
      if (typeof str3 === "symbol") {
        string = Symbol.prototype.toString.call(str3);
      } else if (typeof str3 !== "string") {
        string = String(str3);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i2 = 0; i2 < string.length; ++i2) {
        var c = string.charCodeAt(i2);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i2);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i2 += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact2 = function compact3(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i2 = 0; i2 < queue.length; ++i2) {
        var item = queue[i2];
        var obj = item.obj[item.prop];
        var keys3 = Object.keys(obj);
        for (var j = 0; j < keys3.length; ++j) {
          var key = keys3[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer3 = function isBuffer4(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b10) {
      return [].concat(a, b10);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray3(val)) {
        var mapped = [];
        for (var i2 = 0; i2 < val.length; i2 += 1) {
          mapped.push(fn(val[i2]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact: compact2,
      decode,
      encode,
      isBuffer: isBuffer3,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has3 = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray3 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr2, valueOrArray) {
      push.apply(arr2, isArray3(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults2 = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date2) {
        return toISO.call(date2);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter3, sort2, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter3 === "function") {
        obj = filter3(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray3(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values4 = [];
      if (typeof obj === "undefined") {
        return values4;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray3(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray3(filter3)) {
        objKeys = filter3;
      } else {
        var keys3 = Object.keys(obj);
        objKeys = sort2 ? keys3.sort(sort2) : keys3;
      }
      var adjustedPrefix = commaRoundTrip && isArray3(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values4, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray3(obj) ? null : encoder,
          filter3,
          sort2,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values4;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults2.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has3.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter3 = defaults2.filter;
      if (typeof opts.filter === "function" || isArray3(opts.filter)) {
        filter3 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
        filter: filter3,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter3;
      if (typeof options.filter === "function") {
        filter3 = options.filter;
        obj = filter3("", obj);
      } else if (isArray3(options.filter)) {
        filter3 = options.filter;
        objKeys = filter3;
      }
      var keys3 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i2 = 0; i2 < objKeys.length; ++i2) {
        var key = objKeys[i2];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys3, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys3.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray3 = Array.isArray;
    var defaults2 = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str3) {
      return str3.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str3, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str3.replace(/^\?/, "") : str3;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i2;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (parts[i2].indexOf("utf8=") === 0) {
            if (parts[i2] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i2] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i2;
            i2 = parts.length;
          }
        }
      }
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (i2 === skipIndex) {
          continue;
        }
        var part = parts[i2];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults2.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults2.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray3(val) ? [val] : val;
        }
        if (has3.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i2 = chain.length - 1; i2 >= 0; --i2) {
        var obj;
        var root3 = chain[i2];
        if (root3 === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root3.charAt(0) === "[" && root3.charAt(root3.length - 1) === "]" ? root3.slice(1, -1) : root3;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root3 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys3 = [];
      if (parent) {
        if (!options.plainObjects && has3.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys3.push(parent);
      }
      var i2 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
        i2 += 1;
        if (!options.plainObjects && has3.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys3.push(segment[1]);
      }
      if (segment) {
        keys3.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys3, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
      };
    };
    module2.exports = function(str3, opts) {
      var options = normalizeParseOptions(opts);
      if (str3 === "" || str3 === null || typeof str3 === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str3 === "string" ? parseValues(str3, options) : str3;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys3 = Object.keys(tempObj);
      for (var i2 = 0; i2 < keys3.length; ++i2) {
        var key = keys3[i2];
        var newObj = parseKeys(key, tempObj[key], options, typeof str3 === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/qs@6.11.2/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse9 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse9,
      stringify
    };
  }
});

// ../../node_modules/.pnpm/url@0.11.3/node_modules/url/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/url@0.11.3/node_modules/url/url.js"(exports2) {
    "use strict";
    var punycode = require_punycode();
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    var unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    var hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_lib();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof url === "object" && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
          var hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i2 = 0; i2 < nonHostChars.length; i2++) {
          var hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i2 = 0, l = hostparts.length; i2 < l; i2++) {
            var part = hostparts[i2];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i2 = 0, l = autoEscape.length; i2 < l; i2++) {
          var ae = autoEscape[i2];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source) {
        return relative;
      }
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys3 = Object.keys(relative);
          for (var v = 0; v < keys3.length; v++) {
            var k = keys3[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last4 = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last4 === "." || last4 === "..") || last4 === "";
      var up = 0;
      for (var i2 = srcPath.length; i2 >= 0; i2--) {
        last4 = srcPath[i2];
        if (last4 === ".") {
          srcPath.splice(i2, 1);
        } else if (last4 === "..") {
          srcPath.splice(i2, 1);
          up++;
        } else if (up) {
          srcPath.splice(i2, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports2.parse = urlParse;
    exports2.resolve = urlResolve;
    exports2.resolveObject = urlResolveObject;
    exports2.format = urlFormat;
    exports2.Url = Url;
  }
});

// aliases/url.js
var require_url2 = __commonJS({
  "aliases/url.js"(exports2, module2) {
    var URL = require_url();
    module2.exports = {
      ...URL,
      fileURLToPath(s) {
        return s || "";
      }
    };
  }
});

// ../../node_modules/.pnpm/emitter-component@1.1.2/node_modules/emitter-component/index.js
var require_emitter_component = __commonJS({
  "../../node_modules/.pnpm/emitter-component@1.1.2/node_modules/emitter-component/index.js"(exports2, module2) {
    module2.exports = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin2(obj);
    }
    function mixin2(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      var self2 = this;
      this._callbacks = this._callbacks || {};
      function on() {
        self2.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks[event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks[event];
        return this;
      }
      var cb;
      for (var i2 = 0; i2 < callbacks.length; i2++) {
        cb = callbacks[i2];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i2, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i2 = 0, len2 = callbacks.length; i2 < len2; ++i2) {
          callbacks[i2].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks[event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// ../../node_modules/.pnpm/stream@0.0.2/node_modules/stream/index.js
var require_stream = __commonJS({
  "../../node_modules/.pnpm/stream@0.0.2/node_modules/stream/index.js"(exports2, module2) {
    var Emitter = require_emitter_component();
    function Stream() {
      Emitter.call(this);
    }
    Stream.prototype = new Emitter();
    module2.exports = Stream;
    Stream.Stream = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup2();
        if (!this.hasListeners("error")) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup2() {
        source.off("data", ondata);
        dest.off("drain", ondrain);
        source.off("end", onend);
        source.off("close", onclose);
        source.off("error", onerror);
        dest.off("error", onerror);
        source.off("end", cleanup2);
        source.off("close", cleanup2);
        dest.off("end", cleanup2);
        dest.off("close", cleanup2);
      }
      source.on("end", cleanup2);
      source.on("close", cleanup2);
      dest.on("end", cleanup2);
      dest.on("close", cleanup2);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength2;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len2 = code.length; i2 < len2; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len2;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len3 = b64.length;
      if (len3 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len3;
      var placeHoldersLen = validLen === len3 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len3 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len3; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr2[curByte++] = tmp >> 16 & 255;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      return arr2;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint82, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint82[i3] << 16 & 16711680) + (uint82[i3 + 1] << 8 & 65280) + (uint82[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint82) {
      var tmp;
      var len3 = uint82.length;
      var extraBytes = len3 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len3 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint82, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len3 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len3 - 2] << 8) + uint82[len3 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer5;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr2 = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr2, proto);
        return arr2.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer5.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer5.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer5.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length3) {
      if (length3 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length3);
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function Buffer5(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from(arg, encodingOrOffset, length3);
    }
    Buffer5.poolSize = 8192;
    function from(value, encodingOrOffset, length3) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length3);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length3);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer5.from(valueOf, encodingOrOffset, length3);
      }
      const b10 = fromObject(value);
      if (b10)
        return b10;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer5.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer5.from = function(value, encodingOrOffset, length3) {
      return from(value, encodingOrOffset, length3);
    };
    Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer5, Uint8Array);
    function assertSize(size4) {
      if (typeof size4 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size4 < 0) {
        throw new RangeError('The value "' + size4 + '" is invalid for option "size"');
      }
    }
    function alloc(size4, fill, encoding) {
      assertSize(size4);
      if (size4 <= 0) {
        return createBuffer(size4);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size4).fill(fill, encoding) : createBuffer(size4).fill(fill);
      }
      return createBuffer(size4);
    }
    Buffer5.alloc = function(size4, fill, encoding) {
      return alloc(size4, fill, encoding);
    };
    function allocUnsafe2(size4) {
      assertSize(size4);
      return createBuffer(size4 < 0 ? 0 : checked(size4) | 0);
    }
    Buffer5.allocUnsafe = function(size4) {
      return allocUnsafe2(size4);
    };
    Buffer5.allocUnsafeSlow = function(size4) {
      return allocUnsafe2(size4);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length3 = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length3);
      const actual = buf.write(string, encoding);
      if (actual !== length3) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length3 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length3);
      for (let i2 = 0; i2 < length3; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy4 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy4.buffer, copy4.byteOffset, copy4.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length3) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length3 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length3 === void 0) {
        buf = new Uint8Array(array);
      } else if (length3 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length3);
      }
      Object.setPrototypeOf(buf, Buffer5.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer5.isBuffer(obj)) {
        const len2 = checked(obj.length) | 0;
        const buf = createBuffer(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length3) {
      if (length3 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length3 | 0;
    }
    function SlowBuffer(length3) {
      if (+length3 != length3) {
        length3 = 0;
      }
      return Buffer5.alloc(+length3);
    }
    Buffer5.isBuffer = function isBuffer3(b10) {
      return b10 != null && b10._isBuffer === true && b10 !== Buffer5.prototype;
    };
    Buffer5.compare = function compare(a, b10) {
      if (isInstance(a, Uint8Array))
        a = Buffer5.from(a, a.offset, a.byteLength);
      if (isInstance(b10, Uint8Array))
        b10 = Buffer5.from(b10, b10.offset, b10.byteLength);
      if (!Buffer5.isBuffer(a) || !Buffer5.isBuffer(b10)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b10)
        return 0;
      let x2 = a.length;
      let y2 = b10.length;
      for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
        if (a[i2] !== b10[i2]) {
          x2 = a[i2];
          y2 = b10[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer5.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer5.concat = function concat(list, length3) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer5.alloc(0);
      }
      let i2;
      if (length3 === void 0) {
        length3 = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length3 += list[i2].length;
        }
      }
      const buffer = Buffer5.allocUnsafe(length3);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer5.isBuffer(buf))
              buf = Buffer5.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer5.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength2(string, encoding) {
      if (Buffer5.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len2 = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer5.prototype._isBuffer = true;
    function swap(b10, n2, m) {
      const i2 = b10[n2];
      b10[n2] = b10[m];
      b10[m] = i2;
    }
    Buffer5.prototype.swap16 = function swap16() {
      const len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer5.prototype.swap32 = function swap32() {
      const len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer5.prototype.swap64 = function swap64() {
      const len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer5.prototype.toString = function toString5() {
      const length3 = this.length;
      if (length3 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length3);
      return slowToString.apply(this, arguments);
    };
    Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
    Buffer5.prototype.equals = function equals3(b10) {
      if (!Buffer5.isBuffer(b10))
        throw new TypeError("Argument must be a Buffer");
      if (this === b10)
        return true;
      return Buffer5.compare(this, b10) === 0;
    };
    Buffer5.prototype.inspect = function inspect() {
      let str3 = "";
      const max4 = exports2.INSPECT_MAX_BYTES;
      str3 = this.toString("hex", 0, max4).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max4)
        str3 += " ... ";
      return "<Buffer " + str3 + ">";
    };
    if (customInspectSymbol) {
      Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
    }
    Buffer5.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer5.from(target, target.offset, target.byteLength);
      }
      if (!Buffer5.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len2 = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len2; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer5.from(val, encoding);
      }
      if (Buffer5.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr2.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr2.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr2, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr2, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer5.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer5.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer5.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length3) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length3) {
        length3 = remaining;
      } else {
        length3 = Number(length3);
        if (length3 > remaining) {
          length3 = remaining;
        }
      }
      const strLen = string.length;
      if (length3 > strLen / 2) {
        length3 = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length3; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length3) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length3);
    }
    function asciiWrite(buf, string, offset, length3) {
      return blitBuffer(asciiToBytes(string), buf, offset, length3);
    }
    function base64Write(buf, string, offset, length3) {
      return blitBuffer(base64ToBytes(string), buf, offset, length3);
    }
    function ucs2Write(buf, string, offset, length3) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length3);
    }
    Buffer5.prototype.write = function write(string, offset, length3, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length3 = this.length;
        offset = 0;
      } else if (length3 === void 0 && typeof offset === "string") {
        encoding = offset;
        length3 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length3)) {
          length3 = length3 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length3;
          length3 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length3 === void 0 || length3 > remaining)
        length3 = remaining;
      if (string.length > 0 && (length3 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length3);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length3);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length3);
          case "base64":
            return base64Write(this, string, offset, length3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length3);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer5.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len2) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len2 = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len2)
        end = len2;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer5.prototype.slice = function slice2(start, end) {
      const len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0)
          start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0)
          end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer5.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length3) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul3 *= 256)) {
        val += this[offset + i2] * mul3;
      }
      return val;
    };
    Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul3 = 1;
      while (byteLength3 > 0 && (mul3 *= 256)) {
        val += this[offset + --byteLength3] * mul3;
      }
      return val;
    };
    Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer5.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last4 = this[offset + 7];
      if (first === void 0 || last4 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last4 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer5.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last4 = this[offset + 7];
      if (first === void 0 || last4 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last4;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer5.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul3 *= 256)) {
        val += this[offset + i2] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer5.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      let i2 = byteLength3;
      let mul3 = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul3 *= 256)) {
        val += this[offset + --i2] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer5.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer5.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer5.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer5.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer5.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last4 = this[offset + 7];
      if (first === void 0 || last4 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last4 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer5.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last4 = this[offset + 7];
      if (first === void 0 || last4 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last4);
    });
    Buffer5.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer5.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer5.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer5.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max4, min4) {
      if (!Buffer5.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max4 || value < min4)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul3 = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul3 *= 256)) {
        this[offset + i2] = value / mul3 & 255;
      }
      return offset + byteLength3;
    };
    Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i2 = byteLength3 - 1;
      let mul3 = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul3 *= 256)) {
        this[offset + i2] = value / mul3 & 255;
      }
      return offset + byteLength3;
    };
    Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min4, max4) {
      checkIntBI(value, min4, max4, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min4, max4) {
      checkIntBI(value, min4, max4, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer5.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer5.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = 0;
      let mul3 = 1;
      let sub3 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul3 *= 256)) {
        if (value < 0 && sub3 === 0 && this[offset + i2 - 1] !== 0) {
          sub3 = 1;
        }
        this[offset + i2] = (value / mul3 >> 0) - sub3 & 255;
      }
      return offset + byteLength3;
    };
    Buffer5.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = byteLength3 - 1;
      let mul3 = 1;
      let sub3 = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul3 *= 256)) {
        if (value < 0 && sub3 === 0 && this[offset + i2 + 1] !== 0) {
          sub3 = 1;
        }
        this[offset + i2] = (value / mul3 >> 0) - sub3 & 255;
      }
      return offset + byteLength3;
    };
    Buffer5.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer5.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer5.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer5.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer5.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer5.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer5.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max4, min4) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer5.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer5.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer5.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer5.prototype.copy = function copy4(target, targetStart, start, end) {
      if (!Buffer5.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len2 = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len2;
    };
    Buffer5.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
        const len2 = bytes.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len2];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base3) {
      errors[sym] = class NodeError extends Base3 {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str3, range2, input) {
        let msg = `The value of "${str3}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value, min4, max4, buf, offset, byteLength3) {
      if (value > max4 || value < min4) {
        const n2 = typeof min4 === "bigint" ? "n" : "";
        let range2;
        if (byteLength3 > 3) {
          if (min4 === 0 || min4 === BigInt(0)) {
            range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
          } else {
            range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range2 = `>= ${min4}${n2} and <= ${max4}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length3, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length3 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length3}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str3) {
      str3 = str3.split("=")[0];
      str3 = str3.trim().replace(INVALID_BASE64_RE, "");
      if (str3.length < 2)
        return "";
      while (str3.length % 4 !== 0) {
        str3 = str3 + "=";
      }
      return str3;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length3 = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length3; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length3) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str3) {
      const byteArray = [];
      for (let i2 = 0; i2 < str3.length; ++i2) {
        byteArray.push(str3.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str3, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str3.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str3.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str3) {
      return base64.toByteArray(base64clean(str3));
    }
    function blitBuffer(src, dst, offset, length3) {
      let i2;
      for (i2 = 0; i2 < length3; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length)
          break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require_buffer();
    var Buffer5 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length3) {
      return Buffer5(arg, encodingOrOffset, length3);
    }
    SafeBuffer.prototype = Object.create(Buffer5.prototype);
    copyProps(Buffer5, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length3) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer5(arg, encodingOrOffset, length3);
    };
    SafeBuffer.alloc = function(size4, fill, encoding) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer5(size4);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size4) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer5(size4);
    };
    SafeBuffer.allocUnsafeSlow = function(size4) {
      if (typeof size4 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size4);
    };
  }
});

// ../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer5 = require_safe_buffer().Buffer;
    var isEncoding = Buffer5.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer5.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer5.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i2;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i2 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i2 = 0;
      }
      if (i2 < buf.length)
        return r ? r + this.text(buf, i2) : this.text(buf, i2);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j = buf.length - 1;
      if (j < i2)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r = buf.toString("utf16le", i2);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i2) {
      var n2 = (buf.length - i2) % 3;
      if (n2 === 0)
        return buf.toString("base64", i2);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i2, buf.length - n2);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/.pnpm/sax@1.2.4/node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "../../node_modules/.pnpm/sax@1.2.4/node_modules/sax/lib/sax.js"(exports2) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i2 in o)
            if (o.hasOwnProperty(i2))
              a.push(i2);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          var len2 = parser[buffers[i2]].length;
          if (len2 > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len2);
        }
        var m = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require_stream().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax2.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag2 = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag2.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag2);
      }
      function qname(name, attribute) {
        var i2 = name.indexOf(":");
        var qualName = i2 < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag2 = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag2.ns === parent.ns) {
                tag2.ns = Object.create(parent.ns);
              }
              tag2.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag2 = parser.tag;
          var qn = qname(parser.tagName);
          tag2.prefix = qn.prefix;
          tag2.local = qn.local;
          tag2.uri = tag2.ns[qn.prefix] || "";
          if (tag2.prefix && !tag2.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag2.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag2.ns && parent.ns !== tag2.ns) {
            Object.keys(tag2.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag2.ns[p]
              });
            });
          }
          for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
            var nv = parser.attribList[i2];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag2.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag2 = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag2.ns) {
            x2[i2] = tag2.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag2.ns !== parent.ns) {
            Object.keys(tag2.ns).forEach(function(p) {
              var n2 = tag2.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n2 });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i2++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i2++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad2 = parser.position - parser.startTagPosition;
                  c = new Array(pad2).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                parser[buffer] += parseEntity(parser);
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length3 = arguments.length;
            if (!length3) {
              return "";
            }
            var result = "";
            while (++index2 < length3) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length3 || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// do-nothing:fs
var fs_exports = {};
__export(fs_exports, {
  default: () => fs_default
});
var fs_default;
var init_fs = __esm({
  "do-nothing:fs"() {
    fs_default = false;
  }
});

// ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module2.exports = EventEmitter3;
    module2.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++)
        args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len2 = handler.length;
        var listeners = arrayClone(handler, len2);
        for (var i2 = 0; i2 < len2; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position2, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position2 = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position2 = i2;
            break;
          }
        }
        if (position2 < 0)
          return this;
        if (position2 === 0)
          list.shift();
        else {
          spliceOne(list, position2);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys3 = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys3.length; ++i2) {
          key = keys3[i2];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr2, n2) {
      var copy4 = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy4[i2] = arr2[i2];
      return copy4;
    }
    function spliceOne(list, index2) {
      for (; index2 + 1 < list.length; index2++)
        list[index2] = list[index2 + 1];
      list.pop();
    }
    function unwrapListeners(arr2) {
      var ret = new Array(arr2.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr2[i2].listener || arr2[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../node_modules/.pnpm/queue@6.0.2/node_modules/queue/index.js
var require_queue = __commonJS({
  "../../node_modules/.pnpm/queue@6.0.2/node_modules/queue/index.js"(exports2, module2) {
    var inherits = require_inherits_browser();
    var EventEmitter3 = require_events().EventEmitter;
    module2.exports = Queue;
    module2.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter3.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits(Queue, EventEmitter3);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end) {
      this.jobs = this.jobs.slice(begin, end);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout2 = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err, result) {
        if (once && self2.session === session) {
          once = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err) {
            self2.emit("error", err, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      if (timeout2) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout2);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err) {
          return next(err || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done.call(this, err);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend);
      function onerror(err) {
        self2.end(err);
      }
      function onend(err) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend);
        cb(err, this.results);
      }
    }
    function done(err) {
      this.session++;
      this.running = false;
      this.emit("end", err);
    }
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/bmp.js
var require_bmp = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/bmp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BMP = void 0;
    exports2.BMP = {
      validate(buffer) {
        return "BM" === buffer.toString("ascii", 0, 2);
      },
      calculate(buffer) {
        return {
          height: Math.abs(buffer.readInt32LE(22)),
          width: buffer.readUInt32LE(18)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/ico.js
var require_ico = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/ico.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ICO = void 0;
    var TYPE_ICON = 1;
    var SIZE_HEADER = 2 + 2 + 2;
    var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
    function getSizeFromOffset(buffer, offset) {
      const value = buffer.readUInt8(offset);
      return value === 0 ? 256 : value;
    }
    function getImageSize(buffer, imageIndex) {
      const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
      return {
        height: getSizeFromOffset(buffer, offset + 1),
        width: getSizeFromOffset(buffer, offset)
      };
    }
    exports2.ICO = {
      validate(buffer) {
        const reserved = buffer.readUInt16LE(0);
        const imageCount = buffer.readUInt16LE(4);
        if (reserved !== 0 || imageCount === 0) {
          return false;
        }
        const imageType = buffer.readUInt16LE(2);
        return imageType === TYPE_ICON;
      },
      calculate(buffer) {
        const nbImages = buffer.readUInt16LE(4);
        const imageSize = getImageSize(buffer, 0);
        if (nbImages === 1) {
          return imageSize;
        }
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
          imgs.push(getImageSize(buffer, imageIndex));
        }
        const result = {
          height: imageSize.height,
          images: imgs,
          width: imageSize.width
        };
        return result;
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/cur.js
var require_cur = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/cur.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CUR = void 0;
    var ico_1 = require_ico();
    var TYPE_CURSOR = 2;
    exports2.CUR = {
      validate(buffer) {
        const reserved = buffer.readUInt16LE(0);
        const imageCount = buffer.readUInt16LE(4);
        if (reserved !== 0 || imageCount === 0) {
          return false;
        }
        const imageType = buffer.readUInt16LE(2);
        return imageType === TYPE_CURSOR;
      },
      calculate(buffer) {
        return ico_1.ICO.calculate(buffer);
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/dds.js
var require_dds = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/dds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DDS = void 0;
    exports2.DDS = {
      validate(buffer) {
        return buffer.readUInt32LE(0) === 542327876;
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(12),
          width: buffer.readUInt32LE(16)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/gif.js
var require_gif = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/gif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GIF = void 0;
    var gifRegexp = /^GIF8[79]a/;
    exports2.GIF = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 6);
        return gifRegexp.test(signature);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt16LE(8),
          width: buffer.readUInt16LE(6)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/icns.js
var require_icns = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/icns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ICNS = void 0;
    var SIZE_HEADER = 4 + 4;
    var FILE_LENGTH_OFFSET = 4;
    var ENTRY_LENGTH_OFFSET = 4;
    var ICON_TYPE_SIZE = {
      ICON: 32,
      "ICN#": 32,
      // m => 16 x 16
      "icm#": 16,
      icm4: 16,
      icm8: 16,
      // s => 16 x 16
      "ics#": 16,
      ics4: 16,
      ics8: 16,
      is32: 16,
      s8mk: 16,
      icp4: 16,
      // l => 32 x 32
      icl4: 32,
      icl8: 32,
      il32: 32,
      l8mk: 32,
      icp5: 32,
      ic11: 32,
      // h => 48 x 48
      ich4: 48,
      ich8: 48,
      ih32: 48,
      h8mk: 48,
      // . => 64 x 64
      icp6: 64,
      ic12: 32,
      // t => 128 x 128
      it32: 128,
      t8mk: 128,
      ic07: 128,
      // . => 256 x 256
      ic08: 256,
      ic13: 256,
      // . => 512 x 512
      ic09: 512,
      ic14: 512,
      // . => 1024 x 1024
      ic10: 1024
    };
    function readImageHeader(buffer, imageOffset) {
      const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
      return [
        buffer.toString("ascii", imageOffset, imageLengthOffset),
        buffer.readUInt32BE(imageLengthOffset)
      ];
    }
    function getImageSize(type) {
      const size4 = ICON_TYPE_SIZE[type];
      return { width: size4, height: size4, type };
    }
    exports2.ICNS = {
      validate(buffer) {
        return "icns" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        const bufferLength = buffer.length;
        const fileLength = buffer.readUInt32BE(FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(buffer, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength) {
          return imageSize;
        }
        const result = {
          height: imageSize.height,
          images: [imageSize],
          width: imageSize.width
        };
        while (imageOffset < fileLength && imageOffset < bufferLength) {
          imageHeader = readImageHeader(buffer, imageOffset);
          imageSize = getImageSize(imageHeader[0]);
          imageOffset += imageHeader[1];
          result.images.push(imageSize);
        }
        return result;
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/j2c.js
var require_j2c = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/j2c.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.J2C = void 0;
    exports2.J2C = {
      validate(buffer) {
        return buffer.toString("hex", 0, 4) === "ff4fff51";
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(12),
          width: buffer.readUInt32BE(8)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/jp2.js
var require_jp2 = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/jp2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JP2 = void 0;
    var BoxTypes = {
      ftyp: "66747970",
      ihdr: "69686472",
      jp2h: "6a703268",
      jp__: "6a502020",
      rreq: "72726571",
      xml_: "786d6c20"
    };
    var calculateRREQLength = (box) => {
      const unit2 = box.readUInt8(0);
      let offset = 1 + 2 * unit2;
      const numStdFlags = box.readUInt16BE(offset);
      const flagsLength = numStdFlags * (2 + unit2);
      offset = offset + 2 + flagsLength;
      const numVendorFeatures = box.readUInt16BE(offset);
      const featuresLength = numVendorFeatures * (16 + unit2);
      return offset + 2 + featuresLength;
    };
    var parseIHDR = (box) => {
      return {
        height: box.readUInt32BE(4),
        width: box.readUInt32BE(8)
      };
    };
    exports2.JP2 = {
      validate(buffer) {
        const signature = buffer.toString("hex", 4, 8);
        const signatureLength = buffer.readUInt32BE(0);
        if (signature !== BoxTypes.jp__ || signatureLength < 1) {
          return false;
        }
        const ftypeBoxStart = signatureLength + 4;
        const ftypBoxLength = buffer.readUInt32BE(signatureLength);
        const ftypBox = buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength);
        return ftypBox.toString("hex", 0, 4) === BoxTypes.ftyp;
      },
      calculate(buffer) {
        const signatureLength = buffer.readUInt32BE(0);
        const ftypBoxLength = buffer.readUInt16BE(signatureLength + 2);
        let offset = signatureLength + 4 + ftypBoxLength;
        const nextBoxType = buffer.toString("hex", offset, offset + 4);
        switch (nextBoxType) {
          case BoxTypes.rreq:
            const MAGIC = 4;
            offset = offset + 4 + MAGIC + calculateRREQLength(buffer.slice(offset + 4));
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          case BoxTypes.jp2h:
            return parseIHDR(buffer.slice(offset + 8, offset + 24));
          default:
            throw new TypeError("Unsupported header found: " + buffer.toString("ascii", offset, offset + 4));
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/readUInt.js
var require_readUInt = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/readUInt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readUInt = void 0;
    function readUInt(buffer, bits, offset, isBigEndian2) {
      offset = offset || 0;
      const endian = isBigEndian2 ? "BE" : "LE";
      const methodName = "readUInt" + bits + endian;
      return buffer[methodName].call(buffer, offset);
    }
    exports2.readUInt = readUInt;
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/jpg.js
var require_jpg = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/jpg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JPG = void 0;
    var readUInt_1 = require_readUInt();
    var EXIF_MARKER = "45786966";
    var APP1_DATA_SIZE_BYTES = 2;
    var EXIF_HEADER_BYTES = 6;
    var TIFF_BYTE_ALIGN_BYTES = 2;
    var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
    var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
    var IDF_ENTRY_BYTES = 12;
    var NUM_DIRECTORY_ENTRIES_BYTES = 2;
    function isEXIF(buffer) {
      return buffer.toString("hex", 2, 6) === EXIF_MARKER;
    }
    function extractSize(buffer, index2) {
      return {
        height: buffer.readUInt16BE(index2),
        width: buffer.readUInt16BE(index2 + 2)
      };
    }
    function extractOrientation(exifBlock, isBigEndian2) {
      const idfOffset = 8;
      const offset = EXIF_HEADER_BYTES + idfOffset;
      const idfDirectoryEntries = (0, readUInt_1.readUInt)(exifBlock, 16, offset, isBigEndian2);
      for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
        const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
        const end = start + IDF_ENTRY_BYTES;
        if (start > exifBlock.length) {
          return;
        }
        const block = exifBlock.slice(start, end);
        const tagNumber = (0, readUInt_1.readUInt)(block, 16, 0, isBigEndian2);
        if (tagNumber === 274) {
          const dataFormat = (0, readUInt_1.readUInt)(block, 16, 2, isBigEndian2);
          if (dataFormat !== 3) {
            return;
          }
          const numberOfComponents = (0, readUInt_1.readUInt)(block, 32, 4, isBigEndian2);
          if (numberOfComponents !== 1) {
            return;
          }
          return (0, readUInt_1.readUInt)(block, 16, 8, isBigEndian2);
        }
      }
    }
    function validateExifBlock(buffer, index2) {
      const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index2);
      const byteAlign = exifBlock.toString("hex", EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);
      const isBigEndian2 = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
      const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
      if (isBigEndian2 || isLittleEndian) {
        return extractOrientation(exifBlock, isBigEndian2);
      }
    }
    function validateBuffer(buffer, index2) {
      if (index2 > buffer.length) {
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
      }
      if (buffer[index2] !== 255) {
        throw new TypeError("Invalid JPG, marker table corrupted");
      }
    }
    exports2.JPG = {
      validate(buffer) {
        const SOIMarker = buffer.toString("hex", 0, 2);
        return "ffd8" === SOIMarker;
      },
      calculate(buffer) {
        buffer = buffer.slice(4);
        let orientation;
        let next;
        while (buffer.length) {
          const i2 = buffer.readUInt16BE(0);
          if (isEXIF(buffer)) {
            orientation = validateExifBlock(buffer, i2);
          }
          validateBuffer(buffer, i2);
          next = buffer[i2 + 1];
          if (next === 192 || next === 193 || next === 194) {
            const size4 = extractSize(buffer, i2 + 5);
            if (!orientation) {
              return size4;
            }
            return {
              height: size4.height,
              orientation,
              width: size4.width
            };
          }
          buffer = buffer.slice(i2 + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/ktx.js
var require_ktx = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/ktx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KTX = void 0;
    var SIGNATURE = "KTX 11";
    exports2.KTX = {
      validate(buffer) {
        return SIGNATURE === buffer.toString("ascii", 1, 7);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32LE(40),
          width: buffer.readUInt32LE(36)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/png.js
var require_png = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/png.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PNG = void 0;
    var pngSignature = "PNG\r\n\n";
    var pngImageHeaderChunkName = "IHDR";
    var pngFriedChunkName = "CgBI";
    exports2.PNG = {
      validate(buffer) {
        if (pngSignature === buffer.toString("ascii", 1, 8)) {
          let chunkName = buffer.toString("ascii", 12, 16);
          if (chunkName === pngFriedChunkName) {
            chunkName = buffer.toString("ascii", 28, 32);
          }
          if (chunkName !== pngImageHeaderChunkName) {
            throw new TypeError("Invalid PNG");
          }
          return true;
        }
        return false;
      },
      calculate(buffer) {
        if (buffer.toString("ascii", 12, 16) === pngFriedChunkName) {
          return {
            height: buffer.readUInt32BE(36),
            width: buffer.readUInt32BE(32)
          };
        }
        return {
          height: buffer.readUInt32BE(20),
          width: buffer.readUInt32BE(16)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/pnm.js
var require_pnm = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/pnm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PNM = void 0;
    var PNMTypes = {
      P1: "pbm/ascii",
      P2: "pgm/ascii",
      P3: "ppm/ascii",
      P4: "pbm",
      P5: "pgm",
      P6: "ppm",
      P7: "pam",
      PF: "pfm"
    };
    var Signatures = Object.keys(PNMTypes);
    var handlers = {
      default: (lines) => {
        let dimensions = [];
        while (lines.length > 0) {
          const line = lines.shift();
          if (line[0] === "#") {
            continue;
          }
          dimensions = line.split(" ");
          break;
        }
        if (dimensions.length === 2) {
          return {
            height: parseInt(dimensions[1], 10),
            width: parseInt(dimensions[0], 10)
          };
        } else {
          throw new TypeError("Invalid PNM");
        }
      },
      pam: (lines) => {
        const size4 = {};
        while (lines.length > 0) {
          const line = lines.shift();
          if (line.length > 16 || line.charCodeAt(0) > 128) {
            continue;
          }
          const [key, value] = line.split(" ");
          if (key && value) {
            size4[key.toLowerCase()] = parseInt(value, 10);
          }
          if (size4.height && size4.width) {
            break;
          }
        }
        if (size4.height && size4.width) {
          return {
            height: size4.height,
            width: size4.width
          };
        } else {
          throw new TypeError("Invalid PAM");
        }
      }
    };
    exports2.PNM = {
      validate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        return Signatures.includes(signature);
      },
      calculate(buffer) {
        const signature = buffer.toString("ascii", 0, 2);
        const type = PNMTypes[signature];
        const lines = buffer.toString("ascii", 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/psd.js
var require_psd = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/psd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PSD = void 0;
    exports2.PSD = {
      validate(buffer) {
        return "8BPS" === buffer.toString("ascii", 0, 4);
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt32BE(14),
          width: buffer.readUInt32BE(18)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/svg.js
var require_svg = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/svg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SVG = void 0;
    var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
    var extractorRegExps = {
      height: /\sheight=(['"])([^%]+?)\1/,
      root: svgReg,
      viewbox: /\sviewBox=(['"])(.+?)\1/i,
      width: /\swidth=(['"])([^%]+?)\1/
    };
    var INCH_CM = 2.54;
    var units = {
      in: 96,
      cm: 96 / INCH_CM,
      em: 16,
      ex: 8,
      m: 96 / INCH_CM * 100,
      mm: 96 / INCH_CM / 10,
      pc: 96 / 72 / 12,
      pt: 96 / 72,
      px: 1
    };
    var unitsReg = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`);
    function parseLength(len2) {
      const m = unitsReg.exec(len2);
      if (!m) {
        return void 0;
      }
      return Math.round(Number(m[1]) * (units[m[2]] || 1));
    }
    function parseViewbox(viewbox) {
      const bounds = viewbox.split(" ");
      return {
        height: parseLength(bounds[3]),
        width: parseLength(bounds[2])
      };
    }
    function parseAttributes(root3) {
      const width2 = root3.match(extractorRegExps.width);
      const height = root3.match(extractorRegExps.height);
      const viewbox = root3.match(extractorRegExps.viewbox);
      return {
        height: height && parseLength(height[2]),
        viewbox: viewbox && parseViewbox(viewbox[2]),
        width: width2 && parseLength(width2[2])
      };
    }
    function calculateByDimensions(attrs) {
      return {
        height: attrs.height,
        width: attrs.width
      };
    }
    function calculateByViewbox(attrs, viewbox) {
      const ratio = viewbox.width / viewbox.height;
      if (attrs.width) {
        return {
          height: Math.floor(attrs.width / ratio),
          width: attrs.width
        };
      }
      if (attrs.height) {
        return {
          height: attrs.height,
          width: Math.floor(attrs.height * ratio)
        };
      }
      return {
        height: viewbox.height,
        width: viewbox.width
      };
    }
    exports2.SVG = {
      validate(buffer) {
        const str3 = String(buffer);
        return svgReg.test(str3);
      },
      calculate(buffer) {
        const root3 = buffer.toString("utf8").match(extractorRegExps.root);
        if (root3) {
          const attrs = parseAttributes(root3[0]);
          if (attrs.width && attrs.height) {
            return calculateByDimensions(attrs);
          }
          if (attrs.viewbox) {
            return calculateByViewbox(attrs, attrs.viewbox);
          }
        }
        throw new TypeError("Invalid SVG");
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/tga.js
var require_tga = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/tga.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TGA = void 0;
    exports2.TGA = {
      validate(buffer) {
        return buffer.readUInt16LE(0) === 0 && buffer.readUInt16LE(4) === 0;
      },
      calculate(buffer) {
        return {
          height: buffer.readUInt16LE(14),
          width: buffer.readUInt16LE(12)
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/tiff.js
var require_tiff = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/tiff.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TIFF = void 0;
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var readUInt_1 = require_readUInt();
    function readIFD(buffer, filepath, isBigEndian2) {
      const ifdOffset = (0, readUInt_1.readUInt)(buffer, 32, 4, isBigEndian2);
      let bufferSize = 1024;
      const fileSize = fs.statSync(filepath).size;
      if (ifdOffset + bufferSize > fileSize) {
        bufferSize = fileSize - ifdOffset - 10;
      }
      const endBuffer = Buffer.alloc(bufferSize);
      const descriptor = fs.openSync(filepath, "r");
      fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);
      fs.closeSync(descriptor);
      return endBuffer.slice(2);
    }
    function readValue(buffer, isBigEndian2) {
      const low = (0, readUInt_1.readUInt)(buffer, 16, 8, isBigEndian2);
      const high = (0, readUInt_1.readUInt)(buffer, 16, 10, isBigEndian2);
      return (high << 16) + low;
    }
    function nextTag(buffer) {
      if (buffer.length > 24) {
        return buffer.slice(12);
      }
    }
    function extractTags(buffer, isBigEndian2) {
      const tags = {};
      let temp = buffer;
      while (temp && temp.length) {
        const code = (0, readUInt_1.readUInt)(temp, 16, 0, isBigEndian2);
        const type = (0, readUInt_1.readUInt)(temp, 16, 2, isBigEndian2);
        const length3 = (0, readUInt_1.readUInt)(temp, 32, 4, isBigEndian2);
        if (code === 0) {
          break;
        } else {
          if (length3 === 1 && (type === 3 || type === 4)) {
            tags[code] = readValue(temp, isBigEndian2);
          }
          temp = nextTag(temp);
        }
      }
      return tags;
    }
    function determineEndianness(buffer) {
      const signature = buffer.toString("ascii", 0, 2);
      if ("II" === signature) {
        return "LE";
      } else if ("MM" === signature) {
        return "BE";
      }
    }
    var signatures = [
      // '492049', // currently not supported
      "49492a00",
      "4d4d002a"
      // Big Endian
      // '4d4d002a', // BigTIFF > 4GB. currently not supported
    ];
    exports2.TIFF = {
      validate(buffer) {
        return signatures.includes(buffer.toString("hex", 0, 4));
      },
      calculate(buffer, filepath) {
        if (!filepath) {
          throw new TypeError("Tiff doesn't support buffer");
        }
        const isBigEndian2 = determineEndianness(buffer) === "BE";
        const ifdBuffer = readIFD(buffer, filepath, isBigEndian2);
        const tags = extractTags(ifdBuffer, isBigEndian2);
        const width2 = tags[256];
        const height = tags[257];
        if (!width2 || !height) {
          throw new TypeError("Invalid Tiff. Missing tags");
        }
        return { height, width: width2 };
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/webp.js
var require_webp = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types/webp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WEBP = void 0;
    function calculateExtended(buffer) {
      return {
        height: 1 + buffer.readUIntLE(7, 3),
        width: 1 + buffer.readUIntLE(4, 3)
      };
    }
    function calculateLossless(buffer) {
      return {
        height: 1 + ((buffer[4] & 15) << 10 | buffer[3] << 2 | (buffer[2] & 192) >> 6),
        width: 1 + ((buffer[2] & 63) << 8 | buffer[1])
      };
    }
    function calculateLossy(buffer) {
      return {
        height: buffer.readInt16LE(8) & 16383,
        width: buffer.readInt16LE(6) & 16383
      };
    }
    exports2.WEBP = {
      validate(buffer) {
        const riffHeader = "RIFF" === buffer.toString("ascii", 0, 4);
        const webpHeader = "WEBP" === buffer.toString("ascii", 8, 12);
        const vp8Header = "VP8" === buffer.toString("ascii", 12, 15);
        return riffHeader && webpHeader && vp8Header;
      },
      calculate(buffer) {
        const chunkHeader = buffer.toString("ascii", 12, 16);
        buffer = buffer.slice(20, 30);
        if (chunkHeader === "VP8X") {
          const extendedHeader = buffer[0];
          const validStart = (extendedHeader & 192) === 0;
          const validEnd = (extendedHeader & 1) === 0;
          if (validStart && validEnd) {
            return calculateExtended(buffer);
          } else {
            throw new TypeError("Invalid WebP");
          }
        }
        if (chunkHeader === "VP8 " && buffer[0] !== 47) {
          return calculateLossy(buffer);
        }
        const signature = buffer.toString("hex", 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
          return calculateLossless(buffer);
        }
        throw new TypeError("Invalid WebP");
      }
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typeHandlers = void 0;
    var bmp_1 = require_bmp();
    var cur_1 = require_cur();
    var dds_1 = require_dds();
    var gif_1 = require_gif();
    var icns_1 = require_icns();
    var ico_1 = require_ico();
    var j2c_1 = require_j2c();
    var jp2_1 = require_jp2();
    var jpg_1 = require_jpg();
    var ktx_1 = require_ktx();
    var png_1 = require_png();
    var pnm_1 = require_pnm();
    var psd_1 = require_psd();
    var svg_1 = require_svg();
    var tga_1 = require_tga();
    var tiff_1 = require_tiff();
    var webp_1 = require_webp();
    exports2.typeHandlers = {
      bmp: bmp_1.BMP,
      cur: cur_1.CUR,
      dds: dds_1.DDS,
      gif: gif_1.GIF,
      icns: icns_1.ICNS,
      ico: ico_1.ICO,
      j2c: j2c_1.J2C,
      jp2: jp2_1.JP2,
      jpg: jpg_1.JPG,
      ktx: ktx_1.KTX,
      png: png_1.PNG,
      pnm: pnm_1.PNM,
      psd: psd_1.PSD,
      svg: svg_1.SVG,
      tga: tga_1.TGA,
      tiff: tiff_1.TIFF,
      webp: webp_1.WEBP
    };
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/detector.js
var require_detector = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/detector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detector = void 0;
    var types_1 = require_types();
    var keys3 = Object.keys(types_1.typeHandlers);
    var firstBytes = {
      56: "psd",
      66: "bmp",
      68: "dds",
      71: "gif",
      73: "tiff",
      77: "tiff",
      82: "webp",
      105: "icns",
      137: "png",
      255: "jpg"
    };
    function detector(buffer) {
      const byte = buffer[0];
      if (byte in firstBytes) {
        const type = firstBytes[byte];
        if (type && types_1.typeHandlers[type].validate(buffer)) {
          return type;
        }
      }
      const finder = (key) => types_1.typeHandlers[key].validate(buffer);
      return keys3.find(finder);
    }
    exports2.detector = detector;
  }
});

// ../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/image-size@1.0.2/node_modules/image-size/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = exports2.setConcurrency = exports2.disableTypes = exports2.disableFS = exports2.imageSize = void 0;
    var fs = (init_fs(), __toCommonJS(fs_exports));
    var path4 = require_path_browserify();
    var queue_1 = require_queue();
    var types_1 = require_types();
    var detector_1 = require_detector();
    var MaxBufferSize = 512 * 1024;
    var queue = new queue_1.default({ concurrency: 100, autostart: true });
    var globalOptions = {
      disabledFS: false,
      disabledTypes: []
    };
    function lookup(buffer, filepath) {
      const type = (0, detector_1.detector)(buffer);
      if (typeof type !== "undefined") {
        if (globalOptions.disabledTypes.indexOf(type) > -1) {
          throw new TypeError("disabled file type: " + type);
        }
        if (type in types_1.typeHandlers) {
          const size4 = types_1.typeHandlers[type].calculate(buffer, filepath);
          if (size4 !== void 0) {
            size4.type = type;
            return size4;
          }
        }
      }
      throw new TypeError("unsupported file type: " + type + " (file: " + filepath + ")");
    }
    async function asyncFileToBuffer(filepath) {
      const handle = await fs.promises.open(filepath, "r");
      try {
        const { size: size4 } = await handle.stat();
        if (size4 <= 0) {
          throw new Error("Empty file");
        }
        const bufferSize = Math.min(size4, MaxBufferSize);
        const buffer = Buffer.alloc(bufferSize);
        await handle.read(buffer, 0, bufferSize, 0);
        return buffer;
      } finally {
        await handle.close();
      }
    }
    function syncFileToBuffer(filepath) {
      const descriptor = fs.openSync(filepath, "r");
      try {
        const { size: size4 } = fs.fstatSync(descriptor);
        if (size4 <= 0) {
          throw new Error("Empty file");
        }
        const bufferSize = Math.min(size4, MaxBufferSize);
        const buffer = Buffer.alloc(bufferSize);
        fs.readSync(descriptor, buffer, 0, bufferSize, 0);
        return buffer;
      } finally {
        fs.closeSync(descriptor);
      }
    }
    module2.exports = exports2 = imageSize;
    exports2.default = imageSize;
    function imageSize(input, callback) {
      if (Buffer.isBuffer(input)) {
        return lookup(input);
      }
      if (typeof input !== "string" || globalOptions.disabledFS) {
        throw new TypeError("invalid invocation. input should be a Buffer");
      }
      const filepath = path4.resolve(input);
      if (typeof callback === "function") {
        queue.push(() => asyncFileToBuffer(filepath).then((buffer) => process.nextTick(callback, null, lookup(buffer, filepath))).catch(callback));
      } else {
        const buffer = syncFileToBuffer(filepath);
        return lookup(buffer, filepath);
      }
    }
    exports2.imageSize = imageSize;
    var disableFS = (v) => {
      globalOptions.disabledFS = v;
    };
    exports2.disableFS = disableFS;
    var disableTypes = (types) => {
      globalOptions.disabledTypes = types;
    };
    exports2.disableTypes = disableTypes;
    var setConcurrency = (c) => {
      queue.concurrency = c;
    };
    exports2.setConcurrency = setConcurrency;
    exports2.types = Object.keys(types_1.typeHandlers);
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b10) {
      if (a === b10)
        return true;
      if (a && b10 && typeof a == "object" && typeof b10 == "object") {
        if (a.constructor !== b10.constructor)
          return false;
        var length3, i2, keys3;
        if (Array.isArray(a)) {
          length3 = a.length;
          if (length3 != b10.length)
            return false;
          for (i2 = length3; i2-- !== 0; )
            if (!equal(a[i2], b10[i2]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b10.source && a.flags === b10.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b10.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b10.toString();
        keys3 = Object.keys(a);
        length3 = keys3.length;
        if (length3 !== Object.keys(b10).length)
          return false;
        for (i2 = length3; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b10, keys3[i2]))
            return false;
        for (i2 = length3; i2-- !== 0; ) {
          var key = keys3[i2];
          if (!equal(a[key], b10[key]))
            return false;
        }
        return true;
      }
      return a !== a && b10 !== b10;
    };
  }
});

// ../../node_modules/.pnpm/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "../../node_modules/.pnpm/tiny-inflate@1.0.3/node_modules/tiny-inflate/index.js"(exports2, module2) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i2, sum;
      for (i2 = 0; i2 < delta; ++i2)
        bits[i2] = 0;
      for (i2 = 0; i2 < 30 - delta; ++i2)
        bits[i2 + delta] = i2 / delta | 0;
      for (sum = first, i2 = 0; i2 < 30; ++i2) {
        base[i2] = sum;
        sum += 1 << bits[i2];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i2;
      for (i2 = 0; i2 < 7; ++i2)
        lt.table[i2] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i2 = 0; i2 < 24; ++i2)
        lt.trans[i2] = 256 + i2;
      for (i2 = 0; i2 < 144; ++i2)
        lt.trans[24 + i2] = i2;
      for (i2 = 0; i2 < 8; ++i2)
        lt.trans[24 + 144 + i2] = 280 + i2;
      for (i2 = 0; i2 < 112; ++i2)
        lt.trans[24 + 144 + 8 + i2] = 144 + i2;
      for (i2 = 0; i2 < 5; ++i2)
        dt.table[i2] = 0;
      dt.table[5] = 32;
      for (i2 = 0; i2 < 32; ++i2)
        dt.trans[i2] = i2;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t, lengths2, off, num) {
      var i2, sum;
      for (i2 = 0; i2 < 16; ++i2)
        t.table[i2] = 0;
      for (i2 = 0; i2 < num; ++i2)
        t.table[lengths2[off + i2]]++;
      t.table[0] = 0;
      for (sum = 0, i2 = 0; i2 < 16; ++i2) {
        offs[i2] = sum;
        sum += t.table[i2];
      }
      for (i2 = 0; i2 < num; ++i2) {
        if (lengths2[off + i2])
          t.trans[offs[lengths2[off + i2]]++] = i2;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num)
        return base;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len2 = 0;
      var tag2 = d.tag;
      do {
        cur = 2 * cur + (tag2 & 1);
        tag2 >>>= 1;
        ++len2;
        sum += t.table[len2];
        cur -= t.table[len2];
      } while (cur >= 0);
      d.tag = tag2;
      d.bitcount -= len2;
      return t.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i2, num, length3;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i2 = 0; i2 < 19; ++i2)
        lengths[i2] = 0;
      for (i2 = 0; i2 < hclen; ++i2) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i2]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length3 = tinf_read_bits(d, 2, 3); length3; --length3) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length3 = tinf_read_bits(d, 3, 3); length3; --length3) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length3 = tinf_read_bits(d, 7, 11); length3; --length3) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length3, dist2, offs2;
          var i2;
          sym -= 257;
          length3 = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist2 = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist2], dist_base[dist2]);
          for (i2 = offs2; i2 < offs2 + length3; ++i2) {
            d.dest[d.destLen++] = d.dest[i2];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length3, invlength;
      var i2;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length3 = d.source[d.sourceIndex + 1];
      length3 = 256 * length3 + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length3 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i2 = length3; i2; --i2)
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function")
          return d.dest.slice(0, d.destLen);
        else
          return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module2.exports = tinf_uncompress;
  }
});

// ../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/swap.js"(exports2, module2) {
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap = (b10, n2, m) => {
      let i2 = b10[n2];
      b10[n2] = b10[m];
      b10[m] = i2;
    };
    var swap32 = (array) => {
      const len2 = array.length;
      for (let i2 = 0; i2 < len2; i2 += 4) {
        swap(array, i2, i2 + 3);
        swap(array, i2 + 1, i2 + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian2) {
        swap32(array);
      }
    };
    module2.exports = {
      swap32LE
    };
  }
});

// ../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "../../node_modules/.pnpm/unicode-trie@2.0.0/node_modules/unicode-trie/index.js"(exports2, module2) {
    var inflate = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data) {
        const isBuffer3 = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
        if (isBuffer3 || data instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer3) {
            this.highStart = data.readUInt32LE(0);
            this.errorValue = data.readUInt32LE(4);
            uncompressedLength = data.readUInt32LE(8);
            data = data.slice(12);
          } else {
            const view = new DataView(data.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data = data.subarray(12);
          }
          data = inflate(data, new Uint8Array(uncompressedLength));
          data = inflate(data, new Uint8Array(uncompressedLength));
          swap32LE(data);
          this.data = new Uint32Array(data.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
        }
      }
      get(codePoint) {
        let index2;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint <= 65535) {
          index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint < this.highStart) {
          index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module2.exports = UnicodeTrie;
  }
});

// ../../node_modules/.pnpm/dfa@1.2.0/node_modules/dfa/index.js
var require_dfa = __commonJS({
  "../../node_modules/.pnpm/dfa@1.2.0/node_modules/dfa/index.js"(exports2, module2) {
    "use strict";
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str3) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p = 0; p < str3.length; p++) {
              var c = str3[p];
              lastState = state;
              state = self2.stateTable[state][c];
              if (state === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state = self2.stateTable[INITIAL_STATE][c];
                startRun = null;
              }
              if (state !== FAIL_STATE && startRun == null) {
                startRun = p;
              }
              if (self2.accepting[state]) {
                lastAccepting = p;
              }
              if (state === FAIL_STATE) {
                state = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str3, actions) {
        for (var [start, end, tags] of this.match(str3)) {
          for (var tag2 of tags) {
            if (typeof actions[tag2] === "function") {
              actions[tag2](start, end, str3.slice(start, end + 1));
            }
          }
        }
      }
    };
    module2.exports = StateMachine;
  }
});

// ../../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/clone@2.1.2/node_modules/clone/clone.js"(exports2, module2) {
    var clone3 = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_3) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_3) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_3) {
        nativePromise = function() {
        };
      }
      function clone4(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone4.__isArray(parent2)) {
            child = [];
          } else if (clone4.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone4.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone4.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone4.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone4.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone4.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone4.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      clone4.__getRegExpFlags = __getRegExpFlags;
      return clone4;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone3;
    }
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/streams.js"(exports2) {
    function BrotliInput(buffer) {
      this.buffer = buffer;
      this.pos = 0;
    }
    BrotliInput.prototype.read = function(buf, i2, count) {
      if (this.pos + count > this.buffer.length) {
        count = this.buffer.length - this.pos;
      }
      for (var p = 0; p < count; p++)
        buf[i2 + p] = this.buffer[this.pos + p];
      this.pos += count;
      return count;
    };
    exports2.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    BrotliOutput.prototype.write = function(buf, count) {
      if (this.pos + count > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count), this.pos);
      this.pos += count;
      return count;
    };
    exports2.BrotliOutput = BrotliOutput;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/bit_reader.js"(exports2, module2) {
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i2 = 0; i2 < 4; i2++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i2;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p = 0; p < 32; p++)
            this.buf_[dst + bytes_read + p] = 0;
        }
        if (dst === 0) {
          for (var p = 0; p < 32; p++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module2.exports = BrotliBitReader;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.bin.js"(exports2, module2) {
    module2.exports = "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";
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary-browser.js"(exports2) {
    var base64 = require_base64_js();
    exports2.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/dictionary.js"(exports2) {
    var data = require_dictionary_browser();
    exports2.init = function() {
      exports2.dictionary = data.init();
    };
    exports2.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports2.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports2.minDictionaryWordLength = 4;
    exports2.maxDictionaryWordLength = 24;
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/huffman.js"(exports2) {
    function HuffmanCode(bits, value) {
      this.bits = bits;
      this.value = value;
    }
    exports2.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len2) {
      var step = 1 << len2 - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    function ReplicateValue(table, i2, step, end, code) {
      do {
        end -= step;
        table[i2 + end] = new HuffmanCode(code.bits, code.value);
      } while (end > 0);
    }
    function NextTableBitSize(count, len2, root_bits) {
      var left = 1 << len2 - root_bits;
      while (len2 < MAX_LENGTH) {
        left -= count[len2];
        if (left <= 0)
          break;
        ++len2;
        left <<= 1;
      }
      return len2 - root_bits;
    }
    exports2.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
      var start_table = table;
      var code;
      var len2;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count = new Int32Array(MAX_LENGTH + 1);
      var offset = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count[code_lengths[symbol]]++;
      }
      offset[1] = 0;
      for (len2 = 1; len2 < MAX_LENGTH; len2++) {
        offset[len2 + 1] = offset[len2] + count[len2];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len2 = 1, step = 2; len2 <= root_bits; ++len2, step <<= 1) {
        for (; count[len2] > 0; --count[len2]) {
          code = new HuffmanCode(len2 & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + key, step, table_size, code);
          key = GetNextKey(key, len2);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len2 = root_bits + 1, step = 2; len2 <= MAX_LENGTH; ++len2, step <<= 1) {
        for (; count[len2] > 0; --count[len2]) {
          if ((key & mask) !== low) {
            table += table_size;
            table_bits = NextTableBitSize(count, len2, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
          }
          code = new HuffmanCode(len2 - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
          key = GetNextKey(key, len2);
        }
      }
      return total_size;
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/context.js"(exports2) {
    exports2.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports2.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/prefix.js"(exports2) {
    function PrefixCodeRange(offset, nbits) {
      this.offset = offset;
      this.nbits = nbits;
    }
    exports2.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports2.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports2.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports2.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports2.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/transform.js"(exports2) {
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform(prefix, transform7, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform7;
      this.suffix = new Uint8Array(suffix.length);
      for (var i2 = 0; i2 < prefix.length; i2++)
        this.prefix[i2] = prefix.charCodeAt(i2);
      for (var i2 = 0; i2 < suffix.length; i2++)
        this.suffix[i2] = suffix.charCodeAt(i2);
    }
    var kTransforms = [
      new Transform("", kIdentity, ""),
      new Transform("", kIdentity, " "),
      new Transform(" ", kIdentity, " "),
      new Transform("", kOmitFirst1, ""),
      new Transform("", kUppercaseFirst, " "),
      new Transform("", kIdentity, " the "),
      new Transform(" ", kIdentity, ""),
      new Transform("s ", kIdentity, " "),
      new Transform("", kIdentity, " of "),
      new Transform("", kUppercaseFirst, ""),
      new Transform("", kIdentity, " and "),
      new Transform("", kOmitFirst2, ""),
      new Transform("", kOmitLast1, ""),
      new Transform(", ", kIdentity, " "),
      new Transform("", kIdentity, ", "),
      new Transform(" ", kUppercaseFirst, " "),
      new Transform("", kIdentity, " in "),
      new Transform("", kIdentity, " to "),
      new Transform("e ", kIdentity, " "),
      new Transform("", kIdentity, '"'),
      new Transform("", kIdentity, "."),
      new Transform("", kIdentity, '">'),
      new Transform("", kIdentity, "\n"),
      new Transform("", kOmitLast3, ""),
      new Transform("", kIdentity, "]"),
      new Transform("", kIdentity, " for "),
      new Transform("", kOmitFirst3, ""),
      new Transform("", kOmitLast2, ""),
      new Transform("", kIdentity, " a "),
      new Transform("", kIdentity, " that "),
      new Transform(" ", kUppercaseFirst, ""),
      new Transform("", kIdentity, ". "),
      new Transform(".", kIdentity, ""),
      new Transform(" ", kIdentity, ", "),
      new Transform("", kOmitFirst4, ""),
      new Transform("", kIdentity, " with "),
      new Transform("", kIdentity, "'"),
      new Transform("", kIdentity, " from "),
      new Transform("", kIdentity, " by "),
      new Transform("", kOmitFirst5, ""),
      new Transform("", kOmitFirst6, ""),
      new Transform(" the ", kIdentity, ""),
      new Transform("", kOmitLast4, ""),
      new Transform("", kIdentity, ". The "),
      new Transform("", kUppercaseAll, ""),
      new Transform("", kIdentity, " on "),
      new Transform("", kIdentity, " as "),
      new Transform("", kIdentity, " is "),
      new Transform("", kOmitLast7, ""),
      new Transform("", kOmitLast1, "ing "),
      new Transform("", kIdentity, "\n	"),
      new Transform("", kIdentity, ":"),
      new Transform(" ", kIdentity, ". "),
      new Transform("", kIdentity, "ed "),
      new Transform("", kOmitFirst9, ""),
      new Transform("", kOmitFirst7, ""),
      new Transform("", kOmitLast6, ""),
      new Transform("", kIdentity, "("),
      new Transform("", kUppercaseFirst, ", "),
      new Transform("", kOmitLast8, ""),
      new Transform("", kIdentity, " at "),
      new Transform("", kIdentity, "ly "),
      new Transform(" the ", kIdentity, " of "),
      new Transform("", kOmitLast5, ""),
      new Transform("", kOmitLast9, ""),
      new Transform(" ", kUppercaseFirst, ", "),
      new Transform("", kUppercaseFirst, '"'),
      new Transform(".", kIdentity, "("),
      new Transform("", kUppercaseAll, " "),
      new Transform("", kUppercaseFirst, '">'),
      new Transform("", kIdentity, '="'),
      new Transform(" ", kIdentity, "."),
      new Transform(".com/", kIdentity, ""),
      new Transform(" the ", kIdentity, " of the "),
      new Transform("", kUppercaseFirst, "'"),
      new Transform("", kIdentity, ". This "),
      new Transform("", kIdentity, ","),
      new Transform(".", kIdentity, " "),
      new Transform("", kUppercaseFirst, "("),
      new Transform("", kUppercaseFirst, "."),
      new Transform("", kIdentity, " not "),
      new Transform(" ", kIdentity, '="'),
      new Transform("", kIdentity, "er "),
      new Transform(" ", kUppercaseAll, " "),
      new Transform("", kIdentity, "al "),
      new Transform(" ", kUppercaseAll, ""),
      new Transform("", kIdentity, "='"),
      new Transform("", kUppercaseAll, '"'),
      new Transform("", kUppercaseFirst, ". "),
      new Transform(" ", kIdentity, "("),
      new Transform("", kIdentity, "ful "),
      new Transform(" ", kUppercaseFirst, ". "),
      new Transform("", kIdentity, "ive "),
      new Transform("", kIdentity, "less "),
      new Transform("", kUppercaseAll, "'"),
      new Transform("", kIdentity, "est "),
      new Transform(" ", kUppercaseFirst, "."),
      new Transform("", kUppercaseAll, '">'),
      new Transform(" ", kIdentity, "='"),
      new Transform("", kUppercaseFirst, ","),
      new Transform("", kIdentity, "ize "),
      new Transform("", kUppercaseAll, "."),
      new Transform("\xC2\xA0", kIdentity, ""),
      new Transform(" ", kIdentity, ","),
      new Transform("", kUppercaseFirst, '="'),
      new Transform("", kUppercaseAll, '="'),
      new Transform("", kIdentity, "ous "),
      new Transform("", kUppercaseAll, ", "),
      new Transform("", kUppercaseFirst, "='"),
      new Transform(" ", kUppercaseFirst, ","),
      new Transform(" ", kUppercaseAll, '="'),
      new Transform(" ", kUppercaseAll, ", "),
      new Transform("", kUppercaseAll, ","),
      new Transform("", kUppercaseAll, "("),
      new Transform("", kUppercaseAll, ". "),
      new Transform(" ", kUppercaseAll, "."),
      new Transform("", kUppercaseAll, "='"),
      new Transform(" ", kUppercaseAll, ". "),
      new Transform(" ", kUppercaseFirst, '="'),
      new Transform(" ", kUppercaseAll, "='"),
      new Transform(" ", kUppercaseFirst, "='")
    ];
    exports2.kTransforms = kTransforms;
    exports2.kNumTransforms = kTransforms.length;
    function ToUpperCase(p, i2) {
      if (p[i2] < 192) {
        if (p[i2] >= 97 && p[i2] <= 122) {
          p[i2] ^= 32;
        }
        return 1;
      }
      if (p[i2] < 224) {
        p[i2 + 1] ^= 32;
        return 2;
      }
      p[i2 + 2] ^= 5;
      return 3;
    }
    exports2.transformDictionaryWord = function(dst, idx, word, len2, transform7) {
      var prefix = kTransforms[transform7].prefix;
      var suffix = kTransforms[transform7].suffix;
      var t = kTransforms[transform7].transform;
      var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
      var i2 = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len2) {
        skip = len2;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len2 -= skip;
      if (t <= kOmitLast9) {
        len2 -= t;
      }
      for (i2 = 0; i2 < len2; i2++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i2];
      }
      uppercase = idx - len2;
      if (t === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t === kUppercaseAll) {
        while (len2 > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len2 -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/dec/decode.js"(exports2) {
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context = require_context();
    var Prefix = require_prefix();
    var Transform = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n2;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n2 = br.readBits(3);
      if (n2 > 0) {
        return 17 + n2;
      }
      n2 = br.readBits(3);
      if (n2 > 0) {
        return 8 + n2;
      }
      return 17;
    }
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i2;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i2 = 0; i2 < size_bytes; i2++) {
          var next_byte = br.readBits(8);
          if (i2 + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i2 * 8;
        }
      } else {
        for (i2 = 0; i2 < size_nibbles; ++i2) {
          var next_nibble = br.readBits(4);
          if (i2 + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i2 * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    function ReadSymbol(table, index2, br) {
      var start_index = index2;
      var nbits;
      br.fillBitWindow();
      index2 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table[index2].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index2 += table[index2].value;
        index2 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table[index2].bits;
      return table[index2].value;
    }
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table = [];
      for (var i2 = 0; i2 < 32; i2++)
        table.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table[p].bits;
        code_len = table[p].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat;
          if (repeat > 0) {
            repeat -= 2;
            repeat <<= extra_bits;
          }
          repeat += br.readBits(extra_bits) + 3;
          repeat_delta = repeat - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x2 = 0; x2 < repeat_delta; x2++)
            code_lengths[symbol + x2] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    function ReadHuffmanCode(alphabet_size, tables, table, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i2;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i2 = 0; i2 < num_symbols; ++i2) {
          symbols[i2] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i2]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i2;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i2 = simple_code_or_skip; i2 < CODE_LENGTH_CODES && space > 0; ++i2) {
          var code_len_idx = kCodeLengthCodeOrder[i2];
          var p = 0;
          var v;
          br.fillBitWindow();
          p += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p].bits;
          v = huff[p].value;
          code_length_code_lengths[code_len_idx] = v;
          if (v !== 0) {
            space -= 32 >> v;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    function ReadBlockLength(table, index2, br) {
      var code;
      var nbits;
      code = ReadSymbol(table, index2, br);
      nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
      return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
    }
    function TranslateShortCodes(code, ringbuffer, index2) {
      var val;
      if (code < NUM_DISTANCE_SHORT_CODES) {
        index2 += kDistanceShortCodeIndexOffset[code];
        index2 &= 3;
        val = ringbuffer[index2] + kDistanceShortCodeValueOffset[code];
      } else {
        val = code - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    function MoveToFront(v, index2) {
      var value = v[index2];
      var i2 = index2;
      for (; i2; --i2)
        v[i2] = v[i2 - 1];
      v[0] = value;
    }
    function InverseMoveToFrontTransform(v, v_len) {
      var mtf = new Uint8Array(256);
      var i2;
      for (i2 = 0; i2 < 256; ++i2) {
        mtf[i2] = i2;
      }
      for (i2 = 0; i2 < v_len; ++i2) {
        var index2 = v[i2];
        v[i2] = mtf[index2];
        if (index2)
          MoveToFront(mtf, index2);
      }
    }
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i2;
      var table_size;
      var next = 0;
      for (i2 = 0; i2 < this.num_htrees; ++i2) {
        this.htrees[i2] = next;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
        next += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table;
      var i2;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table = [];
      for (i2 = 0; i2 < HUFFMAN_MAX_TABLE_SIZE; i2++) {
        table[i2] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
      for (i2 = 0; i2 < context_map_size; ) {
        var code;
        br.readMoreInput();
        code = ReadSymbol(table, 0, br);
        if (code === 0) {
          context_map[i2] = 0;
          ++i2;
        } else if (code <= max_run_length_prefix) {
          var reps = 1 + (1 << code) + br.readBits(code);
          while (--reps) {
            if (i2 >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i2] = 0;
            ++i2;
          }
        } else {
          context_map[i2] = code - max_run_length_prefix;
          ++i2;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index2 = tree_type;
      var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index2] & 1)] = block_type;
      ++indexes[index2];
    }
    function CopyUncompressedBlockToOutput(output, len2, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len2 < 8 || br.bit_pos_ + (len2 << 3) < br.bit_end_pos_) {
        while (len2-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len2;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x2 = 0; x2 < tail; x2++)
          ringbuffer[rb_pos + x2] = br.buf_[br_pos + x2];
        nbytes -= tail;
        rb_pos += tail;
        len2 -= tail;
        br_pos = 0;
      }
      for (var x2 = 0; x2 < nbytes; x2++)
        ringbuffer[rb_pos + x2] = br.buf_[br_pos + x2];
      rb_pos += nbytes;
      len2 -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x2 = 0; x2 < rb_pos; x2++)
          ringbuffer[x2] = ringbuffer[rb_size + x2];
      }
      while (rb_pos + len2 >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len2 -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len2) < len2) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    function BrotliDecompressedSize(buffer) {
      var input = new BrotliInput(buffer);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    exports2.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer, output_size) {
      var input = new BrotliInput(buffer);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    exports2.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i2;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x2 = 0; x2 < 3 * HUFFMAN_MAX_TABLE_SIZE; x2++) {
        block_type_trees[x2] = new HuffmanCode(0, 0);
        block_len_trees[x2] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i2 = 0; i2 < 3; ++i2) {
          hgroup[i2].codes = null;
          hgroup[i2].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i2 = 0; i2 < 3; ++i2) {
          num_block_types[i2] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i2] >= 2) {
            ReadHuffmanCode(num_block_types[i2] + 2, block_type_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i2] = ReadBlockLength(block_len_trees, i2 * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i2] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i2 = 0; i2 < num_block_types[0]; ++i2) {
          br.readMoreInput();
          context_modes[i2] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i2 = 0; i2 < 3; ++i2) {
          hgroup[i2].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context.lookupOffsets[context_mode];
        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance3;
          var context;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context.lookupOffsets[context_mode];
              context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
            }
            context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0)
            break;
          if (distance_code < 0) {
            var context;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance3 = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance3 < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance3 > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance3 - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset += word_idx * copy_length;
              if (transform_idx < Transform.kNumTransforms) {
                var len2 = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
                copy_dst += len2;
                pos += len2;
                meta_block_remaining_len -= len2;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance3 + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance3 + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance3;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance3 + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance3 & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    exports2.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// ../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "../../node_modules/.pnpm/brotli@1.3.3/node_modules/brotli/decompress.js"(exports2, module2) {
    module2.exports = require_decode().BrotliDecompressBuffer;
  }
});

// ../pintora-core/lib/logger.js
var logger = {
  debug: (...args) => {
  },
  info: (...args) => {
  },
  warn: (...args) => {
  },
  error: (...args) => {
  },
  fatal: (...args) => {
  }
};

// ../../node_modules/.pnpm/@antv+event-emitter@0.1.3/node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length3 = es.length;
        for (var i2 = 0; i2 < length3; i2++) {
          if (!es[i2]) {
            continue;
          }
          var _a = es[i2], callback = _a.callback, once = _a.once;
          if (once) {
            es.splice(i2, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length3--;
            i2--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i2 = 0; i2 < length_1; i2++) {
            if (events[i2].callback === callback) {
              events.splice(i2, 1);
              length_1--;
              i2--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default = EventEmitter;

// ../pintora-core/lib/diagram-event.js
var DiagramEventManager = class {
  constructor() {
    this.recognizers = [];
    this.emitter = new esm_default();
  }
  addRecognizer(recognizer) {
    if (!this.recognizers.includes(recognizer)) {
      this.recognizers.push(recognizer);
    }
    return () => {
      const index2 = this.recognizers.indexOf(recognizer);
      if (index2 > -1)
        this.recognizers.splice(index2, 1);
    };
  }
  recognizeGraphicEvent(e, ir) {
    const events = [];
    for (const recognizer of this.recognizers) {
      const result = recognizer.recognize(e, ir);
      if (result)
        events.push(result);
    }
    return events;
  }
  feedGraphicEvent(e, ir) {
    const dEvents = this.recognizeGraphicEvent(e, ir);
    for (const dEvent of dEvents) {
      this.emitter.emit(dEvent.type, dEvent);
    }
    return dEvents;
  }
  wireCurrentEventsToRenderer(renderer, diagramIR) {
    for (const [eventName, listeners] of Object.entries(this.emitter.getEvents())) {
      for (const l of listeners) {
        const handler = l.callback;
        this.wireDiagramEventToRenderer(renderer, eventName, handler, diagramIR);
      }
    }
  }
  wireDiagramEventToRenderer(renderer, eventName, handler, diagramIR) {
    return renderer.on(eventName, (graphicEvent) => {
      const dEvents = diagramEventManager.feedGraphicEvent(graphicEvent, diagramIR);
      for (const dEvent of dEvents) {
        handler(dEvent);
      }
    });
  }
  on(evt, handler) {
    const { emitter } = this;
    emitter.on(evt, handler);
    return function dispose() {
      emitter.off(evt, handler);
    };
  }
  once(evt, handler) {
    const { emitter } = this;
    emitter.once(evt, handler);
    return function dispose() {
      emitter.off(evt, handler);
    };
  }
  /**
   * Remove event listeners
   * @param evt - event name, if not passed, all event listeners will be removed
   */
  removeListeners(evt) {
    this.emitter.off(evt);
  }
  /**
   * A type predicate function to narrow DiagramEventItem data type
   * @example
   * ```
   * if (matchEventItem(item, 'er', 'entity')) { // do something with item.data }
   * ```
   */
  matchEventItem(item, diagram, type) {
    return item.diagram === diagram && item.type === type;
  }
};
var diagramEventManager = new DiagramEventManager();
var DiagramEvent = class {
  constructor(graphicEvent, mark, item) {
    this.graphicEvent = graphicEvent;
    this.mark = mark;
    this.item = item;
  }
  get type() {
    return this.graphicEvent.type;
  }
};
function diagramEventMakerFactory(diagram) {
  return (e, mark, id9, type, data) => {
    return new DiagramEvent(e, mark, {
      diagram,
      type,
      id: id9,
      data
    });
  };
}

// ../pintora-core/lib/diagram-registry.js
var DiagramRegistry = class {
  constructor() {
    this.diagrams = {};
  }
  registerDiagram(name, diagram) {
    if (this.diagrams[name]) {
      logger.warn(`[pintora] duplicate diagram: ${name}`);
    } else {
      if (diagram.eventRecognizer) {
        diagramEventManager.addRecognizer(diagram.eventRecognizer);
      }
    }
    this.diagrams[name] = diagram;
  }
  detectDiagram(text) {
    let diagram = this.diagrams["sequenceDiagram"];
    for (const d of Object.values(this.diagrams)) {
      if (d.pattern.test(text)) {
        diagram = d;
        break;
      }
    }
    return diagram;
  }
  getDiagram(name) {
    return this.diagrams[name];
  }
};
var diagramRegistry = new DiagramRegistry();

// ../pintora-core/lib/config.js
var import_deepmerge = __toESM(require_cjs());
var import_clone_deep = __toESM(require_clone_deep());

// ../pintora-core/lib/themes/palette.js
var AYU_LIGHT = {
  white: "#fff",
  lightDark: "#5E666D",
  normalDark: "#3b4044",
  neutralGray: "#f8f8f2",
  cyan: "#55b4d4",
  green: "#9c0",
  orange: "#fdb05e",
  // orangeLight1: '#fec88f', // +10 lightness
  // orangeLight2: '#fee0c1', // +20 lightness
  pink: "#f07171",
  purple: "#af71d0",
  red: "#e45649",
  yellow: "#f5f1be"
};
var DRACULA = {
  white: "#f8f8f2",
  normalDark: "#282a36",
  cyan: "#8be9fd",
  green: "#50fa7b",
  orange: "#ffb86c",
  pink: "#ff79c6",
  // purple: '#bd93f9',
  purple: "#AD78F7",
  purpleDark: "#9a58f5",
  red: "#ff5555",
  yellow: "#f1fa8c"
};
var BLUE_LARK = {
  white: "#EDF4FF",
  normalDark: "#272827",
  cyan: "#A6D8F1",
  green: "#03B59C",
  blue: "#4492FD",
  darkBlue: "#143C9A",
  brightBlue: "#8BBBFD",
  orange: "#ffb86c",
  pink: "#F9DBD8",
  purple: "#AFBCF1",
  red: "#FD514D",
  yellow: "#FEF4D7"
};
var NOTE_BACKGROUND = "#F8EA75";

// ../pintora-core/lib/themes/theme-default.js
var ThemeDefault = class {
  constructor() {
    this.schemeOppsiteTheme = "dark";
    this.primaryColor = AYU_LIGHT.orange;
    this.secondaryColor = AYU_LIGHT.yellow;
    this.teritaryColor = AYU_LIGHT.purple;
    this.primaryLineColor = AYU_LIGHT.normalDark;
    this.secondaryLineColor = AYU_LIGHT.normalDark;
    this.textColor = AYU_LIGHT.normalDark;
    this.primaryTextColor = AYU_LIGHT.normalDark;
    this.secondaryTextColor = AYU_LIGHT.normalDark;
    this.teritaryTextColor = AYU_LIGHT.normalDark;
    this.primaryBorderColor = AYU_LIGHT.normalDark;
    this.secondaryBorderColor = AYU_LIGHT.neutralGray;
    this.canvasBackground = AYU_LIGHT.white;
    this.groupBackground = AYU_LIGHT.white;
    this.background1 = AYU_LIGHT.neutralGray;
    this.noteBackground = NOTE_BACKGROUND;
  }
};

// ../pintora-core/lib/themes/theme-dark.js
var ThemeDark = class {
  constructor() {
    this.isDark = true;
    this.schemeOppsiteTheme = "default";
    this.primaryColor = DRACULA.purpleDark;
    this.secondaryColor = DRACULA.pink;
    this.teritaryColor = DRACULA.cyan;
    this.primaryLineColor = DRACULA.white;
    this.secondaryLineColor = DRACULA.white;
    this.textColor = DRACULA.white;
    this.primaryTextColor = DRACULA.normalDark;
    this.secondaryTextColor = DRACULA.white;
    this.teritaryTextColor = DRACULA.normalDark;
    this.primaryBorderColor = DRACULA.white;
    this.secondaryBorderColor = DRACULA.normalDark;
    this.canvasBackground = DRACULA.normalDark;
    this.groupBackground = DRACULA.normalDark;
    this.background1 = "#555";
    this.noteTextColor = DRACULA.normalDark;
    this.noteBackground = NOTE_BACKGROUND;
  }
};

// ../pintora-core/lib/themes/theme-lark-light.js
var ThemeLarkLight = class {
  constructor() {
    this.schemeOppsiteTheme = "larkDark";
    this.primaryColor = BLUE_LARK.brightBlue;
    this.secondaryColor = BLUE_LARK.cyan;
    this.teritaryColor = BLUE_LARK.cyan;
    this.primaryLineColor = BLUE_LARK.green;
    this.secondaryLineColor = BLUE_LARK.white;
    this.textColor = BLUE_LARK.normalDark;
    this.primaryTextColor = BLUE_LARK.normalDark;
    this.secondaryTextColor = BLUE_LARK.normalDark;
    this.teritaryTextColor = BLUE_LARK.normalDark;
    this.primaryBorderColor = BLUE_LARK.blue;
    this.secondaryBorderColor = BLUE_LARK.normalDark;
    this.canvasBackground = BLUE_LARK.white;
    this.groupBackground = BLUE_LARK.white;
    this.background1 = BLUE_LARK.white;
    this.noteTextColor = BLUE_LARK.normalDark;
    this.noteBackground = NOTE_BACKGROUND;
  }
};

// ../pintora-core/lib/themes/theme-lark-dark.js
var ThemeLarkDark = class {
  constructor() {
    this.isDark = true;
    this.schemeOppsiteTheme = "larkLight";
    this.primaryColor = BLUE_LARK.blue;
    this.secondaryColor = BLUE_LARK.blue;
    this.teritaryColor = BLUE_LARK.darkBlue;
    this.primaryLineColor = BLUE_LARK.green;
    this.secondaryLineColor = BLUE_LARK.white;
    this.textColor = BLUE_LARK.white;
    this.primaryTextColor = BLUE_LARK.white;
    this.secondaryTextColor = BLUE_LARK.white;
    this.teritaryTextColor = BLUE_LARK.white;
    this.primaryBorderColor = BLUE_LARK.blue;
    this.secondaryBorderColor = BLUE_LARK.normalDark;
    this.canvasBackground = BLUE_LARK.normalDark;
    this.groupBackground = BLUE_LARK.normalDark;
    this.background1 = BLUE_LARK.normalDark;
    this.noteTextColor = BLUE_LARK.normalDark;
    this.noteBackground = NOTE_BACKGROUND;
  }
};

// ../pintora-core/lib/themes/index.js
var ThemeRegistry = class {
  constructor() {
    this.themes = {
      default: new ThemeDefault(),
      dark: new ThemeDark(),
      larkLight: new ThemeLarkLight(),
      larkDark: new ThemeLarkDark()
    };
    this.palettes = {
      AYU_LIGHT,
      DRACULA
    };
  }
  registerTheme(name, variables) {
    if (this.themes[name]) {
      console.warn(`[pintora] override theme ${name}`);
    }
    this.themes[name] = variables;
  }
};
var themeRegistry = new ThemeRegistry();

// ../pintora-core/lib/consts.js
var DEFAULT_FONT_FAMILY = "Source Code Pro, sans-serif";

// ../pintora-core/lib/config.js
var config = {
  core: {
    defaultRenderer: "svg",
    defaultFontFamily: DEFAULT_FONT_FAMILY,
    useMaxWidth: false
  },
  themeConfig: {
    theme: "default",
    darkTheme: "dark",
    themeVariables: themeRegistry.themes.default
  }
};
var overwriteArrayMerge = (destinationArray, sourceArray) => sourceArray;
var configApi = {
  getConfig() {
    return config;
  },
  /**
   * Sets the configuration for Pintora.
   */
  setConfig(c) {
    const newConfig = configApi.gnernateNewConfig(c);
    config = newConfig;
  },
  cloneConfig() {
    return (0, import_clone_deep.default)(config);
  },
  replaceConfig(c) {
    config = c;
  },
  /**
   * Genrate new config based on current globalConfig and input partial config
   */
  gnernateNewConfig(c) {
    var _a;
    const newConfig = (0, import_deepmerge.default)(config, c, {
      arrayMerge: overwriteArrayMerge
    });
    if ((_a = c.themeConfig) === null || _a === void 0 ? void 0 : _a.theme) {
      const themeName = c.themeConfig.theme;
      const themeVars = themeRegistry.themes[themeName];
      const configThemeVars = c.themeConfig.themeVariables;
      if (themeVars) {
        newConfig.themeConfig = newConfig.themeConfig || {};
        newConfig.themeConfig.themeVariables = { ...themeVars };
      }
      if (configThemeVars && newConfig.themeConfig.themeVariables) {
        Object.assign(newConfig.themeConfig.themeVariables, configThemeVars);
      }
    }
    return newConfig;
  }
};
var config_default = configApi;

// ../pintora-core/lib/util/util.js
function safeAssign(base, ...attrList) {
  return Object.assign(base || {}, ...attrList);
}
function pick(base, keys3) {
  const out = {};
  keys3.forEach((k) => out[k] = base[k]);
  return out;
}
function compact(list) {
  return list.filter((v) => Boolean(v));
}
function unique(list) {
  const map4 = /* @__PURE__ */ new Map();
  const result = [];
  list.forEach((item) => {
    if (map4.has(item))
      return;
    map4.set(item, item);
    result.push(item);
  });
  return result;
}
var CHARACTERS = "0123456789abcdef";
function makeid(length3) {
  let result = "";
  const CHARACTERSLength = CHARACTERS.length;
  for (let i2 = 0; i2 < length3; i2++) {
    result += CHARACTERS.charAt(Math.floor(Math.random() * CHARACTERSLength));
  }
  return result;
}
function makeIdCounter(offset = 0) {
  let v = offset;
  return {
    reset() {
      v = offset;
    },
    next() {
      v++;
      return v.toString();
    }
  };
}
function last(list) {
  if (!(list && list.length))
    return;
  return list[list.length - 1];
}
function min(arr2, fn) {
  return Math.min(...arr2.map(fn));
}
function max(arr2, fn) {
  return Math.max(...arr2.map(fn));
}
function removeValues(obj, values4 = [void 0, null]) {
  for (const [k, v] of Object.entries(obj)) {
    if (values4.includes(v))
      delete obj[k];
  }
  return obj;
}

// ../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y2 = 0, i2 = arguments.length;
    while (i2--) {
      y2 += arguments[i2] * arguments[i2];
    }
    return Math.sqrt(y2);
  };

// ../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b10) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b10[0], b01 = b10[1], b02 = b10[2];
  var b102 = b10[3], b11 = b10[4], b12 = b10[5];
  var b20 = b10[6], b21 = b10[7], b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x2 = v[0], y2 = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x2 = v[0], y2 = v[1];
  out[0] = x2 * a[0];
  out[1] = x2 * a[1];
  out[2] = x2 * a[2];
  out[3] = y2 * a[3];
  out[4] = y2 * a[4];
  out[5] = y2 * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x2 = q[0], y2 = q[1], z = q[2], w = q[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z2 = z + z;
  var xx = x2 * x22;
  var yx = y2 * x22;
  var yy6 = y2 * y22;
  var zx = z * x22;
  var zy = z * y22;
  var zz = z * z2;
  var wx = w * x22;
  var wy = w * y22;
  var wz = w * z2;
  out[0] = 1 - yy6 - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy6;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width2, height) {
  out[0] = 2 / width2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b10) {
  out[0] = a[0] + b10[0];
  out[1] = a[1] + b10[1];
  out[2] = a[2] + b10[2];
  out[3] = a[3] + b10[3];
  out[4] = a[4] + b10[4];
  out[5] = a[5] + b10[5];
  out[6] = a[6] + b10[6];
  out[7] = a[7] + b10[7];
  out[8] = a[8] + b10[8];
  return out;
}
function subtract(out, a, b10) {
  out[0] = a[0] - b10[0];
  out[1] = a[1] - b10[1];
  out[2] = a[2] - b10[2];
  out[3] = a[3] - b10[3];
  out[4] = a[4] - b10[4];
  out[5] = a[5] - b10[5];
  out[6] = a[6] - b10[6];
  out[7] = a[7] - b10[7];
  out[8] = a[8] - b10[8];
  return out;
}
function multiplyScalar(out, a, b10) {
  out[0] = a[0] * b10;
  out[1] = a[1] * b10;
  out[2] = a[2] * b10;
  out[3] = a[3] * b10;
  out[4] = a[4] * b10;
  out[5] = a[5] * b10;
  out[6] = a[6] * b10;
  out[7] = a[7] * b10;
  out[8] = a[8] * b10;
  return out;
}
function multiplyScalarAndAdd(out, a, b10, scale3) {
  out[0] = a[0] + b10[0] * scale3;
  out[1] = a[1] + b10[1] * scale3;
  out[2] = a[2] + b10[2] * scale3;
  out[3] = a[3] + b10[3] * scale3;
  out[4] = a[4] + b10[4] * scale3;
  out[5] = a[5] + b10[5] * scale3;
  out[6] = a[6] + b10[6] * scale3;
  out[7] = a[7] + b10[7] * scale3;
  out[8] = a[8] + b10[8] * scale3;
  return out;
}
function exactEquals(a, b10) {
  return a[0] === b10[0] && a[1] === b10[1] && a[2] === b10[2] && a[3] === b10[3] && a[4] === b10[4] && a[5] === b10[5] && a[6] === b10[6] && a[7] === b10[7] && a[8] === b10[8];
}
function equals(a, b10) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
}
var mul = multiply;
var sub = subtract;

// ../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add2,
  angle: () => angle,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min2,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotate: () => rotate2,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues2(x2, y2) {
  var out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set2(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function add2(out, a, b10) {
  out[0] = a[0] + b10[0];
  out[1] = a[1] + b10[1];
  return out;
}
function subtract2(out, a, b10) {
  out[0] = a[0] - b10[0];
  out[1] = a[1] - b10[1];
  return out;
}
function multiply2(out, a, b10) {
  out[0] = a[0] * b10[0];
  out[1] = a[1] * b10[1];
  return out;
}
function divide(out, a, b10) {
  out[0] = a[0] / b10[0];
  out[1] = a[1] / b10[1];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min2(out, a, b10) {
  out[0] = Math.min(a[0], b10[0]);
  out[1] = Math.min(a[1], b10[1]);
  return out;
}
function max2(out, a, b10) {
  out[0] = Math.max(a[0], b10[0]);
  out[1] = Math.max(a[1], b10[1]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale2(out, a, b10) {
  out[0] = a[0] * b10;
  out[1] = a[1] * b10;
  return out;
}
function scaleAndAdd(out, a, b10, scale3) {
  out[0] = a[0] + b10[0] * scale3;
  out[1] = a[1] + b10[1] * scale3;
  return out;
}
function distance(a, b10) {
  var x2 = b10[0] - a[0], y2 = b10[1] - a[1];
  return Math.hypot(x2, y2);
}
function squaredDistance(a, b10) {
  var x2 = b10[0] - a[0], y2 = b10[1] - a[1];
  return x2 * x2 + y2 * y2;
}
function length(a) {
  var x2 = a[0], y2 = a[1];
  return Math.hypot(x2, y2);
}
function squaredLength(a) {
  var x2 = a[0], y2 = a[1];
  return x2 * x2 + y2 * y2;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize(out, a) {
  var x2 = a[0], y2 = a[1];
  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a[0] * len2;
  out[1] = a[1] * len2;
  return out;
}
function dot(a, b10) {
  return a[0] * b10[0] + a[1] * b10[1];
}
function cross(out, a, b10) {
  var z = a[0] * b10[1] - a[1] * b10[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp(out, a, b10, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b10[0] - ax);
  out[1] = ay + t * (b10[1] - ay);
  return out;
}
function random(out, scale3) {
  scale3 = scale3 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale3;
  out[1] = Math.sin(r) * scale3;
  return out;
}
function transformMat2(out, a, m) {
  var x2 = a[0], y2 = a[1];
  out[0] = m[0] * x2 + m[2] * y2;
  out[1] = m[1] * x2 + m[3] * y2;
  return out;
}
function transformMat2d(out, a, m) {
  var x2 = a[0], y2 = a[1];
  out[0] = m[0] * x2 + m[2] * y2 + m[4];
  out[1] = m[1] * x2 + m[3] * y2 + m[5];
  return out;
}
function transformMat3(out, a, m) {
  var x2 = a[0], y2 = a[1];
  out[0] = m[0] * x2 + m[3] * y2 + m[6];
  out[1] = m[1] * x2 + m[4] * y2 + m[7];
  return out;
}
function transformMat4(out, a, m) {
  var x2 = a[0];
  var y2 = a[1];
  out[0] = m[0] * x2 + m[4] * y2 + m[12];
  out[1] = m[1] * x2 + m[5] * y2 + m[13];
  return out;
}
function rotate2(out, a, b10, rad) {
  var p0 = a[0] - b10[0], p1 = a[1] - b10[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b10[0];
  out[1] = p0 * sinC + p1 * cosC + b10[1];
  return out;
}
function angle(a, b10) {
  var x1 = a[0], y1 = a[1], x2 = b10[0], y2 = b10[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str2(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals2(a, b10) {
  return a[0] === b10[0] && a[1] === b10[1];
}
function equals2(a, b10) {
  var a0 = a[0], a1 = a[1];
  var b02 = b10[0], b12 = b10[1];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
}
var len = length;
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create2();
  return function(a, stride, offset, count, fn, arg) {
    var i2, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i2 = offset; i2 < l; i2 += stride) {
      vec[0] = a[i2];
      vec[1] = a[i2 + 1];
      fn(vec, vec, arg);
      a[i2] = vec[0];
      a[i2 + 1] = vec[1];
    }
    return a;
  };
}();

// ../../node_modules/.pnpm/@antv+matrix-util@3.0.4/node_modules/@antv/matrix-util/esm/ext.js
var ext_exports = {};
__export(ext_exports, {
  angleTo: () => angleTo,
  direction: () => direction,
  leftRotate: () => leftRotate,
  leftScale: () => leftScale,
  leftTranslate: () => leftTranslate,
  transform: () => transform,
  vertical: () => vertical
});
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v);
  return mat3_exports.multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v);
  return mat3_exports.multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
  return mat3_exports.multiply(out, a1, a);
}
function transform(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len2 = actions.length; i2 < len2; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical(out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }
  return out;
}

// ../pintora-core/lib/util/matrix.js
function createTranslation(x2, y2 = 0) {
  return mat3_exports.fromTranslation(mat3_exports.create(), [x2, y2]);
}
var transform2 = ext_exports.transform;
var translate2 = ext_exports.leftTranslate;
var leftRotate2 = ext_exports.leftRotate;
var leftScale2 = ext_exports.leftScale;
function createRotateAtPoint(x2, y2, rotate4) {
  const newMatrix = transform2(void 0, [
    ["t", -x2, -y2],
    ["r", rotate4],
    ["t", x2, y2]
  ]);
  return newMatrix;
}

// ../pintora-core/lib/util/geometry.js
function getDistance(a, b10) {
  return Math.sqrt(Math.pow(b10.x - a.x, 2) + Math.pow(b10.y - a.y, 2));
}
function getDistanceSegs(points) {
  return points.reduce((out, p, i2, arr2) => {
    if (arr2[i2 + 1]) {
      const d = getDistance(p, arr2[i2 + 1]);
      out.push(d);
    }
    return out;
  }, []);
}
function interpolateAt(p1, p2, proportion) {
  const x2 = p1.x + (p2.x - p1.x) * proportion;
  const y2 = p1.y + (p2.y - p1.y) * proportion;
  return { x: x2, y: y2 };
}
function getPointAt(points, s, isProportion = false) {
  if (s <= 0)
    return;
  const segs = getDistanceSegs(points);
  const totalLength = segs.reduce((out, l) => {
    return out + l;
  }, 0);
  const len2 = isProportion ? totalLength * s : s;
  let lengthLeft = len2;
  for (let i2 = 0; i2 < segs.length; i2++) {
    const segLength = segs[i2];
    if (segLength >= lengthLeft) {
      const p1 = points[i2];
      const p2 = points[i2 + 1];
      return interpolateAt(p1, p2, lengthLeft / segLength);
    } else {
      lengthLeft -= segLength;
    }
  }
}
function clamp(num, min4, max4) {
  return Math.min(Math.max(num, min4), max4);
}
var PositionH;
(function(PositionH2) {
  PositionH2[PositionH2["LEFT"] = 32] = "LEFT";
  PositionH2[PositionH2["CENTER"] = 16] = "CENTER";
  PositionH2[PositionH2["RIGHT"] = 8] = "RIGHT";
})(PositionH || (PositionH = {}));
var PositionV;
(function(PositionV2) {
  PositionV2[PositionV2["TOP"] = 4] = "TOP";
  PositionV2[PositionV2["CENTER"] = 2] = "CENTER";
  PositionV2[PositionV2["BOTTOM"] = 1] = "BOTTOM";
})(PositionV || (PositionV = {}));
function getPositionOfRect(rect, position2) {
  let x2 = rect.x;
  let y2 = rect.y;
  if (position2 & PositionH.CENTER) {
    x2 += rect.width / 2;
  } else if (position2 & PositionH.RIGHT) {
    x2 += rect.width;
  }
  if (position2 & PositionV.CENTER) {
    y2 += rect.height / 2;
  } else if (position2 & PositionV.BOTTOM) {
    y2 += rect.height;
  }
  return { x: x2, y: y2 };
}
function movePointPosition(p, offsets) {
  return {
    x: p.x + offsets.x,
    y: p.y + offsets.y
  };
}

// ../pintora-core/lib/util/text-metric.js
var CanvasTextMetricCalculator = class {
  constructor() {
    this.name = "CanvasTextMetricCalculator";
    this.ctx = void 0;
    this.getCanvasContext = () => {
      if (!this.ctx) {
        const canvas = document.createElement("canvas");
        this.ctx = canvas.getContext("2d");
      }
      return this.ctx;
    };
  }
  calculateTextDimensions(text, font) {
    const lines = text.split("\n");
    let width2 = 0;
    let height = 0;
    const fontSize2 = (font === null || font === void 0 ? void 0 : font.fontSize) || 14;
    lines.forEach((line, i2) => {
      const lineMetric = this.getLineMetric(line, font);
      const w = lineMetric.width;
      width2 = Math.max(w, width2);
      let lineHeight = fontSize2;
      if (i2 === 0) {
        if ("actualBoundingBoxDescent" in lineMetric) {
          lineHeight = lineMetric.actualBoundingBoxAscent + lineMetric.actualBoundingBoxDescent;
        }
      }
      height += lineHeight;
    });
    return {
      width: width2,
      height
    };
  }
  getLineMetric(text, font) {
    const fontSize2 = (font === null || font === void 0 ? void 0 : font.fontSize) || 14;
    const fontFamily2 = (font === null || font === void 0 ? void 0 : font.fontFamily) || "sans-serif";
    const ctx2 = this.getCanvasContext();
    ctx2.font = `${fontSize2}px ${fontFamily2}`;
    return ctx2.measureText(text);
  }
};
var canvasTextCalculator = new CanvasTextMetricCalculator();
var TextMetricBridge = class {
  constructor() {
    this.calculator = canvasTextCalculator;
  }
  setImpl(calculator) {
    this.calculator = calculator;
  }
  calculateTextDimensions(text, font) {
    return this.calculator.calculateTextDimensions(text, font);
  }
};
var textMetrics = new TextMetricBridge();
function calculateTextDimensions(text, font) {
  return textMetrics.calculateTextDimensions(text, font);
}

// ../pintora-core/lib/util/encode.js
function encodeForUrl(code) {
  const encoded = encodeURIComponent(btoa(escape(code)));
  return encoded;
}
function decodeCodeInUrl(input) {
  return unescape(atob(decodeURIComponent(input)));
}

// ../pintora-core/lib/util/mark.js
function makeMark(type, attrs, other) {
  return {
    type,
    ...other || {},
    attrs
  };
}
function cloneMark(mark) {
  const newMark = {
    ...mark,
    attrs: { ...mark.attrs }
  };
  if ("children" in mark) {
    newMark.children = mark.children.map((child) => cloneMark(child));
  }
  return newMark;
}

// ../pintora-core/lib/util/color.js
var import_tinycolor2 = __toESM(require_tinycolor());
var HEX_PATTERN = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
function parseColor(input) {
  let isValid = false;
  let color2 = input;
  if (HEX_PATTERN.test(input)) {
    color2 = input;
    isValid = true;
  } else {
    color2 = input.replace("#", "");
  }
  return {
    color: color2,
    isValid
  };
}

// ../pintora-core/lib/util/artist.js
function makeArtist(opts) {
  const artist4 = opts;
  return artist4;
}

// ../pintora-core/lib/symbol-registry.js
var SymbolRegistry = class {
  constructor() {
    this.symbols = {};
  }
  register(name, sym) {
    if (this.symbols[name]) {
      logger.warn(`[pintora] duplicate symbol: ${name}`);
    }
    this.symbols[name] = sym;
  }
  get(name) {
    return this.symbols[name];
  }
  getSymbols() {
    return this.symbols;
  }
  /**
   * Create and instantiate a symbol mark
   */
  create(name, opts) {
    const { attrs, contentArea } = opts;
    const def = this.symbols[name];
    if (!def)
      return null;
    try {
      let sym = null;
      if (def.type === "factory") {
        const _position = contentArea || { x: 0, y: 0, width: 100, height: 100 };
        const mode = opts.mode || "icon";
        sym = def.factory(_position, { mode });
      } else if (def.type === "prototype") {
        sym = {
          ...def.symbol,
          mark: cloneMark(def.symbol.mark)
        };
      }
      if (sym && def.styleMark) {
        def.styleMark(sym.mark, def, attrs);
      }
      return sym;
    } catch (error) {
      console.error("[symbolRegistry] error in create", error);
      return null;
    }
  }
};
var symbolRegistry = new SymbolRegistry();

// ../pintora-core/lib/config-engine.js
var config_engine_exports = {};
__export(config_engine_exports, {
  interpreteConfigs: () => interpreteConfigs
});
var sizeEvaluator = ({ value }) => {
  const parsed = parseInt(value);
  if (isNaN(parsed))
    return { valid: false };
  return { value: parsed, valid: true };
};
var configValueEvaluators = {
  color({ value }) {
    const parsed = parseColor(value);
    return { value: parsed.color, valid: true };
  },
  size: sizeEvaluator,
  fontSize: sizeEvaluator,
  string({ value }) {
    return { value, valid: true };
  },
  boolean({ value }) {
    return { value: value === "true", valid: true };
  },
  layoutDirection({ value }) {
    return { value, valid: true };
  }
};
function interpreteConfigs(ruleMap, params) {
  const out = {};
  params.forEach((param) => {
    const meta = ruleMap[param.key];
    if (!meta)
      return;
    const valueTypes = Array.isArray(meta.valueType) ? meta.valueType : [meta.valueType];
    for (const valueType of valueTypes) {
      const evaluator = configValueEvaluators[valueType];
      if (!evaluator)
        continue;
      const result = evaluator(param);
      if (result.valid) {
        out[param.key] = result.value;
        return;
      }
    }
  });
  return out;
}

// ../pintora-core/lib/index.js
function parseAndDraw(text, opts) {
  const { onError, config: config2 } = opts;
  const diagram = diagramRegistry.detectDiagram(text);
  if (!diagram) {
    const errMessage = `[pintora] no diagram detected with input: ${text.slice(0, 30)}`;
    logger.warn(errMessage);
    onError && onError(new Error(errMessage));
    return;
  }
  diagram.clear();
  const diagramIR = diagram.parser.parse(text);
  let configForArtist = void 0;
  if (config2 && diagram.configKey && config2[diagram.configKey]) {
    configForArtist = config2[diagram.configKey];
  }
  const graphicIR = diagram.artist.draw(diagramIR, configForArtist, opts);
  return {
    diagramIR,
    graphicIR
  };
}
var util = {
  encodeForUrl,
  decodeCodeInUrl,
  makeMark,
  calculateTextDimensions,
  parseColor,
  tinycolor: import_tinycolor2.default
};

// ../pintora-diagrams/lib/util/base-db.js
var BaseDb = class {
  constructor() {
    this.configParams = [];
    this.overrideConfig = {};
    this.title = "";
  }
  addOverrideConfig(action) {
    if ("error" in action) {
      console.error(action.error);
    } else {
      this.overrideConfig = action.value;
    }
  }
  getBaseDiagramIR() {
    return {
      configParams: this.configParams,
      overrideConfig: this.overrideConfig,
      title: this.title
    };
  }
  clear() {
    this.configParams = [];
    this.overrideConfig = {};
    this.title = "";
  }
};

// ../pintora-diagrams/lib/sequence/db.js
var LINETYPE;
(function(LINETYPE2) {
  LINETYPE2[LINETYPE2["SOLID"] = 0] = "SOLID";
  LINETYPE2[LINETYPE2["DOTTED"] = 1] = "DOTTED";
  LINETYPE2[LINETYPE2["NOTE"] = 2] = "NOTE";
  LINETYPE2[LINETYPE2["SOLID_CROSS"] = 3] = "SOLID_CROSS";
  LINETYPE2[LINETYPE2["DOTTED_CROSS"] = 4] = "DOTTED_CROSS";
  LINETYPE2[LINETYPE2["SOLID_OPEN"] = 5] = "SOLID_OPEN";
  LINETYPE2[LINETYPE2["DOTTED_OPEN"] = 6] = "DOTTED_OPEN";
  LINETYPE2[LINETYPE2["LOOP_START"] = 10] = "LOOP_START";
  LINETYPE2[LINETYPE2["LOOP_END"] = 11] = "LOOP_END";
  LINETYPE2[LINETYPE2["ALT_START"] = 12] = "ALT_START";
  LINETYPE2[LINETYPE2["ALT_ELSE"] = 13] = "ALT_ELSE";
  LINETYPE2[LINETYPE2["ALT_END"] = 14] = "ALT_END";
  LINETYPE2[LINETYPE2["OPT_START"] = 15] = "OPT_START";
  LINETYPE2[LINETYPE2["OPT_END"] = 16] = "OPT_END";
  LINETYPE2[LINETYPE2["ACTIVE_START"] = 17] = "ACTIVE_START";
  LINETYPE2[LINETYPE2["ACTIVE_END"] = 18] = "ACTIVE_END";
  LINETYPE2[LINETYPE2["PAR_START"] = 19] = "PAR_START";
  LINETYPE2[LINETYPE2["PAR_AND"] = 20] = "PAR_AND";
  LINETYPE2[LINETYPE2["PAR_END"] = 21] = "PAR_END";
  LINETYPE2[LINETYPE2["RECT_START"] = 22] = "RECT_START";
  LINETYPE2[LINETYPE2["RECT_END"] = 23] = "RECT_END";
  LINETYPE2[LINETYPE2["SOLID_POINT"] = 24] = "SOLID_POINT";
  LINETYPE2[LINETYPE2["DOTTED_POINT"] = 25] = "DOTTED_POINT";
  LINETYPE2[LINETYPE2["DIVIDER"] = 26] = "DIVIDER";
})(LINETYPE || (LINETYPE = {}));
var ARROWTYPE = {
  FILLED: 0,
  OPEN: 1
};
var PLACEMENT;
(function(PLACEMENT2) {
  PLACEMENT2[PLACEMENT2["LEFTOF"] = 0] = "LEFTOF";
  PLACEMENT2[PLACEMENT2["RIGHTOF"] = 1] = "RIGHTOF";
  PLACEMENT2[PLACEMENT2["OVER"] = 2] = "OVER";
})(PLACEMENT || (PLACEMENT = {}));
var GROUP_TYPE_CONFIGS = {
  loop: { startSignalType: LINETYPE.LOOP_START, endSignalType: LINETYPE.LOOP_END },
  par: { startSignalType: LINETYPE.PAR_START, endSignalType: LINETYPE.PAR_END },
  opt: { startSignalType: LINETYPE.OPT_START, endSignalType: LINETYPE.OPT_END },
  alt: { startSignalType: LINETYPE.ALT_START, endSignalType: LINETYPE.ALT_END },
  else: { startSignalType: LINETYPE.ALT_ELSE, endSignalType: LINETYPE.ALT_END },
  and: { startSignalType: LINETYPE.PAR_AND, endSignalType: LINETYPE.PAR_END }
};
var SequenceDB = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.prevActorId = null;
    this.messages = [];
    this.notes = [];
    this.actors = {};
    this.participantBoxes = {};
    this.title = "";
    this.titleWrapped = false;
    this.wrapEnabled = false;
    this.showSequenceNumbers = false;
    this.actorOrder = /* @__PURE__ */ new Set();
    this.idCounter = makeIdCounter();
  }
  addActor(param) {
    const { actor: name, classifier } = param;
    let { description } = param;
    const id9 = name;
    const old = this.actors[id9];
    if (old && name === old.name && description == null)
      return;
    this.actorOrder.add(id9);
    if (description == null || description.text == null) {
      description = { text: name, wrap: false };
    }
    this.actors[id9] = {
      name,
      description: description.text,
      wrap: description.wrap === void 0 && this.wrapEnabled || !!description.wrap,
      prevActorId: this.prevActorId,
      classifier,
      itemId: `actor-${id9}`
    };
    if (this.prevActorId && this.actors[this.prevActorId]) {
      this.actors[this.prevActorId].nextActorId = id9;
    }
    this.prevActorId = id9;
  }
  addSignal(from, to, message = { text: "", wrap: false }, messageType) {
    if (typeof from === "string") {
      from = { actor: from };
    }
    if (typeof to === "string") {
      to = { actor: to };
    }
    if (messageType === LINETYPE.ACTIVE_END) {
      const cnt = activationCount(this, from.actor);
      if (cnt < 1) {
        const error = new SError("Trying to inactivate an inactive participant (" + from.actor + ")");
        error.hash = {
          text: "->>-",
          token: "->>-",
          line: "1",
          loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
          expected: ["'ACTIVE_PARTICIPANT'"]
        };
        throw error;
      }
    }
    const msgIndex = this.messages.length;
    this.messages.push({
      from: from.actor,
      to: to ? to.actor : "",
      text: message.text || "",
      wrap: message.wrap === void 0 && this.wrapEnabled || !!message.wrap,
      type: messageType,
      itemId: `message-${msgIndex}-${messageType}`
    });
    return true;
  }
  addSignalWithoutActor(message = { text: "", wrap: false }, messageType, attrs) {
    const msgIndex = this.messages.length;
    this.messages.push({
      from: void 0,
      to: void 0,
      text: message.text || "",
      wrap: message.wrap === void 0 && this.wrapEnabled || !!message.wrap,
      type: messageType,
      attrs,
      itemId: `message-${msgIndex}-${messageType}`
    });
  }
  addGroupStart(groupType, text, attrs) {
    const groupConfig = GROUP_TYPE_CONFIGS[groupType];
    if (!groupConfig)
      return;
    if (attrs.background) {
      attrs.background = parseColor(attrs.background).color;
    }
    this.addSignalWithoutActor(text, groupConfig.startSignalType, attrs);
  }
  addGroupEnd(groupType) {
    const groupConfig = GROUP_TYPE_CONFIGS[groupType];
    if (!groupConfig)
      return;
    this.addSignalWithoutActor(void 0, groupConfig.endSignalType);
  }
  addNote(actor, placement, message) {
    const note = {
      actor,
      placement,
      text: message.text,
      wrap: message.wrap === void 0 && this.wrapEnabled || !!message.wrap
    };
    const fromActor = Array.isArray(actor) ? actor[0] : actor;
    const toActor = Array.isArray(actor) ? actor[1] : actor;
    this.notes.push(note);
    const msgIndex = this.messages.length;
    this.messages.push({
      from: fromActor,
      to: toActor,
      text: message.text,
      wrap: message.wrap === void 0 && this.wrapEnabled || !!message.wrap,
      type: LINETYPE.NOTE,
      placement,
      itemId: `message-${msgIndex}-${LINETYPE.NOTE}`
    });
  }
  setTitle(titleWrap) {
    this.title = titleWrap.text;
    this.titleWrapped = titleWrap.wrap === void 0 && this.wrapEnabled || !!titleWrap.wrap;
  }
  parseMessage(str3) {
    const _str = str3.trim();
    const message = {
      text: _str.replace(/\\n/, "\n"),
      wrap: false
    };
    logger.debug("parseMessage:", message);
    return message;
  }
  addParam(sp) {
    this.configParams.push(sp);
  }
  addBox(param) {
    this.apply(param.children);
    const participantBox = {
      actors: [],
      text: param.text,
      id: this.idCounter.next(),
      background: param.background
    };
    param.children.forEach((childAction) => {
      if (childAction.type === "addActor") {
        participantBox.actors.push(childAction.actor);
      }
    });
    if (participantBox.actors.length) {
      this.participantBoxes[participantBox.id] = participantBox;
    }
  }
  getActor(id9) {
    return this.actors[id9];
  }
  getActorKeys() {
    return Object.keys(this.actors);
  }
  clear() {
    super.clear();
    this.prevActorId = null;
    this.messages = [];
    this.notes = [];
    this.actors = {};
    this.actorOrder.clear();
    this.participantBoxes = {};
    this.title = "";
    this.showSequenceNumbers = false;
    this.idCounter.reset();
  }
  prepareBeforeGetIR() {
    for (const box of Object.values(this.participantBoxes)) {
      for (const actorId of box.actors) {
        const actor = this.getActor(actorId);
        if (actor) {
          actor.boxId = box.id;
        }
      }
    }
  }
  getDiagramIR() {
    this.prepareBeforeGetIR();
    return {
      messages: this.messages,
      notes: this.notes,
      actors: this.actors,
      actorOrder: Array.from(this.actorOrder),
      participantBoxes: this.participantBoxes,
      title: this.title,
      showSequenceNumbers: this.showSequenceNumbers,
      configParams: this.configParams,
      overrideConfig: this.overrideConfig
    };
  }
  apply(param) {
    if (!param)
      return;
    if (param instanceof Array) {
      param.forEach((item) => {
        this.apply(item);
      });
    } else {
      logger.debug("apply", param);
      switch (param.type) {
        case "addActor":
          this.addActor(param);
          break;
        case "activeStart":
        case "activeEnd":
          this.addSignal(param.actor, void 0, void 0, param.signalType);
          break;
        case "addNote":
          this.addNote(param.actor, param.placement, param.text);
          break;
        case "addSignal":
          this.addSignal(param.from, param.to, param.msg, param.signalType);
          break;
        case "groupStart":
          this.addGroupStart(param.groupType, param.text, { background: param.background });
          break;
        case "groupEnd":
          this.addGroupEnd(param.groupType);
          break;
        case "addBox":
          this.addBox(param);
          break;
        case "setTitle":
          this.setTitle(param.text);
          break;
        case "addDivider":
          this.addSignalWithoutActor({ text: param.text, wrap: false }, param.signalType);
          break;
        case "addParam":
          this.addParam({ key: param.key, value: param.value });
          break;
        case "overrideConfig":
          this.addOverrideConfig(param);
          break;
      }
    }
  }
};
var db = new SequenceDB();
var SError = class extends Error {
};
var activationCount = (db9, part) => {
  let i2;
  let count = 0;
  for (i2 = 0; i2 < db9.messages.length; i2++) {
    if (db9.messages[i2].type === LINETYPE.ACTIVE_START) {
      if (db9.messages[i2].from === part) {
        count++;
      }
    }
    if (db9.messages[i2].type === LINETYPE.ACTIVE_END) {
      if (db9.messages[i2].from === part) {
        count--;
      }
    }
  }
  return count;
};
function enableSequenceNumbers() {
  db.showSequenceNumbers = true;
}
var db_default = {
  addActor: db.addActor,
  addSignal: db.addSignal,
  enableSequenceNumbers,
  parseMessage: db.parseMessage,
  LINETYPE,
  ARROWTYPE,
  PLACEMENT,
  addNote: db.addNote,
  setTitle: db.setTitle,
  apply: db.apply.bind(db)
};

// ../pintora-diagrams/lib/util/theme.js
var PALETTE = themeRegistry.palettes.AYU_LIGHT;

// ../pintora-diagrams/lib/util/config.js
function baseGetConfigFromGlobalConfig(globalConfig, configContext, configKey9) {
  var _a;
  const coreConfig = safeAssign({}, globalConfig.core, (_a = configContext.overrideConfig) === null || _a === void 0 ? void 0 : _a.core);
  return safeAssign({ fontFamily: coreConfig.defaultFontFamily, useMaxWidth: coreConfig.useMaxWidth }, globalConfig[configKey9] || {});
}
function makeConfigurator(opts) {
  const { configKey: configKey9, defaultConfig: defaultConfig9 } = opts;
  function getConfig2(configContext, extraConfig) {
    var _a, _b;
    const globalConfig = config_default.gnernateNewConfig(configContext.overrideConfig || {});
    const t = (_a = globalConfig.themeConfig) === null || _a === void 0 ? void 0 : _a.themeVariables;
    const conf6 = { ...defaultConfig9 };
    safeAssign(conf6, opts.getConfigFromTheme(t, conf6));
    const getConfigFromGlobalConfig = opts.getConfigFromGlobalConfig || baseGetConfigFromGlobalConfig;
    safeAssign(conf6, getConfigFromGlobalConfig(globalConfig, configContext, configKey9));
    if (extraConfig)
      safeAssign(conf6, extraConfig);
    safeAssign(conf6, (_b = configContext.overrideConfig) === null || _b === void 0 ? void 0 : _b[configKey9]);
    if (opts.getConfigFromParamDirectives) {
      safeAssign(conf6, opts.getConfigFromParamDirectives(configContext.configParams));
    }
    return conf6;
  }
  return {
    getConfig: getConfig2
  };
}
function getParamRulesFromConfig(config2) {
  const out = {};
  for (const [key, value] of Object.entries(config2)) {
    const t = typeof value;
    let valueType;
    if (t === "number") {
      valueType = "size";
    } else if (t === "boolean") {
      valueType = "boolean";
    } else if (t === "string") {
      if (/color|background/.test(key.toLowerCase())) {
        valueType = "color";
      } else {
        valueType = "string";
      }
    }
    if (valueType) {
      out[key] = { valueType };
    }
  }
  return out;
}

// ../pintora-diagrams/lib/sequence/config.js
var defaultConfig = {
  noteWidth: 80,
  noteHeight: 50,
  noteMargin: 10,
  boxMargin: 10,
  activationWidth: 10,
  diagramMarginX: 10,
  diagramMarginY: 10,
  boxTextMargin: 5,
  messageFontSize: 16,
  messageFontFamily: DEFAULT_FONT_FAMILY,
  messageFontWeight: 400,
  messageTextColor: PALETTE.normalDark,
  wrapPadding: 10,
  labelBoxWidth: 50,
  labelBoxHeight: 20,
  loopLineColor: PALETTE.orange,
  mirrorActors: true,
  actorWidth: 80,
  actorHeight: 50,
  actorMargin: 10,
  actorBackground: PALETTE.orange,
  actorBorderColor: PALETTE.normalDark,
  actorTextColor: PALETTE.normalDark,
  actorLineColor: PALETTE.normalDark,
  participantBoxPadding: 10,
  participantBackground: "transparent",
  noteTextColor: PALETTE.normalDark,
  activationBackground: PALETTE.neutralGray,
  dividerFontWeight: 600,
  dividerTextColor: PALETTE.normalDark,
  dividerMargin: 15,
  showSequenceNumbers: false,
  useMaxWidth: false
};
var SEQUENCE_PARAM_DIRECTIVE_RULES = {
  noteMargin: { valueType: "size" },
  boxMargin: { valueType: "size" },
  activationWidth: { valueType: "size" },
  diagramMarginX: { valueType: "size" },
  diagramMarginY: { valueType: "size" },
  boxTextMargin: { valueType: "size" },
  messageFontSize: { valueType: "fontSize" },
  messageFontFamily: { valueType: "string" },
  messageTextColor: { valueType: "color" },
  wrapPadding: { valueType: "size" },
  labelBoxWidth: { valueType: "size" },
  labelBoxHeight: { valueType: "size" },
  loopLineColor: { valueType: "color" },
  actorWidth: { valueType: "size" },
  actorHeight: { valueType: "size" },
  actorMargin: { valueType: "size" },
  actorBackground: { valueType: "color" },
  actorBorderColor: { valueType: "color" },
  actorTextColor: { valueType: "color" },
  actorLineColor: { valueType: "color" },
  noteTextColor: { valueType: "color" },
  activationBackground: { valueType: "color" },
  dividerTextColor: { valueType: "color" },
  useMaxWidth: { valueType: "boolean" }
};
var configKey = "sequence";
var configurator = makeConfigurator({
  defaultConfig,
  configKey,
  getConfigFromGlobalConfig(globalConfig, configContext, configKey9) {
    return safeAssign({
      ...baseGetConfigFromGlobalConfig(globalConfig, configContext, configKey9),
      messageFontFamily: globalConfig.core.defaultFontFamily
    });
  },
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(SEQUENCE_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    return {
      actorBackground: t.primaryColor,
      actorBorderColor: t.primaryBorderColor,
      messageTextColor: t.textColor,
      loopLineColor: t.primaryColor,
      actorTextColor: t.textColor,
      actorLineColor: t.primaryLineColor,
      noteTextColor: t.noteTextColor || t.textColor,
      activationBackground: t.background1,
      dividerTextColor: t.secondaryTextColor
    };
  }
});
var getConf = configurator.getConfig;

// ../pintora-diagrams/lib/util/number.js
function toFixed(num, digits = 2) {
  return parseFloat(num.toFixed(digits));
}

// ../pintora-diagrams/lib/util/arrow/index.js
function drawArrowTo(dest, baseLength, rad, opts) {
  const { x: x2, y: y2 } = dest;
  const xOffset = baseLength / 2 * Math.tan(Math.PI / 3);
  const { type = "default", color: color2 = "transparent", bgColor = "transparent" } = opts;
  const context = { x: x2, y: y2, baseLength, color: color2, bgColor, type, xOffset, arrowTypeRegistry };
  const result = arrowTypeRegistry.draw(context);
  const shapeStartPoint = result.shapeStartPoint || { x: x2 - xOffset, y: y2 };
  const matrix = createRotateAtPoint(x2, y2, rad);
  return {
    type: "path",
    matrix,
    attrs: {
      ...shapeStartPoint,
      ...result.attrs || {},
      ...opts.attrs || {},
      path: result.path || []
    }
  };
}
var defaultHeadDrawer = (context) => {
  const { x: x2, y: y2, color: color2, baseLength } = context;
  const xOffset = baseLength / 2 * Math.tan(Math.PI / 3);
  const path4 = [
    ["M", x2 - xOffset, y2 - baseLength / 2],
    ["L", x2, y2],
    ["L", x2 - xOffset, y2 + baseLength / 2]
    // bottom
  ];
  return {
    path: path4,
    attrs: { stroke: color2, lineCap: "round" }
  };
};
var ArrowTypeRegistry = class {
  constructor() {
    this.drawers = {};
  }
  register(type, drawer) {
    this.drawers[type] = drawer;
  }
  draw(context) {
    const drawer = (context.type ? this.drawers[context.type] : null) || defaultHeadDrawer;
    const result = drawer(context);
    return result;
  }
};
var arrowTypeRegistry = new ArrowTypeRegistry();
arrowTypeRegistry.register("triangle", (context) => {
  const { x: x2, y: y2, xOffset, baseLength, color: color2 } = context;
  const path4 = [
    ["M", x2 - xOffset, y2 - baseLength / 2],
    ["L", x2 - xOffset, y2 + baseLength / 2],
    ["L", x2, y2],
    ["Z"]
  ];
  return {
    path: path4,
    attrs: { fill: color2 }
  };
});
arrowTypeRegistry.register("etriangle", makeStrokeDrawer("triangle"));
arrowTypeRegistry.register("box", (context) => {
  const { x: x2, y: y2, baseLength, color: color2 } = context;
  const side = baseLength;
  const path4 = [
    ["M", x2 - side, y2 - side / 2],
    ["L", x2 - side, y2 + side / 2],
    ["L", x2, y2 + side / 2],
    ["L", x2, y2 - side / 2],
    ["Z"]
  ];
  return {
    path: path4,
    attrs: { fill: color2 }
  };
});
arrowTypeRegistry.register("obox", makeStrokeDrawer("box"));
arrowTypeRegistry.register("dot", (context) => {
  const { x: x2, y: y2, baseLength, color: color2 } = context;
  const radius = baseLength / 2;
  const startX = x2 - radius * 2;
  const path4 = [
    ["M", startX, y2],
    ["A", radius, radius, 0, 0, 0, x2, y2],
    ["A", radius, radius, 0, 0, 0, startX, y2]
  ];
  return {
    path: path4,
    attrs: { fill: color2 }
  };
});
arrowTypeRegistry.register("odot", makeStrokeDrawer("dot"));
arrowTypeRegistry.register("diamond", (context) => {
  const { x: x2, y: y2, baseLength, xOffset, color: color2 } = context;
  const halfW = xOffset;
  const halfH = baseLength / 2;
  const centerX = x2 - halfW;
  const path4 = [
    ["M", centerX - halfW, y2],
    ["l", halfW, halfH],
    ["l", halfW, -halfH],
    ["l", -halfW, -halfH],
    ["Z"]
  ];
  return {
    path: path4,
    attrs: { fill: color2 }
  };
});
function makeStrokeDrawer(fromType) {
  return (context) => {
    const result = context.arrowTypeRegistry.draw({ ...context, type: fromType });
    result.attrs = { stroke: context.color, fill: context.bgColor };
    return result;
  };
}
arrowTypeRegistry.register("ediamond", makeStrokeDrawer("diamond"));

// ../pintora-diagrams/lib/util/artist-util.js
function getBaseText() {
  return {
    x: 0,
    y: 0,
    text: "",
    fill: PALETTE.normalDark
  };
}
function drawCrossTo(dest, baseLength, rad, attrs) {
  const { x: x2, y: y2 } = dest;
  const offset = baseLength / 2;
  const p = [
    ["M", x2 - offset, y2 - offset],
    ["L", x2 + offset, y2 + offset],
    ["M", x2 + offset, y2 - offset],
    ["L", x2 - offset, y2 + offset]
  ];
  const matrix = createRotateAtPoint(x2, y2, rad);
  return {
    type: "path",
    matrix,
    attrs: {
      ...attrs || {},
      path: p
    }
  };
}
function drawDiamondTo(dest, halfW, attrs) {
  const width2 = halfW * 2;
  const centerX = dest.x;
  const centerY = dest.y;
  const diamondMark = makeMark("path", {
    ...attrs,
    width: width2,
    height: width2,
    /* prettier-ignore */
    path: [
      ["m", centerX - halfW, centerY],
      ["l", halfW, halfW],
      ["l", halfW, -halfW],
      ["l", -halfW, -halfW],
      ["Z"]
    ]
  });
  return diamondMark;
}
function calcDirection(start, end) {
  const ox = end.x - start.x;
  const oy = end.y - start.y;
  let r = Math.atan(oy / ox);
  if (ox < 0) {
    r = r + Math.PI;
  }
  return r;
}
function makeLabelBg(labelDims, center, attrs = {}, theme3) {
  let fill = "#fff";
  if (theme3) {
    fill = theme3.canvasBackground || theme3.background1 || (theme3.isDark ? "#000" : "#fff");
  }
  const labelBg = makeMark("rect", {
    x: center.x - labelDims.width / 2,
    y: center.y - labelDims.height / 2,
    width: labelDims.width,
    height: labelDims.height + 2,
    fill,
    opacity: 0.85,
    ...attrs
  }, { class: "label-bg" });
  return labelBg;
}
function adjustRootMarkBounds({ rootMark, gBounds, padX, padY, containerSize, useMaxWidth, titleSize, titleMark }) {
  const containerWidth = containerSize === null || containerSize === void 0 ? void 0 : containerSize.width;
  const doublePadX = padX * 2;
  const titleHeight = (titleSize === null || titleSize === void 0 ? void 0 : titleSize.height) || 0;
  const titleWidth = (titleSize === null || titleSize === void 0 ? void 0 : titleSize.width) || 0;
  const scaleX = useMaxWidth && containerWidth ? containerWidth / Math.max(gBounds.width + doublePadX, titleWidth) : 1;
  rootMark.matrix = mat3_exports.translate(mat3_exports.create(), mat3_exports.fromScaling(mat3_exports.create(), [scaleX, scaleX]), [
    -Math.min(0, gBounds.left) + padX / scaleX,
    -Math.min(0, gBounds.top) + padY / scaleX + titleHeight
  ]);
  const width2 = Math.max(gBounds.width + doublePadX, titleWidth) * scaleX;
  if (titleMark) {
    titleMark.attrs.x = gBounds.left + width2 / 2 - padX;
  }
  return {
    width: width2,
    height: gBounds.height * scaleX + padY * 2 + ((titleSize === null || titleSize === void 0 ? void 0 : titleSize.height) || 0)
  };
}
function makeTitleMark(title, titleFont, attrs) {
  const titleSize = calculateTextDimensions(title, titleFont);
  const titleHeight = titleSize.height;
  return {
    mark: {
      type: "text",
      attrs: {
        text: title,
        x: 0,
        y: -titleHeight,
        ...titleFont,
        ...attrs,
        textAlign: "center",
        fontWeight: "bold"
      }
    },
    titleSize
  };
}
function makeEmptyGroup() {
  return makeMark("group", { x: 0, y: 0 }, { children: [] });
}
function makeCircle(attrs) {
  return makeMark("circle", { x: 0, y: 0, r: 0, ...attrs });
}
var getBaseNote = function(theme3) {
  return {
    x: 0,
    y: 0,
    fill: theme3.noteBackground || theme3.groupBackground,
    stroke: theme3.primaryBorderColor,
    width: 50,
    anchor: "start",
    height: 50,
    rx: 0,
    ry: 0
  };
};
var LayerManager = class {
  constructor() {
    this.layers = {};
  }
  addLayer(name, zIndex) {
    if (!this.layers[name]) {
      this.layers[name] = { zIndex: 0, marks: [] };
    }
    this.layers[name].zIndex = zIndex;
    return this.layers[name];
  }
  getLayer(name) {
    return this.layers[name];
  }
  sortLayerMarks() {
    const layerList = Object.values(this.layers).sort((a, b10) => a.zIndex - b10.zIndex);
    const marks = layerList.reduce((acc, layer) => {
      acc.push(...layer.marks);
      return acc;
    }, []);
    return marks;
  }
  addMark(name, mark) {
    var _a;
    (_a = this.getLayer(name)) === null || _a === void 0 ? void 0 : _a.marks.push(mark);
  }
};
function makeTriangle(center, baseLength, rad, attrs) {
  const { x: x2, y: y2 } = center;
  const offsetX = toFixed(baseLength / 2);
  const offsetY = baseLength * Math.sign(Math.PI / 3) / 2;
  const p = [
    ["M", x2, y2 - offsetY],
    ["L", x2 - offsetX, y2 + offsetY],
    ["L", x2 + offsetX, y2 + offsetY],
    ["Z"]
  ];
  const matrix = createRotateAtPoint(x2, y2, rad);
  const mark = makeMark("path", {
    ...attrs || {},
    path: p
  }, { matrix });
  return {
    mark,
    width: baseLength,
    height: offsetY * 2
  };
}
function makeTextAtPoint(text, p, attrs = {}) {
  return makeMark("text", {
    x: p.x,
    y: p.y,
    text,
    fill: PALETTE.normalDark,
    textAlign: "center",
    textBaseline: "middle",
    ...attrs
  });
}

// ../pintora-diagrams/lib/sequence/artist-util.js
function makeLoopLabelBox(position2, width2, height, cut) {
  const { x: x2, y: y2 } = position2;
  const points = [
    [x2, y2],
    [x2 + width2, y2],
    [x2 + width2, y2 + height - cut],
    [x2 + width2 - cut * 1.2, y2 + height],
    [x2, y2 + height]
  ];
  return makeMark("polygon", {
    points
  }, { class: "loop__label-box" });
}

// ../pintora-diagrams/lib/util/mark-positioner.js
var MARK_TRANSFORMERS = {
  rect({ attrs }, info) {
    attrs.x = (attrs.x || 0) + info.offsets.x;
    attrs.y = (attrs.y || 0) + info.offsets.y;
  },
  circle({ attrs }, info) {
    attrs.x += info.offsets.x;
    attrs.y += info.offsets.y;
    if (info.scales.x)
      attrs.r *= info.scales.x;
  },
  ellipse({ attrs, type }, info) {
    attrs.x += info.offsets.x;
    attrs.y += info.offsets.y;
    if (info.scales.x)
      attrs.rx *= info.scales.x;
    if (info.scales.y)
      attrs.ry *= info.scales.y;
  },
  line(mark, info) {
    mark.matrix = createTranslation(info.offsets.x, info.offsets.y);
  },
  path(mark, info) {
    const translateMatrix = createTranslation(info.offsets.x, info.offsets.y);
    const scaleMatrix = mat3_exports.fromScaling(mat3_exports.create(), [info.scales.x || 1, info.scales.y || 1]);
    const matrix = mat3_exports.multiply(mat3_exports.create(), translateMatrix, scaleMatrix);
    mark.matrix = matrix;
  }
};
function positionGroupContents(group, p) {
  const oldBounds = {
    x: group.attrs.x || 0,
    y: group.attrs.y || 0,
    width: group.attrs.width || null,
    height: group.attrs.height || null
  };
  const offsets = {
    x: p.x - oldBounds.x,
    y: p.y - oldBounds.y
  };
  const info = {
    offsets,
    scales: {
      x: oldBounds.width === null ? null : p.width / oldBounds.width,
      y: oldBounds.height === null ? null : p.height / oldBounds.height
    },
    width: p.width,
    height: p.height
  };
  group.children.forEach((mark) => {
    const { type } = mark;
    if (mark.type === "group") {
      positionGroupContents(mark, { ...offsets, width: mark.attrs.width, height: mark.attrs.height });
    } else {
      const transformer2 = MARK_TRANSFORMERS[type];
      if (transformer2) {
        transformer2(mark, info);
      } else {
        const cAttrs = mark.attrs;
        cAttrs.x = (cAttrs.x || 0) + offsets.x;
        cAttrs.y = (cAttrs.y || 0) + offsets.y;
      }
    }
  });
  safeAssign(group.attrs, p);
}
var TRANSFORM_GRAPH = {
  /**
   * Turn dagre layout result node coords to GraphicsIR rect left top
   */
  graphNodeToRectStart(rect) {
    const { width: width2, height, x: x2, y: y2 } = rect;
    return {
      width: width2,
      height,
      x: x2 - rect.width / 2,
      y: y2 - rect.height / 2
    };
  }
};
function makeBounds() {
  return {
    left: Infinity,
    right: -Infinity,
    top: Infinity,
    bottom: -Infinity,
    width: 0,
    height: 0
  };
}
function tryExpandBounds(base, newRegion) {
  base.left = Math.min(base.left, newRegion.left);
  base.right = Math.max(base.right, newRegion.right);
  base.top = Math.min(base.top, newRegion.top);
  base.bottom = Math.max(base.bottom, newRegion.bottom);
  base.width = base.right - base.left;
  base.height = base.bottom - base.top;
  return base;
}

// ../pintora-diagrams/lib/sequence/artist/divider.js
function drawDivider(context, divider) {
  const { conf: conf6, model: model3 } = context;
  const container = context.rootMark;
  const dividerMargin = conf6.dividerMargin;
  model3.tryBumpType({ [BumpType.Box]: true });
  model3.bumpVerticalPos(dividerMargin);
  const dividerTextFont = {
    ...messageFont(conf6),
    fontWeight: conf6.dividerFontWeight
  };
  const bounds = model3.getBounds();
  const starty = model3.verticalPos;
  const startx = bounds.startx;
  const { width: width2, height } = divider;
  const padding = conf6.wrapPadding;
  const rectWidth = width2 + conf6.wrapPadding * 2;
  const rectX = startx + (bounds.stopx - rectWidth) / 2;
  const rect = makeMark("rect", {
    x: rectX,
    y: starty,
    width: rectWidth,
    height: height + conf6.wrapPadding * 2,
    fill: conf6.activationBackground,
    stroke: conf6.actorBorderColor,
    lineWidth: 2
  });
  const textDims = calculateTextDimensions(divider.text);
  const textMark = makeMark("text", {
    text: divider.text,
    fill: conf6.dividerTextColor,
    x: rectX + width2 / 2 + padding,
    y: starty + height / 2 + padding,
    textAlign: "center",
    textBaseline: "middle",
    ...dividerTextFont
  });
  const lineGap = 3;
  const line1Y = starty + rect.attrs.height / 2 - lineGap / 2;
  const line2Y = line1Y + lineGap;
  const line1 = makeMark("line", {
    x1: 0,
    y1: line1Y,
    x2: bounds.stopx,
    y2: line1Y,
    stroke: conf6.actorLineColor
  });
  const line2 = makeMark("line", {
    ...line1.attrs,
    y1: line2Y,
    y2: line2Y
  });
  const g = makeMark("group", {}, {
    children: [line1, line2, rect, textMark],
    class: "divider"
  });
  container.children.push(g);
  model3.bumpVerticalPos(dividerMargin + textDims.height + padding);
  model3.onBoundsFinish(({ bounds: bounds2 }) => {
    const boundWidth = Math.abs(bounds2.stopx - bounds2.startx);
    const newCenterX = bounds2.startx + boundWidth / 2;
    const newRectX = newCenterX - rect.attrs.width / 2;
    safeAssign(rect.attrs, { x: newRectX });
    safeAssign(textMark.attrs, { x: newCenterX });
    safeAssign(line1.attrs, { x1: bounds2.startx });
    safeAssign(line2.attrs, { x1: bounds2.startx });
  });
}

// ../pintora-diagrams/lib/sequence/artist/loop.js
function drawLoopTo(context, loopModel, labelText) {
  const { conf: conf6, rootMark: mark, model: model3 } = context;
  const loopLineColor = conf6.loopLineColor;
  const group = makeMark("group", {}, { children: [], class: "loop" });
  function drawLoopLine(startx2, starty2, stopx2, stopy2) {
    const line = makeMark("line", {
      x1: startx2,
      x2: stopx2,
      y1: starty2,
      y2: stopy2,
      stroke: loopLineColor,
      lineWidth: 2,
      lineDash: [2, 2]
    }, { class: "loopline" });
    group.children.push(line);
  }
  function drawSectionBg(section) {
    const sectionBgRect = makeMark("rect", {
      x: startx,
      y: section.y,
      width: stopx - startx,
      height: stopy - section.y,
      fill: section.fill,
      stroke: loopLineColor,
      lineWidth: 2,
      lineDash: [2, 2]
    });
    model3.groupBgs.push(sectionBgRect);
  }
  const { startx, starty, stopx, stopy } = loopModel;
  const bgRect = makeMark("rect", removeValues({
    x: startx,
    y: starty,
    width: stopx - startx,
    height: stopy - starty,
    fill: loopModel.fill,
    stroke: loopLineColor,
    lineWidth: 2,
    lineDash: [2, 2]
  }));
  model3.groupBgs.push(bgRect);
  if (loopModel.sections) {
    loopModel.sections.forEach(function(item) {
      drawLoopLine(startx, item.y, loopModel.stopx, item.y);
      if (item.fill) {
        drawSectionBg(item);
      }
    });
  }
  const { boxMargin, boxTextMargin, labelBoxWidth, labelBoxHeight, messageFontFamily: fontFamily2, messageFontSize: fontSize2, messageFontWeight: fontWeight, messageTextColor: textColor } = conf6;
  const tAttrs = getBaseText();
  safeAssign(tAttrs, {
    text: labelText,
    x: startx + boxTextMargin,
    y: starty + boxTextMargin,
    textBaseline: "top",
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeight,
    fill: textColor
  });
  const labelTextMark = makeMark("text", tAttrs, { class: "label-text" });
  const labelTextSize = calculateTextDimensions(labelText, messageFont(conf6));
  const labelWidth = Math.max(labelTextSize.width + 2 * boxTextMargin, labelBoxWidth);
  const labelHeight = Math.max(labelTextSize.height + 2 * boxTextMargin, labelBoxHeight);
  const labelWrap = makeLoopLabelBox({ x: startx, y: starty }, labelWidth, labelHeight, 5);
  safeAssign(labelWrap.attrs, {
    fill: conf6.actorBackground,
    stroke: loopLineColor
  });
  const loopWidth = stopx - startx;
  const titleMark = makeMark("text", {
    text: loopModel.title,
    x: startx + loopWidth / 2 + labelBoxWidth / 2,
    y: starty + boxTextMargin,
    textBaseline: "top",
    textAlign: "center",
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeight,
    fill: textColor
  }, { class: "loop__title" });
  group.children.push(labelWrap, labelTextMark, titleMark);
  if (loopModel.sections) {
    loopModel.sections.forEach(function(item, idx) {
      const sectionTitle = item.message.text;
      if (sectionTitle) {
        const sectionTitleMark = makeMark("text", {
          ...getBaseText(),
          text: sectionTitle,
          x: startx + loopWidth / 2,
          y: loopModel.sections[idx].y + boxTextMargin,
          textAlign: "center",
          textBaseline: "top",
          fontFamily: fontFamily2,
          fontSize: fontSize2,
          fontWeight,
          fill: conf6.messageTextColor
        }, { class: "loop__title" });
        const { height: sectionHeight } = calculateTextDimensions(sectionTitle, messageFont(conf6));
        loopModel.sections[idx].height += sectionHeight - (boxMargin + boxTextMargin);
        group.children.push(sectionTitleMark);
      }
    });
  }
  mark.children.push(group);
}

// ../../node_modules/.pnpm/dedent@1.5.1/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim2 = input[Symbol.toPrimitive];
  if (prim2 !== void 0) {
    var res = prim2.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent_default = createDedent({});
function createDedent(options) {
  dedent.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values4) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i2 = 0; i2 < raw.length; i2++) {
      let next = raw[i2];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{");
      }
      result += next;
      if (i2 < values4.length) {
        result += values4[i2];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent;
      result = lines.map((l) => l[0] === " " || l[0] === "	" ? l.slice(m) : l).join("\n");
    }
    return result.trim().replace(/\\n/g, "\n");
  }
}

// ../pintora-diagrams/lib/util/text.js
function getTextDimensionsInPresicion(text, fontConfig, precision = 2) {
  const { width: width2, height } = calculateTextDimensions(text, fontConfig);
  return {
    width: toFixed(width2, precision),
    height: toFixed(height, precision)
  };
}

// ../pintora-diagrams/lib/sequence/artist.js
var conf;
var theme;
var GROUP_LABEL_MAP = {
  [LINETYPE.LOOP_END]: "loop",
  [LINETYPE.ALT_END]: "alt",
  [LINETYPE.OPT_END]: "opt",
  [LINETYPE.PAR_END]: "par",
  [LINETYPE.LOOP_START]: "loop",
  [LINETYPE.ALT_START]: "alt",
  [LINETYPE.OPT_START]: "opt",
  [LINETYPE.PAR_START]: "par"
};
var SHOW_NUMBER_CIRCLE_RADIUS = 8;
var sequenceArtist = {
  draw(ir, config2, opts) {
    var _a;
    conf = getConf(ir, config2);
    theme = config_default.getConfig().themeConfig.themeVariables;
    model.init();
    const { messages, title } = ir;
    const actorKeys = db.getActorKeys();
    const rootMark = makeEmptyGroup();
    const context = {
      ir,
      rootMark,
      conf,
      model
    };
    actorKeys.forEach((key) => {
      model.actorAttrsMap.set(key, { fill: conf.actorBackground, stroke: conf.actorBorderColor });
    });
    model.initBoxInfos(ir);
    let startVerticalPos = 0;
    if (model.hasParticipantBox()) {
      const vPos = conf.participantBoxPadding * 2 + model.participantBoxStats.maxTitleHeight;
      startVerticalPos = model.bumpVerticalPos(vPos);
    }
    calcLoopMinWidths(ir.messages);
    const maxMessageWidthPerActor = getMaxMessageWidthPerActor(ir);
    model.maxMessageWidthPerActor = maxMessageWidthPerActor;
    const actorsCalcResult = calculateActorMargins(context, maxMessageWidthPerActor);
    model.actorHeight = actorsCalcResult.actorHeight;
    drawActors(rootMark, ir, { verticalPos: startVerticalPos });
    const loopWidths = calculateLoopBounds(messages);
    const activationGroup = makeMark("group", {}, {
      children: [],
      class: "activations"
    });
    rootMark.children.push(activationGroup);
    function activeEnd(msg, verticalPos) {
      const activationData = model.endActivation(msg);
      if (activationData.starty + 18 > verticalPos) {
        activationData.starty = verticalPos - 6;
        verticalPos += 12;
      }
      drawActivationTo(activationGroup, activationData);
      model.insert(activationData.startx, verticalPos - 10, activationData.stopx, verticalPos);
    }
    let sequenceIndex = 1;
    messages.forEach(function(msg) {
      let loopModel, noteModel, msgModel;
      switch (msg.type) {
        case LINETYPE.NOTE:
          noteModel = model.noteModelMap.get(msg.id);
          drawNoteTo(noteModel, rootMark);
          break;
        case LINETYPE.ACTIVE_START:
          model.newActivation(msg);
          break;
        case LINETYPE.ACTIVE_END:
          activeEnd(msg, model.verticalPos);
          break;
        case LINETYPE.LOOP_START:
        case LINETYPE.OPT_START:
        case LINETYPE.ALT_START:
        case LINETYPE.PAR_START:
          adjustLoopSizeForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, ({ message, width: width3 }) => {
            var _a2;
            const fill = (_a2 = msg.attrs) === null || _a2 === void 0 ? void 0 : _a2.background;
            model.newLoop(message, width3, fill);
          });
          break;
        case LINETYPE.ALT_ELSE:
        case LINETYPE.PAR_AND:
          adjustLoopSizeForWrap(loopWidths, msg, conf.boxMargin, conf.boxMargin + conf.boxTextMargin, ({ message, width: width3 }) => {
            var _a2;
            const fill = (_a2 = msg.attrs) === null || _a2 === void 0 ? void 0 : _a2.background;
            model.addSectionToLoop(message, width3, fill);
          });
          break;
        case LINETYPE.LOOP_END:
        case LINETYPE.ALT_END:
        case LINETYPE.OPT_END:
        case LINETYPE.PAR_END:
          loopModel = model.endLoop();
          const label = GROUP_LABEL_MAP[msg.type];
          drawLoopTo(context, loopModel, label);
          model.bumpVerticalPos(loopModel.stopy - model.verticalPos);
          model.loops.push(loopModel);
          break;
        case LINETYPE.DIVIDER:
          msgModel = model.dividerMap.get(msg.id);
          drawDivider(context, msgModel);
          break;
        default:
          try {
            msgModel = model.msgModelMap.get(msg.id);
            if (!msgModel) {
              console.warn("no msgModel for", msg);
              return;
            }
            msgModel.starty = model.verticalPos;
            msgModel.sequenceIndex = sequenceIndex;
            rootMark.children.push(drawMessage(msgModel).mark);
          } catch (e) {
            logger.error("error while drawing message", e);
          }
      }
      if ([
        LINETYPE.SOLID_OPEN,
        LINETYPE.DOTTED_OPEN,
        LINETYPE.SOLID,
        LINETYPE.DOTTED,
        LINETYPE.SOLID_CROSS,
        LINETYPE.DOTTED_CROSS,
        LINETYPE.SOLID_POINT,
        LINETYPE.DOTTED_POINT
      ].includes(msg.type)) {
        sequenceIndex++;
      }
    });
    if (conf.mirrorActors) {
      model.bumpVerticalPos(conf.boxMargin * 2);
      drawActors(rootMark, ir, { verticalPos: model.verticalPos, isMirror: true });
    }
    if (model.hasParticipantBox()) {
      model.bumpVerticalPos(conf.participantBoxPadding);
    }
    rootMark.children = [...model.groupBgs, ...rootMark.children];
    drawParticipantBoxes(context);
    const box = model.getBounds();
    if (title) {
      const titleFont = actorFont(conf);
      rootMark.children.push({
        type: "text",
        attrs: {
          text: title,
          x: box.startx + (box.stopx - box.startx) / 2,
          y: -20,
          ...titleFont,
          fill: conf.actorTextColor,
          textAlign: "center",
          fontWeight: "bold"
        },
        class: "sequence__title"
      });
    }
    model.emitBoundsFinish();
    const doublePadX = 2 * conf.diagramMarginX;
    const doublePadY = 2 * conf.diagramMarginY;
    const extraVertForTitle = title ? 40 : 0;
    const contentWidth = box.stopx - box.startx;
    let contentHeight = box.stopy - box.starty + extraVertForTitle;
    if (conf.mirrorActors) {
      contentHeight = contentHeight + conf.boxMargin;
    }
    const containerWidth = (_a = opts.containerSize) === null || _a === void 0 ? void 0 : _a.width;
    const scaleX = conf.useMaxWidth && containerWidth && containerWidth / (contentWidth + doublePadX) || 1;
    const width2 = Math.round(scaleX * (contentWidth + doublePadX));
    const height = Math.round(scaleX * (contentHeight + doublePadY));
    const leftPad = Math.abs(Math.min(0, box.startx));
    rootMark.matrix = mat3_exports.translate(mat3_exports.create(), mat3_exports.fromScaling(mat3_exports.create(), [scaleX, scaleX]), [
      conf.diagramMarginX + leftPad,
      conf.diagramMarginY + extraVertForTitle
    ]);
    const graphicsIR = {
      mark: rootMark,
      width: width2,
      height
    };
    return graphicsIR;
  }
};
var BumpType;
(function(BumpType2) {
  BumpType2[BumpType2["Box"] = 1] = "Box";
})(BumpType || (BumpType = {}));
var Model = class {
  constructor() {
    this.activations = [];
    this.actorAttrsMap = /* @__PURE__ */ new Map();
    this.msgModelMap = /* @__PURE__ */ new Map();
    this.actorLineMarkMap = /* @__PURE__ */ new Map();
    this.maxMessageWidthPerActor = {};
    this.noteModelMap = /* @__PURE__ */ new Map();
    this.dividerMap = /* @__PURE__ */ new Map();
    this.posTempInfo = {};
    this.boxInfos = /* @__PURE__ */ new Map();
    this.participantBoxStats = { maxTitleHeight: 0 };
  }
  init() {
    this.sequenceItems = [];
    this.clear();
    this.data = {
      startx: 0,
      stopx: 0,
      starty: 0,
      stopy: 0
    };
    this.activations = [];
    this.verticalPos = 0;
    this.loops = [];
    this.loopMinWidths = {};
    this.onBoundsFinishCbs = [];
    this.groupBgs = [];
    this.actorHeight = conf.actorHeight;
  }
  clear() {
    this.activations = [];
    this.actorAttrsMap.clear();
    this.actorLineMarkMap.clear();
    this.msgModelMap.clear();
    this.maxMessageWidthPerActor = {};
    this.noteModelMap.clear();
    this.dividerMap.clear();
    this.onBoundsFinishCbs = [];
    this.groupBgs = [];
    this.loopMinWidths = {};
    this.posTempInfo = {};
    this.boxInfos.clear();
  }
  updateVal(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  }
  updateBounds(startx, starty, stopx, stopy) {
    const _self = this;
    let cnt = 0;
    function updateFn(type) {
      return function updateItemBounds(item) {
        cnt++;
        const n2 = _self.sequenceItems.length - cnt + 1;
        _self.updateVal(item, "starty", starty - n2 * conf.boxMargin, Math.min);
        _self.updateVal(item, "stopy", stopy + n2 * conf.boxMargin, Math.max);
        const groupItemStopx = stopx + n2 * conf.boxMargin;
        _self.updateVal(_self.data, "startx", startx - n2 * conf.boxMargin, Math.min);
        _self.updateVal(_self.data, "stopx", groupItemStopx, Math.max);
        if (!(type === "activation")) {
          _self.updateVal(item, "startx", startx - n2 * conf.boxMargin, Math.min);
          _self.updateVal(item, "stopx", groupItemStopx, Math.max);
          _self.updateVal(_self.data, "starty", starty - n2 * conf.boxMargin, Math.min);
          _self.updateVal(_self.data, "stopy", stopy + n2 * conf.boxMargin, Math.max);
        }
      };
    }
    this.sequenceItems.forEach(updateFn());
    this.activations.forEach(updateFn("activation"));
  }
  insert(startx, starty, stopx, stopy) {
    const _startx = Math.min(startx, stopx);
    const _stopx = Math.max(startx, stopx);
    const _starty = Math.min(starty, stopy);
    const _stopy = Math.max(starty, stopy);
    this.updateVal(this.data, "startx", _startx, Math.min);
    this.updateVal(this.data, "starty", _starty, Math.min);
    this.updateVal(this.data, "stopx", _stopx, Math.max);
    this.updateVal(this.data, "stopy", _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  }
  newActivation(message) {
    const actorRect = this.actorAttrsMap.get(message.from);
    const stackedSize = actorActivations(message.from).length || 0;
    const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf.activationWidth / 2;
    this.activations.push({
      startx: x2,
      starty: this.verticalPos + 2,
      stopx: x2 + conf.activationWidth,
      stopy: void 0,
      actor: message.from
    });
  }
  endActivation(message) {
    const lastActorActivationIdx = this.activations.map((activation) => {
      return activation.actor;
    }).lastIndexOf(message.from);
    return this.activations.splice(lastActorActivationIdx, 1)[0];
  }
  createLoop(title = { text: void 0, wrap: false }, width2, fill) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: title.text,
      wrap: title.wrap,
      width: width2,
      height: 0,
      fill
    };
  }
  newLoop(title = { text: void 0, wrap: false }, width2, fill) {
    this.sequenceItems.push(this.createLoop(title, width2, fill));
  }
  endLoop() {
    return this.sequenceItems.pop();
  }
  addSectionToLoop(message, width2, fill) {
    const loop = this.sequenceItems[this.sequenceItems.length - 1];
    loop.sections = loop.sections || [];
    loop.sections.push({ y: this.verticalPos, width: width2, height: 0, fill, message });
  }
  bumpVerticalPos(bump, tempInfo) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
    this.posTempInfo = tempInfo || {};
    return this.verticalPos;
  }
  tryBumpType(types) {
    const { posTempInfo } = this;
    let pos = 0;
    if (types[BumpType.Box] && posTempInfo.extraMarginForBox) {
      pos += posTempInfo.extraMarginForBox;
    }
    this.bumpVerticalPos(pos);
  }
  getBounds() {
    return this.data;
  }
  getHeight() {
    const actorHeight = this.actorAttrsMap.size === 0 ? 0 : Array.from(this.actorAttrsMap.values()).reduce((acc, actor) => {
      return Math.max(acc, actor.height || 0);
    }, 0);
    const messagesHeight = this.msgModelMap.size ? Array.from(this.msgModelMap.values()).reduce((acc, h) => acc + h.height, 0) : 0;
    const notesHeight = this.noteModelMap.size ? Array.from(this.noteModelMap.values()).reduce((acc, h) => acc + h.height, 0) : 0;
    const loopsHeight = this.loops.reduce((acc, h) => acc + h.height, 0);
    return actorHeight + messagesHeight + notesHeight + loopsHeight;
  }
  getBoxInfo(boxId) {
    return this.boxInfos.get(boxId);
  }
  initBoxInfos(ir) {
    let maxTitleHeight = 0;
    for (const actorBox of Object.values(ir.participantBoxes)) {
      const id9 = actorBox.id;
      let boxInfo = this.boxInfos.get(id9);
      if (id9) {
        if (!boxInfo) {
          const fontConfig = messageFont(conf);
          boxInfo = {
            width: 0,
            actorMarks: [],
            bounds: makeBounds(),
            textDims: getTextDimensionsInPresicion(actorBox.text || "", fontConfig),
            participantBox: actorBox
          };
          if (actorBox.text) {
            maxTitleHeight = Math.max(maxTitleHeight, boxInfo.textDims.height);
          }
          this.boxInfos.set(id9, boxInfo);
        }
      }
    }
    this.participantBoxStats = { maxTitleHeight };
  }
  hasParticipantBox() {
    return this.boxInfos.size > 0;
  }
  /**
   * Some elements (such as dividers) can only decide their horizontal position after bounds are calculated
   **/
  onBoundsFinish(cb) {
    this.onBoundsFinishCbs.push(cb);
  }
  emitBoundsFinish() {
    this.onBoundsFinishCbs.forEach((cb) => {
      cb({ bounds: this.data });
    });
  }
};
var model = new Model();
var actorActivations = function(actor) {
  return model.activations.filter(function(activation) {
    return activation.actor === actor;
  });
};
var activationBounds = function(actor) {
  const actorAttrs = model.actorAttrsMap.get(actor);
  const activations = actorActivations(actor);
  const left = activations.reduce(function(acc, activation) {
    return Math.min(acc, activation.startx);
  }, actorAttrs.x + actorAttrs.width / 2);
  const right = activations.reduce(function(acc, activation) {
    return Math.max(acc, activation.stopx);
  }, actorAttrs.x + actorAttrs.width / 2);
  return [left, right];
};
function adjustLoopSizeForWrap(loopWidths, msg, preMargin, postMargin, addLoopFn) {
  model.tryBumpType({ [BumpType.Box]: true });
  model.bumpVerticalPos(preMargin);
  let heightAdjust = postMargin;
  let loopWidth = 0;
  if (msg.id && msg.text && loopWidths[msg.id]) {
    const loopMinWidth = model.loopMinWidths[msg.id] || 0;
    loopWidth = Math.max(loopWidths[msg.id].width, loopMinWidth);
    const textConf = messageFont(conf);
    msg.text = `[${msg.text}]`;
    msg.wrap = true;
    const textDims = calculateTextDimensions(msg.text, textConf);
    const totalOffset = Math.max(textDims.height, conf.labelBoxHeight);
    heightAdjust = postMargin + totalOffset;
    logger.debug(`yOffset: ${totalOffset} - ${msg.text}`);
  }
  addLoopFn({ message: msg, width: loopWidth });
  model.bumpVerticalPos(heightAdjust);
}
var messageFont = (cnf) => {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};
var actorFont = messageFont;
var noteFont = messageFont;
function splitBreaks(text) {
  return text.split("\n");
}
var drawMessage = function(msgModel) {
  model.bumpVerticalPos(conf.boxMargin);
  const { startx, stopx, starty, text, fromBound, type, sequenceIndex, itemId } = msgModel;
  const linesCount = splitBreaks(text).length;
  const textDims = calculateTextDimensions(text, messageFont(conf));
  const lineHeight = textDims.height / linesCount;
  model.bumpVerticalPos(lineHeight);
  const tAttrs = {
    text: "",
    textAlign: "center",
    textBaseline: "top",
    fill: conf.messageTextColor,
    stroke: conf.messageTextColor
  };
  tAttrs.x = fromBound + msgModel.width / 2;
  tAttrs.y = starty + conf.boxMargin;
  tAttrs.width = msgModel.width;
  tAttrs.text = text;
  tAttrs.fontFamily = conf.messageFontFamily;
  tAttrs.fontSize = conf.messageFontSize;
  tAttrs.fontWeight = conf.messageFontWeight;
  let totalOffset = textDims.height;
  let lineStarty;
  const lineAttrs = {
    stroke: conf.messageTextColor,
    lineWidth: 2
  };
  const { verticalPos } = model;
  let lineMark;
  if (startx === stopx) {
    lineStarty = model.verticalPos + totalOffset;
    totalOffset += conf.boxMargin;
    lineStarty = model.verticalPos + totalOffset;
    const lineEndy = lineStarty + 20;
    const linePath = "M " + startx + "," + lineStarty + " C " + (startx + 60) + "," + (lineStarty - 10) + " " + (startx + 60) + "," + (lineStarty + 30) + " " + startx + "," + lineEndy;
    safeAssign(lineAttrs, {
      path: linePath,
      x1: startx,
      x2: stopx,
      y2: lineEndy
    });
    lineMark = makeMark("path", lineAttrs, { class: "message__line", itemId });
    safeAssign(tAttrs, {
      x: startx
    });
    const offsetBump = 20;
    totalOffset += offsetBump;
    const dx = Math.max(textDims.width / 2, conf.actorWidth / 2);
    model.insert(startx - dx, verticalPos - 10 + totalOffset, stopx + dx, verticalPos + offsetBump + totalOffset);
  } else {
    lineStarty = verticalPos + totalOffset;
    safeAssign(lineAttrs, {
      x1: startx,
      x2: stopx,
      y1: lineStarty,
      y2: lineStarty
    });
    lineMark = {
      type: "line",
      attrs: lineAttrs,
      class: "message__line",
      itemId
    };
    model.insert(startx, lineStarty - 10, stopx, lineStarty);
  }
  if (type === LINETYPE.DOTTED || type === LINETYPE.DOTTED_CROSS || type === LINETYPE.DOTTED_POINT || type === LINETYPE.DOTTED_OPEN) {
    safeAssign(lineAttrs, {
      lineDash: [3, 3]
    });
  }
  const isRightArrow = stopx > startx;
  const arrowRad = isRightArrow ? 0 : -Math.PI;
  let lineEndMark = null;
  let lineEndHalfH = 0;
  if (type === LINETYPE.SOLID || type === LINETYPE.DOTTED) {
    const side = 10;
    lineEndMark = drawArrowTo({ x: lineAttrs.x2, y: lineAttrs.y2 }, side, arrowRad, {
      type: "triangle",
      color: lineAttrs.stroke
    });
    lineEndHalfH = side / 2;
  }
  if (type === LINETYPE.SOLID_CROSS || type === LINETYPE.DOTTED_CROSS) {
    const crossOffset = 5;
    const arrowHeight = 10;
    const crossCenterX = lineAttrs.x2 + crossOffset * (isRightArrow ? -1 : 1);
    lineEndMark = drawCrossTo({ x: crossCenterX, y: lineAttrs.y2 }, arrowHeight, arrowRad, {
      stroke: lineAttrs.stroke,
      lineWidth: 2
    });
    lineAttrs.x2 += isRightArrow ? -crossOffset : crossOffset;
    lineEndHalfH = arrowHeight / 2;
  }
  let numberMark;
  if (db.showSequenceNumbers || conf.showSequenceNumbers) {
    const numberTextMark = makeMark("text", {
      ...getBaseText(),
      text: sequenceIndex.toString(),
      x: startx,
      y: lineStarty,
      textAlign: "center",
      textBaseline: "middle",
      fill: conf.actorBackground,
      fontWeight: "bold"
    }, { class: "sequence-number" });
    const circleColor = conf.actorBorderColor;
    const circleMark = makeMark("marker", {
      symbol: "circle",
      x: startx,
      y: lineStarty,
      r: SHOW_NUMBER_CIRCLE_RADIUS,
      fill: circleColor,
      stroke: circleColor
    });
    numberMark = makeMark("group", {}, {
      children: [circleMark, numberTextMark]
    });
  }
  model.bumpVerticalPos(totalOffset, { extraMarginForBox: lineEndHalfH });
  msgModel.height += totalOffset;
  msgModel.stopy = msgModel.starty + msgModel.height;
  model.insert(msgModel.fromBound, msgModel.starty, msgModel.toBound, msgModel.stopy);
  return {
    mark: {
      type: "group",
      class: "message",
      itemId,
      children: compact([
        lineMark,
        lineEndMark,
        {
          type: "text",
          attrs: tAttrs,
          class: "message__text"
        },
        numberMark
      ])
    }
  };
};
var drawNoteTo = function(noteModel, container) {
  model.bumpVerticalPos(conf.boxMargin);
  const textDims = calculateTextDimensions(noteModel.text, noteFont(conf));
  const textHeight = textDims.height;
  noteModel.height = textHeight + 2 * conf.noteMargin;
  noteModel.starty = model.verticalPos;
  const rectAttrs = getBaseNote(theme);
  safeAssign(rectAttrs, {
    x: noteModel.startx,
    y: noteModel.starty,
    width: noteModel.width || conf.noteWidth,
    height: noteModel.height
  });
  const noteRect = {
    type: "rect",
    class: "note__bg",
    attrs: rectAttrs
  };
  const textAttrs = { fill: conf.noteTextColor, text: noteModel.text, ...noteFont(conf) };
  safeAssign(textAttrs, {
    x: noteModel.startx + noteModel.width / 2,
    y: noteModel.starty + noteModel.height / 2,
    width: noteModel.width,
    textAlign: "center",
    textBaseline: "middle"
  });
  const textMark = {
    type: "text",
    attrs: textAttrs
  };
  model.bumpVerticalPos(textHeight + 2 * conf.noteMargin);
  noteModel.stopy = noteModel.starty + textHeight + 2 * conf.noteMargin;
  noteModel.stopx = noteModel.startx + rectAttrs.width;
  model.insert(noteModel.startx, noteModel.starty, noteModel.stopx, noteModel.stopy);
  const mark = {
    type: "group",
    class: "note",
    children: [noteRect, textMark]
  };
  container.children.push(mark);
};
var drawActors = function(rootMark, ir, opts) {
  const { verticalPos = 0, isMirror } = opts;
  let actorKeys = ir.actorOrder;
  const boxIds = Object.keys(ir.participantBoxes);
  actorKeys = actorKeys.sort((a, b10) => {
    let aOrder = 1e3;
    let bOrder = 1e3;
    const actorA = ir.actors[a];
    const actorB = ir.actors[b10];
    if (actorA.boxId) {
      aOrder = boxIds.indexOf(actorA.boxId);
    }
    if (actorB.boxId) {
      bOrder = boxIds.indexOf(actorB.boxId);
    }
    return aOrder - bOrder;
  });
  let nextActorX = 0;
  for (let i2 = 0; i2 < actorKeys.length; i2++) {
    const key = actorKeys[i2];
    const actor = ir.actors[key];
    const attrsKey = isMirror ? `${key}_mirror` : key;
    const { boxId } = actor;
    const boxInfo = model.getBoxInfo(boxId);
    const participantBox = boxInfo === null || boxInfo === void 0 ? void 0 : boxInfo.participantBox;
    const actorMark = {
      type: "group",
      class: "actor",
      children: [],
      itemId: actor.itemId
    };
    let attrs;
    if (isMirror) {
      attrs = { ...model.actorAttrsMap.get(key) };
    } else {
      attrs = model.actorAttrsMap.get(key) || { fill: conf.actorBackground, stroke: conf.actorBorderColor };
    }
    const areaWidth = attrs.width || conf.actorWidth;
    const areaHeight = Math.max(attrs.height || 0, model.actorHeight);
    let actorX = nextActorX;
    if (participantBox && participantBox.actors[0] === key) {
      actorX += conf.participantBoxPadding;
    }
    safeAssign(attrs, {
      width: areaWidth,
      height: areaHeight,
      margin: attrs.margin || conf.actorMargin,
      x: actorX,
      y: verticalPos,
      radius: 4
    });
    const actorCenter = { x: attrs.x + attrs.width / 2, y: attrs.y + attrs.height / 2 };
    const labelFontFonfig = actorFont(conf);
    const textAttrs = {
      fill: conf.actorTextColor,
      text: actor.description,
      x: actorCenter.x,
      y: actorCenter.y,
      textAlign: "center",
      textBaseline: "middle",
      ...labelFontFonfig
    };
    const labelDims = calculateTextDimensions(actor.description, labelFontFonfig);
    let lineStartOffsetY = 0;
    let sym;
    if (actor.classifier && symbolRegistry.get(actor.classifier)) {
      const symbolHeight = areaHeight - labelDims.height;
      const contentArea = {
        x: attrs.x + areaWidth / 2,
        y: attrs.y + (areaHeight - labelDims.height) / 2,
        width: clamp(symbolHeight * 1.4, areaWidth / 2, areaWidth),
        height: symbolHeight
      };
      lineStartOffsetY += labelDims.height / 2;
      sym = symbolRegistry.create(actor.classifier, {
        mode: "icon",
        attrs: {
          stroke: attrs.stroke,
          fill: attrs.fill
        },
        contentArea
      });
      if (sym) {
        textAttrs.y = actorCenter.y + (areaHeight - labelDims.height) / 2 + 4;
        actorMark.children.push(sym);
      }
    }
    if (!sym) {
      actorMark.children.push({
        type: "rect",
        attrs
      });
    }
    actorMark.children.push({
      type: "text",
      attrs: textAttrs
    });
    let lineMark;
    if (!isMirror) {
      lineMark = {
        type: "line",
        class: "actor__line",
        attrs: {
          x1: actorCenter.x,
          x2: actorCenter.x,
          y1: attrs.y + areaHeight + lineStartOffsetY,
          y2: 2e3,
          stroke: conf.actorLineColor
        }
      };
      model.actorLineMarkMap.set(key, lineMark);
    } else {
      const prevLineMark = model.actorLineMarkMap.get(key);
      if (prevLineMark) {
        prevLineMark.attrs.y2 = attrs.y;
      }
    }
    if (lineMark) {
      actorMark.children.unshift(lineMark);
    }
    model.insert(attrs.x, verticalPos, attrs.x + attrs.width, attrs.height);
    nextActorX = actorX + attrs.width + attrs.margin;
    if (participantBox && participantBox.actors.indexOf(key) === participantBox.actors.length - 1) {
      nextActorX += conf.participantBoxPadding;
    }
    rootMark.children.push(actorMark);
    model.actorAttrsMap.set(attrsKey, attrs);
    if (boxInfo) {
      boxInfo.actorMarks.push(actorMark);
      const newBound = makeBounds();
      newBound.left = attrs.x;
      newBound.right = attrs.x + attrs.width;
      newBound.top = 0;
      tryExpandBounds(boxInfo.bounds, newBound);
    }
  }
  model.bumpVerticalPos(model.actorHeight);
};
function drawParticipantBoxes(context) {
  const { model: model3, rootMark, conf: conf6 } = context;
  if (!model3.hasParticipantBox())
    return;
  const boxesGroup = makeEmptyGroup();
  boxesGroup.class = "sequence__participant-boxes";
  const padding = conf6.participantBoxPadding;
  rootMark.children.unshift(boxesGroup);
  const modelBounds = model3.getBounds();
  for (const boxInfo of model3.boxInfos.values()) {
    const { participantBox, bounds, textDims } = boxInfo;
    const width2 = Math.max(textDims.width, bounds.width) + padding * 2;
    if (!isFinite(width2))
      continue;
    const startx = bounds.left - padding;
    const rect = makeMark("rect", {
      x: startx,
      y: 0,
      width: width2,
      height: modelBounds.stopy - modelBounds.starty,
      fill: participantBox.background || conf6.participantBackground,
      stroke: conf6.actorTextColor
    });
    boxesGroup.children.push(rect);
    if (participantBox.text) {
      const fontConfig = messageFont(conf6);
      const textMark = makeMark("text", {
        text: participantBox.text,
        x: startx + width2 / 2,
        y: conf6.participantBoxPadding,
        textBaseline: "top",
        textAlign: "center",
        fill: conf6.actorTextColor,
        ...fontConfig,
        fontWeight: "bold"
      });
      boxesGroup.children.push(textMark);
    }
    model3.insert(startx, 0, startx + width2, rect.attrs.height);
  }
}
function drawActivationTo(mark, data) {
  const rectAttrs = getBaseNote(theme);
  safeAssign(rectAttrs, {
    x: data.startx,
    y: data.starty,
    width: data.stopx - data.startx,
    height: model.verticalPos - data.starty,
    fill: conf.activationBackground
  });
  const rect = {
    type: "rect",
    class: "activation",
    attrs: rectAttrs
  };
  mark.children.push(rect);
}
var getMaxMessageWidthPerActor = function(ir) {
  const { actors, messages } = ir;
  const maxMessageWidthPerActor = {};
  messages.forEach(function(msg) {
    if (actors[msg.to] && actors[msg.from]) {
      const actor = actors[msg.to];
      const { prevActorId, nextActorId } = actor;
      if (msg.placement === PLACEMENT.LEFTOF && !prevActorId) {
        return;
      }
      if (msg.placement === PLACEMENT.RIGHTOF && !actor.nextActorId) {
        return;
      }
      const isNote = msg.placement !== void 0;
      const isMessage = !isNote;
      const textFont = isNote ? noteFont(conf) : messageFont(conf);
      const wrappedMessage = msg.text;
      const messageDimensions = calculateTextDimensions(wrappedMessage, textFont);
      const messageWidth = messageDimensions.width + 2 * conf.wrapPadding;
      if (isMessage && msg.from === nextActorId) {
        maxMessageWidthPerActor[msg.to] = Math.max(maxMessageWidthPerActor[msg.to] || 0, messageWidth);
      } else if (isMessage && msg.from === prevActorId) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth);
      } else if (isMessage && msg.from === msg.to) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth / 2);
        maxMessageWidthPerActor[msg.to] = Math.max(maxMessageWidthPerActor[msg.to] || 0, messageWidth / 2);
      } else if (msg.placement === PLACEMENT.RIGHTOF) {
        maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth);
      } else if (msg.placement === PLACEMENT.LEFTOF) {
        maxMessageWidthPerActor[prevActorId] = Math.max(maxMessageWidthPerActor[prevActorId] || 0, messageWidth);
      } else if (msg.placement === PLACEMENT.OVER) {
        if (prevActorId) {
          maxMessageWidthPerActor[prevActorId] = Math.max(maxMessageWidthPerActor[prevActorId] || 0, messageWidth / 2);
        }
        if (nextActorId) {
          maxMessageWidthPerActor[msg.from] = Math.max(maxMessageWidthPerActor[msg.from] || 0, messageWidth / 2);
        }
      }
    }
  });
  return maxMessageWidthPerActor;
};
var calculateActorMargins = function(context, actorToMessageWidth) {
  const { ir, model: model3 } = context;
  const { actors } = ir;
  let maxHeight = 0;
  Object.keys(actors).forEach((prop) => {
    const actorAttrs = model3.actorAttrsMap.get(prop) || {};
    const actor = actors[prop];
    const actDims = calculateTextDimensions(actor.description, actorFont(conf));
    actorAttrs.width = actor.wrap ? conf.actorWidth : Math.max(conf.actorWidth, actDims.width + 2 * conf.wrapPadding);
    actorAttrs.height = actor.wrap ? Math.max(actDims.height, conf.actorHeight) : conf.actorHeight;
    maxHeight = Math.max(maxHeight, actorAttrs.height);
  });
  for (const actorKey in actorToMessageWidth) {
    const actor = actors[actorKey];
    const actorAttrs = model3.actorAttrsMap.get(actorKey);
    if (!actor) {
      continue;
    }
    const nextActorAttrs = model3.actorAttrsMap.get(actor.nextActorId);
    if (!nextActorAttrs) {
      continue;
    }
    const messageWidth = actorToMessageWidth[actorKey];
    const actorWidth = messageWidth + conf.actorMargin - actorAttrs.width / 2 - nextActorAttrs.width / 2;
    actorAttrs.margin = Math.max(actorWidth, conf.actorMargin);
  }
  return {
    actorHeight: Math.max(maxHeight, conf.actorHeight)
  };
};
var buildMessageModel = function(msg) {
  const msgDims = calculateTextDimensions(msg.text, messageFont(conf));
  let process2 = false;
  if ([
    LINETYPE.SOLID_OPEN,
    LINETYPE.DOTTED_OPEN,
    LINETYPE.SOLID,
    LINETYPE.DOTTED,
    LINETYPE.SOLID_CROSS,
    LINETYPE.DOTTED_CROSS,
    LINETYPE.SOLID_POINT,
    LINETYPE.DOTTED_POINT
  ].includes(msg.type)) {
    process2 = true;
  }
  if (!process2) {
    return {
      width: msgDims.width,
      height: msgDims.height,
      startx: 0,
      starty: 0,
      text: msg.text,
      type: msg.type,
      stopx: msgDims.width,
      stopy: msgDims.height,
      itemId: msg.itemId
    };
  }
  const fromBound = activationBounds(msg.from);
  const toBound = activationBounds(msg.to);
  const fromIdx = fromBound[0] <= toBound[0] ? 1 : 0;
  const toIdx = fromBound[0] < toBound[0] ? 0 : 1;
  const allBounds = fromBound.concat(toBound);
  const boundedWidth = Math.abs(toBound[toIdx] - fromBound[fromIdx]);
  return {
    width: Math.max(msg.wrap ? 0 : msgDims.width + 2 * conf.wrapPadding, boundedWidth + 2 * conf.wrapPadding, conf.actorWidth),
    height: 0,
    startx: fromBound[fromIdx],
    stopx: toBound[toIdx],
    starty: 0,
    stopy: 0,
    text: msg.text,
    type: msg.type,
    wrap: msg.wrap,
    fromBound: Math.min.apply(null, allBounds),
    toBound: Math.max.apply(null, allBounds),
    attrs: msg.attrs,
    itemId: msg.itemId
  };
};
var buildNoteModel = function(msg) {
  const fromActorAttr = model.actorAttrsMap.get(msg.from);
  const toActorAttr = model.actorAttrsMap.get(msg.to);
  const startx = fromActorAttr.x;
  const stopx = toActorAttr.x;
  const shouldWrap = msg.wrap && msg.text;
  let textDimensions = calculateTextDimensions(msg.text, noteFont(conf));
  const noteModel = {
    width: shouldWrap ? conf.noteWidth : Math.max(conf.noteWidth, textDimensions.width + 2 * conf.noteMargin),
    height: 0,
    startx: fromActorAttr.x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    text: msg.text
  };
  if (msg.placement === PLACEMENT.RIGHTOF) {
    noteModel.width = shouldWrap ? Math.max(conf.noteWidth, textDimensions.width) : Math.max(fromActorAttr.width / 2 + toActorAttr.width / 2, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx + (fromActorAttr.width + conf.actorMargin) / 2;
  } else if (msg.placement === PLACEMENT.LEFTOF) {
    noteModel.width = shouldWrap ? Math.max(conf.noteWidth, textDimensions.width + 2 * conf.noteMargin) : Math.max(fromActorAttr.width / 2 + toActorAttr.width / 2, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx - noteModel.width + (fromActorAttr.width - conf.actorMargin) / 2;
  } else if (msg.to === msg.from) {
    textDimensions = calculateTextDimensions(
      // shouldWrap
      //   ? utils.wrapLabel(msg.text, Math.max(conf.noteWidth, actors[msg.from].width), noteFont(conf))
      //   : msg.text,
      msg.text,
      noteFont(conf)
    );
    noteModel.width = shouldWrap ? Math.max(conf.noteWidth, fromActorAttr.width) : Math.max(fromActorAttr.width, conf.noteWidth, textDimensions.width + 2 * conf.noteMargin);
    noteModel.startx = startx + (fromActorAttr.width - noteModel.width) / 2;
  } else {
    noteModel.width = Math.abs(startx + fromActorAttr.width / 2 - (stopx + toActorAttr.width / 2)) + conf.actorMargin;
    noteModel.startx = startx < stopx ? startx + fromActorAttr.width / 2 - conf.actorMargin / 2 : stopx + toActorAttr.width / 2 - conf.actorMargin / 2;
  }
  logger.debug(`NM:[${noteModel.startx},${noteModel.stopx},${noteModel.starty},${noteModel.stopy}:${noteModel.width},${noteModel.height}=${msg.text}]`);
  return noteModel;
};
function calcLoopMinWidths(messages) {
  const minWidths = {};
  const messageFontConfig = messageFont(conf);
  messages.forEach((msg) => {
    switch (msg.type) {
      case LINETYPE.LOOP_START:
      case LINETYPE.ALT_START:
      case LINETYPE.OPT_START:
      case LINETYPE.PAR_START:
        if (!msg.id)
          msg.id = makeid(10);
        const label = GROUP_LABEL_MAP[msg.type];
        const labelWidth = label ? calculateTextDimensions(label, messageFontConfig).width : conf.labelBoxWidth;
        const titleWidth = calculateTextDimensions(msg.text, messageFontConfig).width;
        minWidths[msg.id] = labelWidth + titleWidth + 2 * conf.boxTextMargin;
        break;
    }
  });
  model.loopMinWidths = minWidths;
}
var calculateLoopBounds = function(messages) {
  const loops = {};
  const stack = [];
  let current;
  let noteModel;
  let msgModel;
  messages.forEach(function(msg) {
    if (!msg.id)
      msg.id = makeid(10);
    switch (msg.type) {
      case LINETYPE.LOOP_START:
      case LINETYPE.ALT_START:
      case LINETYPE.OPT_START:
      case LINETYPE.PAR_START:
        const minWidth = model.loopMinWidths[msg.id] || 0;
        stack.push({
          id: msg.id,
          msg: msg.text,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: minWidth
        });
        break;
      case LINETYPE.ALT_ELSE:
      case LINETYPE.PAR_AND:
        if (msg.text) {
          current = stack[stack.length - 1];
          loops[current.id] = current;
          loops[msg.id] = current;
        }
        break;
      case LINETYPE.LOOP_END:
      case LINETYPE.ALT_END:
      case LINETYPE.OPT_END:
      case LINETYPE.PAR_END:
        current = stack.pop();
        loops[current.id] = current;
        break;
      case LINETYPE.ACTIVE_START:
        {
          const actorName = msg.from || msg.to;
          const actorRect = model.actorAttrsMap.get(actorName);
          const stackedSize = actorActivations(msg.from ? msg.from : msg.to).length;
          const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf.activationWidth / 2;
          const toAdd = {
            startx: x2,
            stopx: x2 + conf.activationWidth,
            actor: msg.from,
            starty: 0,
            stopy: 0,
            enabled: true
          };
          model.activations.push(toAdd);
        }
        break;
      case LINETYPE.ACTIVE_END:
        {
          const lastActorActivationIdx = model.activations.map((a) => a.actor).lastIndexOf(msg.from);
          delete model.activations.splice(lastActorActivationIdx, 1)[0];
        }
        break;
    }
    const isNote = msg.placement !== void 0;
    if (isNote) {
      noteModel = buildNoteModel(msg);
      model.noteModelMap.set(msg.id, noteModel);
      stack.forEach((stk) => {
        current = stk;
        current.from = Math.min(current.from, noteModel.startx);
        current.to = Math.max(current.to, noteModel.startx + noteModel.width);
        current.width = Math.max(current.width, Math.abs(current.from - current.to)) - conf.labelBoxWidth;
      });
    } else if (msg.type === LINETYPE.DIVIDER) {
      const dividerModel = buildMessageModel(msg);
      model.dividerMap.set(msg.id, dividerModel);
    } else {
      msgModel = buildMessageModel(msg);
      model.msgModelMap.set(msg.id, msgModel);
      if (msgModel.startx && msgModel.stopx && stack.length > 0) {
        const isZeroWidth = msgModel.startx === msgModel.stopx;
        stack.forEach((stk) => {
          current = stk;
          if (isZeroWidth) {
            const from = model.actorAttrsMap.get(msg.from);
            const to = model.actorAttrsMap.get(msg.to);
            current.from = Math.min(from.x - msgModel.width / 2, from.x - from.width / 2, current.from);
            current.to = Math.max(to.x + msgModel.width / 2, to.x + from.width / 2, current.to);
            current.width = Math.max(current.width, Math.abs(current.to - current.from)) - conf.labelBoxWidth;
          } else {
            current.from = Math.min(msgModel.startx, current.from);
            current.width = Math.max(current.width, msgModel.width);
            current.to = Math.max(msgModel.stopx, current.to, current.from + current.width);
          }
        });
      }
    }
  });
  logger.debug("Loop type widths:", loops);
  return loops;
};
var artist_default = sequenceArtist;

// ../pintora-diagrams/lib/sequence/parser/sequenceDiagram.js
var moo = __toESM(require_moo());

// ../pintora-diagrams/lib/util/parser-shared.js
var LETTER_REGEXP = /[a-zA-Z]/;
var isCharLetter = (char) => LETTER_REGEXP.test(char);
function textToCaseInsensitiveRegex(text) {
  const regexSource = text.split("").map((char) => {
    if (isCharLetter(char)) {
      return `[${char.toLowerCase()}${char.toUpperCase()}]`;
    }
    return char;
  });
  return new RegExp(regexSource.join(""));
}
function tv(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
var VALID_TEXT_REGEXP = /(?:[a-zA-Z0-9_]\p{Unified_Ideograph})+/;
var COLOR_REGEXP = /#[a-zA-Z0-9]+/;
var MOO_NEWLINE = { match: /\n|\r\n/, lineBreaks: true };
var COMMENT_LINE_REGEXP = /%%.*/;
var L_PAREN_REGEXP = /\(/;
var R_PAREN_REGEXP = /\)/;
var QUOTED_WORD_REGEXP = /"(?:\\["nr]|[^"])+"/;
var CONFIG_DIRECTIVE = /@config/;
var configLexerMainState = {
  CONFIG_DIRECTIVE: {
    match: CONFIG_DIRECTIVE,
    push: "configStatement"
  }
};
var configLexerconfigStatementState = {
  QUOTED_WORD: QUOTED_WORD_REGEXP,
  L_PAREN: L_PAREN_REGEXP,
  R_PAREN: { match: R_PAREN_REGEXP, pop: 1 }
};
function getQuotedWord(token) {
  const v = tv(token);
  return v.slice(1, v.length - 1).replace(/\\"/g, '"');
}
function makeNth(n2) {
  return function(d) {
    return d[n2];
  };
}

// ../pintora-diagrams/lib/sequence/parser/sequenceDiagram.js
function id(d) {
  return d[0];
}
var COLOR = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE = /@param/;
var CONFIG_DIRECTIVE2 = /@config/;
var L_PAREN = /\(/;
var R_PAREN = /\)/;
function getTokenValue(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE = /%%.*/;
var lexer = moo.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: / +/, lineBreaks: false },
    ...configLexerMainState,
    QUOTED_WORD: QUOTED_WORD_REGEXP,
    START_NOTE: textToCaseInsensitiveRegex("@note"),
    END_NOTE: textToCaseInsensitiveRegex("@end_note"),
    BACKQUOTED_TEXT: /`[^`]*`/,
    SOLID_ARROW: /->>/,
    DOTTED_ARROW: /-->>/,
    SOLID_OPEN_ARROW: /->/,
    DOTTED_OPEN_ARROW: /-->/,
    SOLID_CROSS: /\-x/,
    DOTTED_CROSS: /\-\-x/,
    SOLID_POINT: /\-[\)]/,
    DOTTED_POINT: /\-\-[\)]/,
    PLUS: /\+/,
    MINUS: /-/,
    COMMA: /,/,
    COLON: { match: /:/, push: "line" },
    L_SQ_BRACKET: { match: /\[/ },
    R_SQ_BRACKET: { match: /\]/ },
    L_AN_BRACKET: { match: /\</ },
    R_AN_BRACKET: { match: /\>/ },
    L_PAREN: L_PAREN_REGEXP,
    R_PAREN: R_PAREN_REGEXP,
    _PLACEMENT: [
      { match: /left\sof/, type: () => "LEFT_OF" },
      { match: /right\sof/, type: () => "RIGHT_OF" }
    ],
    COLOR: /#[a-zA-Z0-9]+/,
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    WORD: { match: VALID_TEXT_REGEXP, fallback: true }
  },
  line: {
    REST_OF_LINE: { match: /[^#\n;]+/, pop: 1 }
  },
  configStatement: {
    ...configLexerconfigStatementState,
    WORD: { match: VALID_TEXT_REGEXP, fallback: true }
  }
});
var yy;
function setYY(v) {
  yy = v;
}
var grammar = {
  Lexer: lexer,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id },
    { "name": "color", "symbols": [COLOR], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE2, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE2, L_PAREN, "configOpenCloseStatement$ebnf$1", R_PAREN], "postprocess": handleConfigOpenCloseStatement },
    { "name": "comment", "symbols": [COMMENT_LINE], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"], "postprocess": (d) => d[1] },
    {
      "name": "start",
      "symbols": [{ "literal": "sequenceDiagram" }, "document"],
      "postprocess": function(d) {
        return d[1];
      }
    },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "line"],
      "postprocess": (d) => {
        const r = d[0].concat(d[1]);
        return r;
      }
    },
    { "name": "line$ebnf$1", "symbols": [lexer.has("WS") ? { type: "WS" } : WS], "postprocess": id },
    { "name": "line$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"], "postprocess": (d) => {
      return d[1];
    } },
    { "name": "line$ebnf$2", "symbols": [lexer.has("WS") ? { type: "WS" } : WS], "postprocess": id },
    { "name": "line$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$2", lexer.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement", "symbols": ["participantStatement"], "postprocess": id },
    { "name": "statement$ebnf$1", "symbols": ["color"], "postprocess": id },
    { "name": "statement$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "statement$ebnf$2", "symbols": [lexer.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD], "postprocess": id },
    { "name": "statement$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "statement$ebnf$3", "symbols": [] },
    { "name": "statement$ebnf$3", "symbols": ["statement$ebnf$3", "participantStatement"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "statement",
      "symbols": [{ "literal": "box" }, "statement$ebnf$1", "statement$ebnf$2", lexer.has("NL") ? { type: "NL" } : NL, "statement$ebnf$3", { "literal": "endbox" }, lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const title = d[2] ? getQuotedWord(d[2]) : null;
        const background = d[1] ? d[1] : null;
        return {
          type: "addBox",
          text: title,
          children: d[4],
          background
        };
      }
    },
    { "name": "statement", "symbols": ["signal", lexer.has("NL") ? { type: "NL" } : NL], "postprocess": id },
    { "name": "statement$ebnf$4", "symbols": [lexer.has("WS") ? { type: "WS" } : WS], "postprocess": id },
    { "name": "statement$ebnf$4", "symbols": [], "postprocess": () => null },
    { "name": "statement", "symbols": [{ "literal": "autonumber" }, "statement$ebnf$4", lexer.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => yy.enableSequenceNumbers() },
    {
      "name": "statement",
      "symbols": [{ "literal": "activate" }, lexer.has("WS") ? { type: "WS" } : WS, "actor", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return {
          type: "activeStart",
          signalType: yy.LINETYPE.ACTIVE_START,
          actor: d[2]
        };
      }
    },
    {
      "name": "statement",
      "symbols": [{ "literal": "deactivate" }, lexer.has("WS") ? { type: "WS" } : WS, "actor", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return {
          type: "activeEnd",
          signalType: yy.LINETYPE.ACTIVE_END,
          actor: d[2]
        };
      }
    },
    { "name": "statement", "symbols": ["note_statement"], "postprocess": (d) => {
      return d[0];
    } },
    { "name": "statement", "symbols": [{ "literal": "title" }, "textWithColon", lexer.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => ({ type: "setTitle", text: d[1] }) },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "loop" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "opt" }] },
    { "name": "statement$ebnf$5", "symbols": ["color"], "postprocess": id },
    { "name": "statement$ebnf$5", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["statement$subexpression$1", lexer.has("WS") ? { type: "WS" } : WS, "statement$ebnf$5", "words", lexer.has("NL") ? { type: "NL" } : NL, "document", "_", { "literal": "end" }, "_", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const groupType = tv(d[0][0]);
        const text = yy.parseMessage(d[3]);
        const background = d[2] ? d[2] : null;
        const result = [
          { type: "groupStart", text, groupType, background },
          d[5],
          { type: "groupEnd", groupType }
        ];
        return result;
      }
    },
    { "name": "statement$subexpression$2", "symbols": [{ "literal": "par" }] },
    { "name": "statement$ebnf$6", "symbols": ["color"], "postprocess": id },
    { "name": "statement$ebnf$6", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["statement$subexpression$2", lexer.has("WS") ? { type: "WS" } : WS, "statement$ebnf$6", "words", lexer.has("NL") ? { type: "NL" } : NL, "par_sections", "_", { "literal": "end" }, "_", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const groupType = tv(d[0][0]);
        const text = yy.parseMessage(d[3]);
        const background = d[2] ? d[2] : null;
        const result = [
          { type: "groupStart", text, groupType, background },
          d[5],
          { type: "groupEnd", groupType }
        ];
        return result;
      }
    },
    { "name": "statement$subexpression$3", "symbols": [{ "literal": "alt" }] },
    { "name": "statement$ebnf$7", "symbols": ["color"], "postprocess": id },
    { "name": "statement$ebnf$7", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["statement$subexpression$3", lexer.has("WS") ? { type: "WS" } : WS, "statement$ebnf$7", "words", lexer.has("NL") ? { type: "NL" } : NL, "else_sections", "_", { "literal": "end" }, "_", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const groupType = tv(d[0][0]);
        const text = yy.parseMessage(d[3]);
        const background = d[2] ? d[2] : null;
        const result = [
          { type: "groupStart", text, groupType, background },
          d[5],
          { type: "groupEnd", groupType }
        ];
        return result;
      }
    },
    { "name": "statement$ebnf$8$subexpression$1", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD] },
    { "name": "statement$ebnf$8$subexpression$1", "symbols": [lexer.has("WS") ? { type: "WS" } : WS] },
    { "name": "statement$ebnf$8", "symbols": ["statement$ebnf$8$subexpression$1"] },
    { "name": "statement$ebnf$8$subexpression$2", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD] },
    { "name": "statement$ebnf$8$subexpression$2", "symbols": [lexer.has("WS") ? { type: "WS" } : WS] },
    { "name": "statement$ebnf$8", "symbols": ["statement$ebnf$8", "statement$ebnf$8$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "statement",
      "symbols": [{ "literal": "==" }, lexer.has("WS") ? { type: "WS" } : WS, "statement$ebnf$8", lexer.has("WS") ? { type: "WS" } : WS, { "literal": "==" }, "_", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const text = d[2].map((o) => tv(o[0])).join("").trim();
        return { type: "addDivider", text, signalType: yy.LINETYPE.DIVIDER };
      }
    },
    { "name": "statement", "symbols": ["paramStatement", lexer.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["configOpenCloseStatement", lexer.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["comment", lexer.has("NL") ? { type: "NL" } : NL] },
    { "name": "participantWord", "symbols": [{ "literal": "participant" }] },
    {
      "name": "classifiableActor",
      "symbols": [lexer.has("L_SQ_BRACKET") ? { type: "L_SQ_BRACKET" } : L_SQ_BRACKET, lexer.has("L_AN_BRACKET") ? { type: "L_AN_BRACKET" } : L_AN_BRACKET, lexer.has("WORD") ? { type: "WORD" } : WORD, lexer.has("R_AN_BRACKET") ? { type: "R_AN_BRACKET" } : R_AN_BRACKET, "__", "actor", { "literal": "]" }],
      "postprocess": function(d) {
        const actor = d[5];
        actor.classifier = tv(d[2]);
        return actor;
      }
    },
    { "name": "classifiableActor", "symbols": ["actor"], "postprocess": id },
    {
      "name": "participantStatement",
      "symbols": ["participantWord", lexer.has("WS") ? { type: "WS" } : WS, "classifiableActor", lexer.has("WS") ? { type: "WS" } : WS, { "literal": "as" }, lexer.has("WS") ? { type: "WS" } : WS, lexer.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD, lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        d[2].description = yy.parseMessage(getQuotedWord(d[6]));
        return d[2];
      }
    },
    {
      "name": "participantStatement",
      "symbols": ["participantWord", lexer.has("WS") ? { type: "WS" } : WS, "classifiableActor", lexer.has("WS") ? { type: "WS" } : WS, { "literal": "as" }, lexer.has("WS") ? { type: "WS" } : WS, "words", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const alias = d[6];
        d[2].description = yy.parseMessage(alias);
        return d[2];
      }
    },
    { "name": "participantStatement$ebnf$1", "symbols": [lexer.has("WS") ? { type: "WS" } : WS], "postprocess": id },
    { "name": "participantStatement$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "participantStatement",
      "symbols": ["participantWord", lexer.has("WS") ? { type: "WS" } : WS, "classifiableActor", "participantStatement$ebnf$1", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1$subexpression$1"] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": ["words$ebnf$1"],
      "postprocess": function(d) {
        return d[0].map((a) => a[0]).map((o) => tv(o)).join("");
      }
    },
    { "name": "signaltype", "symbols": [lexer.has("SOLID_OPEN_ARROW") ? { type: "SOLID_OPEN_ARROW" } : SOLID_OPEN_ARROW], "postprocess": (d) => yy.LINETYPE.SOLID_OPEN },
    { "name": "signaltype", "symbols": [lexer.has("DOTTED_OPEN_ARROW") ? { type: "DOTTED_OPEN_ARROW" } : DOTTED_OPEN_ARROW], "postprocess": (d) => yy.LINETYPE.DOTTED_OPEN },
    { "name": "signaltype", "symbols": [lexer.has("SOLID_ARROW") ? { type: "SOLID_ARROW" } : SOLID_ARROW], "postprocess": (d) => yy.LINETYPE.SOLID },
    { "name": "signaltype", "symbols": [lexer.has("DOTTED_ARROW") ? { type: "DOTTED_ARROW" } : DOTTED_ARROW], "postprocess": (d) => yy.LINETYPE.DOTTED },
    { "name": "signaltype", "symbols": [lexer.has("SOLID_CROSS") ? { type: "SOLID_CROSS" } : SOLID_CROSS], "postprocess": (d) => yy.LINETYPE.SOLID_CROSS },
    { "name": "signaltype", "symbols": [lexer.has("DOTTED_CROSS") ? { type: "DOTTED_CROSS" } : DOTTED_CROSS], "postprocess": (d) => yy.LINETYPE.DOTTED_CROSS },
    { "name": "signaltype", "symbols": [lexer.has("SOLID_POINT") ? { type: "SOLID_POINT" } : SOLID_POINT], "postprocess": (d) => yy.LINETYPE.SOLID_POINT },
    { "name": "signaltype", "symbols": [lexer.has("DOTTED_POINT") ? { type: "DOTTED_POINT" } : DOTTED_POINT], "postprocess": (d) => yy.LINETYPE.DOTTED_POINT },
    { "name": "signal$subexpression$1", "symbols": [lexer.has("PLUS") ? { type: "PLUS" } : PLUS] },
    { "name": "signal$subexpression$1", "symbols": [lexer.has("MINUS") ? { type: "MINUS" } : MINUS] },
    {
      "name": "signal",
      "symbols": ["actor", "signaltype", "signal$subexpression$1", "actor", "textWithColon"],
      "postprocess": function(d) {
        const toActor = d[3];
        const fromActor = d[0];
        const activeMark = d[2][0];
        let activeAction;
        if (activeMark.type === "MINUS") {
          activeAction = { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: fromActor };
        } else {
          activeAction = { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: toActor };
        }
        return [
          fromActor,
          toActor,
          { type: "addSignal", from: fromActor.actor, to: toActor.actor, signalType: d[1], msg: d[4] },
          activeAction
        ];
      }
    },
    {
      "name": "signal",
      "symbols": ["actor", "signaltype", "actor", "textWithColon"],
      "postprocess": function(d) {
        const toActor = d[2];
        return [
          d[0],
          toActor,
          { type: "addSignal", from: d[0].actor, to: toActor.actor, signalType: d[1], msg: d[3] }
        ];
      }
    },
    { "name": "actor", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD], "postprocess": (d) => {
      return { type: "addActor", actor: tv(d[0]) };
    } },
    {
      "name": "textWithColon",
      "symbols": [lexer.has("COLON") ? { type: "COLON" } : COLON, "_", lexer.has("REST_OF_LINE") ? { type: "REST_OF_LINE" } : REST_OF_LINE],
      "postprocess": function(d) {
        return yy.parseMessage(tv(d[2]).trim());
      }
    },
    { "name": "multilineNoteText$ebnf$1", "symbols": [] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer.has("WORD") ? { type: "WORD" } : WORD] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer.has("WS") ? { type: "WS" } : WS] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer.has("NL") ? { type: "NL" } : NL] },
    { "name": "multilineNoteText$ebnf$1", "symbols": ["multilineNoteText$ebnf$1", "multilineNoteText$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "multilineNoteText",
      "symbols": ["multilineNoteText$ebnf$1", lexer.has("END_NOTE") ? { type: "END_NOTE" } : END_NOTE],
      "postprocess": function(d) {
        const v = d[0].map((l) => {
          return l.map((o) => tv(o));
        }).join("");
        return v;
      }
    },
    { "name": "placement", "symbols": [lexer.has("LEFT_OF") ? { type: "LEFT_OF" } : LEFT_OF], "postprocess": (d) => yy.PLACEMENT.LEFTOF },
    { "name": "placement", "symbols": [lexer.has("RIGHT_OF") ? { type: "RIGHT_OF" } : RIGHT_OF], "postprocess": (d) => yy.PLACEMENT.RIGHTOF },
    { "name": "note_statement$subexpression$1", "symbols": [{ "literal": "note" }] },
    { "name": "note_statement$subexpression$1", "symbols": [lexer.has("START_NOTE") ? { type: "START_NOTE" } : START_NOTE] },
    {
      "name": "note_statement",
      "symbols": ["note_statement$subexpression$1", "placement", "actor", "textWithColon", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return [d[2], { type: "addNote", placement: d[1], actor: d[2].actor, text: d[3] }];
      }
    },
    { "name": "note_statement$subexpression$2", "symbols": [{ "literal": "note" }] },
    { "name": "note_statement$subexpression$2", "symbols": [lexer.has("START_NOTE") ? { type: "START_NOTE" } : START_NOTE] },
    {
      "name": "note_statement",
      "symbols": ["note_statement$subexpression$2", "placement", "actor", "multilineNoteText", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const text = d[3];
        const message = yy.parseMessage(text);
        return [d[2], { type: "addNote", placement: d[1], actor: d[2].actor, text: message }];
      }
    },
    { "name": "note_statement$subexpression$3", "symbols": [{ "literal": "note" }] },
    { "name": "note_statement$subexpression$3", "symbols": [lexer.has("START_NOTE") ? { type: "START_NOTE" } : START_NOTE] },
    {
      "name": "note_statement",
      "symbols": ["note_statement$subexpression$3", { "literal": "over" }, "actor_pair", "textWithColon", lexer.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const actors = [d[2][0].actor, d[2][1].actor];
        return [
          d[2],
          { type: "addNote", placement: yy.PLACEMENT.OVER, actor: actors, text: d[3] }
        ];
      }
    },
    { "name": "actor_pair", "symbols": ["actor", lexer.has("COMMA") ? { type: "COMMA" } : COMMA, "actor"], "postprocess": (d) => [d[0], d[2]] },
    { "name": "actor_pair", "symbols": ["actor"], "postprocess": id },
    { "name": "else_sections", "symbols": ["document"] },
    { "name": "else_sections$ebnf$1", "symbols": ["color"], "postprocess": id },
    { "name": "else_sections$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "else_sections",
      "symbols": ["document", "_", { "literal": "else" }, lexer.has("WS") ? { type: "WS" } : WS, "else_sections$ebnf$1", "words", lexer.has("NL") ? { type: "NL" } : NL, "else_sections"],
      "postprocess": function(d) {
        const background = d[4] ? d[4] : null;
        const text = yy.parseMessage(d[5]);
        return d[0].concat([
          { type: "groupStart", groupType: "else", text, signalType: yy.LINETYPE.ALT_ELSE, background },
          d[7]
        ]);
      }
    },
    { "name": "par_sections", "symbols": ["document"] },
    { "name": "par_sections$ebnf$1", "symbols": ["color"], "postprocess": id },
    { "name": "par_sections$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "par_sections",
      "symbols": ["document", "_", { "literal": "and" }, lexer.has("WS") ? { type: "WS" } : WS, "par_sections$ebnf$1", "words", lexer.has("NL") ? { type: "NL" } : NL, "par_sections"],
      "postprocess": function(d) {
        const background = d[4] ? d[4] : null;
        const text = yy.parseMessage(d[5]);
        return d[0].concat([
          { type: "groupStart", groupType: "and", text, signalType: yy.LINETYPE.PAR_AND, background },
          d[7]
        ]);
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer.has("WS") ? { type: "WS" } : WS] }
};
var sequenceDiagram_default = grammar;

// ../pintora-diagrams/lib/util/parser-util.js
var import_nearley = __toESM(require_nearley());
function genParserWithRules(grammar9, opts = {}) {
  return function parse9(text) {
    const parser = new import_nearley.default.Parser(import_nearley.default.Grammar.fromCompiled(grammar9));
    if (opts.prepare)
      opts.prepare();
    let preparedText = text;
    preparedText = preparedText.split("\n").filter((line) => {
      return line.length > 0;
    }).join("\n");
    const textToParse = preparedText[preparedText.length - 1] !== "\n" ? preparedText + "\n" : preparedText;
    parser.feed(textToParse);
    let results = compact(parser.results);
    if (opts.dedupeAmbigousResults) {
      if (Array.isArray(results[0])) {
        results = results[0];
      }
    }
    if (opts.postProcess) {
      results = opts.postProcess(results);
    }
    return results;
  };
}

// ../pintora-diagrams/lib/sequence/parser.js
setYY(db_default);
var parse = genParserWithRules(sequenceDiagram_default, {
  dedupeAmbigousResults: true,
  postProcess(results) {
    db_default.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/util/event-recognizer.js
var BaseEventRecognizer = class {
  constructor() {
    this.rules = [];
  }
  recognize(e, ir) {
    let d;
    if (e.markPath) {
      for (const m of e.markPath) {
        if (m.itemId) {
          for (const rule of this.rules) {
            if (rule.match(m)) {
              d = rule.createDiagramEvent(e, m, ir);
            }
            if (d)
              break;
          }
        }
      }
    }
    return d;
  }
  addPatternRecognizerRule(pattern, createDiagramEvent) {
    const rule = {
      match(m) {
        return pattern.test(m.itemId);
      },
      createDiagramEvent
    };
    this.rules.push(rule);
    return this;
  }
};

// ../pintora-diagrams/lib/sequence/event-recognizer.js
var ACTOR_ITEM_PATTERN = /^actor\-/;
var MESSAGE_ITEM_PATTERN = /^message\-/;
var createSequenceDiagramEvent = diagramEventMakerFactory("sequence");
var eventRecognizer = new BaseEventRecognizer().addPatternRecognizerRule(ACTOR_ITEM_PATTERN, (e, m, ir) => {
  const actor = ir.actors[m.itemId.replace(ACTOR_ITEM_PATTERN, "")];
  return createSequenceDiagramEvent(e, m, m.itemId, "actor", actor);
}).addPatternRecognizerRule(MESSAGE_ITEM_PATTERN, (e, m, ir) => {
  const message = ir.messages.find((message2) => message2.itemId === m.itemId);
  return createSequenceDiagramEvent(e, m, m.itemId, "message", message);
});

// ../pintora-diagrams/lib/sequence/index.js
var sequenceDiagram = {
  pattern: /^\s*sequenceDiagram/,
  parser: {
    parse(text) {
      parse(text);
      return db.getDiagramIR();
    }
  },
  artist: artist_default,
  configKey: "sequence",
  eventRecognizer,
  clear() {
    db.clear();
  }
};

// ../pintora-diagrams/lib/er/db.js
var Cardinality;
(function(Cardinality2) {
  Cardinality2["ZERO_OR_ONE"] = "ZERO_OR_ONE";
  Cardinality2["ZERO_OR_MORE"] = "ZERO_OR_MORE";
  Cardinality2["ONE_OR_MORE"] = "ONE_OR_MORE";
  Cardinality2["ONLY_ONE"] = "ONLY_ONE";
  Cardinality2["MORE"] = "MORE";
})(Cardinality || (Cardinality = {}));
var Identification;
(function(Identification2) {
  Identification2["NON_IDENTIFYING"] = "NON_IDENTIFYING";
  Identification2["IDENTIFYING"] = "IDENTIFYING";
})(Identification || (Identification = {}));
var ErDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.Cardinality = Cardinality;
    this.Identification = Identification;
    this.entities = {};
    this.relationships = [];
    this.inheritances = [];
  }
  addEntity(name) {
    if (!this.entities[name]) {
      this.entities[name] = { attributes: [], itemId: `entity-${name}` };
    }
    return this.entities[name];
  }
  addRelationship(entityA, roleA, entityB, relSpec) {
    const itemId = `relationship-${entityA}-${entityB}`;
    const rel = {
      entityA,
      roleA,
      entityB,
      relSpec,
      itemId
    };
    this.relationships.push(rel);
  }
  addInheritance(sup, sub3) {
    this.inheritances.push({ sup, sub: sub3 });
  }
  getDiagramIR() {
    return {
      ...super.getBaseDiagramIR(),
      entities: this.entities,
      relationships: this.relationships,
      inheritances: this.inheritances
    };
  }
  addTitle(title) {
    this.title = title;
  }
  addAttributes(name, attributes) {
    const entity = this.addEntity(name);
    entity.attributes.push(...attributes);
  }
  addParam(styleParam) {
    this.configParams.push(styleParam);
  }
  clear() {
    super.clear();
    this.entities = {};
    this.relationships = [];
    this.inheritances = [];
    this.configParams = [];
    this.title = "";
  }
};
var db2 = new ErDb();
var db_default2 = db2;

// ../pintora-diagrams/lib/er/config.js
var defaultConfig2 = {
  diagramPadding: 15,
  layoutDirection: "TB",
  ranksep: 100,
  edgesep: 80,
  edgeType: "polyline",
  useMaxWidth: false,
  minEntityWidth: 80,
  minEntityHeight: 50,
  entityPaddingX: 15,
  entityPaddingY: 15,
  borderRadius: 2,
  stroke: PALETTE.normalDark,
  fill: PALETTE.orange,
  edgeColor: PALETTE.normalDark,
  attributeFill: "#fffbf9",
  textColor: PALETTE.normalDark,
  labelBackground: PALETTE.white,
  fontSize: 14,
  fontFamily: DEFAULT_FONT_FAMILY
};
var ER_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig2),
  useMaxWidth: { valueType: "boolean" },
  layoutDirection: { valueType: "string" },
  borderRadius: { valueType: "size" },
  stroke: { valueType: "color" },
  fill: { valueType: "color" },
  edgeColor: { valueType: "color" },
  attributeFill: { valueType: "color" },
  textColor: { valueType: "color" },
  labelBackground: { valueType: "color" },
  fontSize: { valueType: "size" },
  fontFamily: { valueType: "string" }
};
var configKey2 = "er";
var configurator2 = makeConfigurator({
  defaultConfig: defaultConfig2,
  configKey: configKey2,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(ER_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t, conf6) {
    return {
      stroke: t.primaryBorderColor,
      fill: t.primaryColor,
      // fill: 'transparent', // for debugging markers
      edgeColor: t.primaryLineColor,
      textColor: t.textColor,
      labelBackground: t.canvasBackground || t.background1,
      attributeFill: t.lightestBackground || conf6.attributeFill
    };
  }
});
var getConf2 = configurator2.getConfig;

// ../../node_modules/.pnpm/@pintora+graphlib@2.2.2/node_modules/@pintora/graphlib/dist/graphlib.esm.js
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty$a.call(object, key);
}
var isArray = Array.isArray;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol2 = root.Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol2 ? Symbol2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag2 = baseGetTag(value);
  return tag2 == funcTag$1 || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype;
var objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length3 = array.length;
  while (length3--) {
    if (eq(array[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map2 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map4, key) {
  var data = map4.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size4 = data.size;
  data.set(key, value);
  this.size += data.size == size4 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match);
  });
  return result;
});
function arrayMap(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
  while (++index2 < length3) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol2 ? Symbol2.prototype : void 0;
var symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length3) {
  var type = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER$1 : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function hasPath(object, path4, hasFunc) {
  path4 = castPath(path4, object);
  var index2 = -1, length3 = path4.length, result = false;
  while (++index2 < length3) {
    var key = toKey(path4[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength(length3) && isIndex(key, length3) && (isArray(object) || isArguments(object));
}
function has(object, path4) {
  return object != null && hasPath(object, path4, baseHas);
}
function arrayEach(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key = props[fromRight ? length3 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer2 = moduleExports$1 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag = "[object Function]";
var mapTag$4 = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$1 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$2 = "[object String]";
var weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
function overArg(func, transform7) {
  return function(arg) {
    return func(transform7(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length3) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function identity2(value) {
  return value;
}
function castFunction(value) {
  return typeof value == "function" ? value : identity2;
}
function forEach2(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}
var DataView2 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set2 = getNative(root, "Set");
var WeakMap2 = getNative(root, "WeakMap");
var mapTag$3 = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView2);
var mapCtorString = toSource(Map2);
var promiseCtorString = toSource(Promise$1);
var setCtorString = toSource(Set2);
var weakMapCtorString = toSource(WeakMap2);
var getTag = baseGetTag;
if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag$1 || Map2 && getTag(new Map2()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag$3 || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var stringTag$1 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$1;
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var asciiSize = baseProperty("length");
var rsAstralRange$1 = "\\ud800-\\udfff";
var rsComboMarksRange$1 = "\\u0300-\\u036f";
var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]";
var rsCombo = "[" + rsComboRange + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange + "]?";
var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}
var mapTag$2 = "[object Map]";
var setTag$2 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag2 = getTag$1(collection);
  if (tag2 == mapTag$2 || tag2 == setTag$2) {
    return collection.size;
  }
  return baseKeys(collection).length;
}
function constant(value) {
  return function() {
    return value;
  };
}
function arrayFilter(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length3) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values4) {
  var index2 = -1, length3 = values4 == null ? 0 : values4.length;
  this.__data__ = new MapCache();
  while (++index2 < length3) {
    this.add(values4[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1;
var COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array2 = root.Uint8Array;
function mapToArray(map4) {
  var index2 = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1;
var COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var mapTag$1 = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag$1 = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values4) {
  var index2 = -1, length3 = values4.length, offset = array.length;
  while (++index2 < length3) {
    array[offset + index2] = values4[index2];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length3) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object) {
  var result = keys(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
function baseGet(object, path4) {
  path4 = castPath(path4, object);
  var index2 = 0, length3 = path4.length;
  while (object != null && index2 < length3) {
    object = object[toKey(path4[index2++])];
  }
  return index2 && index2 == length3 ? object : void 0;
}
function get(object, path4, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path4);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasIn(object, path4) {
  return object != null && hasPath(object, path4, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path4, srcValue) {
  if (isKey(path4) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path4), srcValue);
  }
  return function(object) {
    var objValue = get(object, path4);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path4) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function basePropertyDeep(path4) {
  return function(object) {
    return baseGet(object, path4);
  };
}
function property(path4) {
  return isKey(path4) ? baseProperty(toKey(path4)) : basePropertyDeep(path4);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity2;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate));
}
function isUndefined(value) {
  return value === void 0;
}
var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length3 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length3) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax = Math.max;
function overRest(func, start, transform7) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length3 = nativeMax(args.length - start, 0), array = Array(length3);
    while (++index2 < length3) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform7(array);
    return apply(func, this, otherArgs);
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var baseSetToString = !defineProperty ? identity2 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString);
function baseRest(func, start) {
  return setToString(overRest(func, start, identity2), func + "");
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length3 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length3 = array.length;
  while (++index2 < length3) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
function arrayIncludes(array, value) {
  var length3 = array == null ? 0 : array.length;
  return !!length3 && baseIndexOf(array, value, 0) > -1;
}
function arrayIncludesWith(array, value, comparator) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
function noop() {
}
var INFINITY = 1 / 0;
var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values4) {
  return new Set2(values4);
};
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length3 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length3 >= LARGE_ARRAY_SIZE) {
    var set3 = iteratee ? null : createSet(array);
    if (set3) {
      return setToArray(set3);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length3) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var getPrototype = overArg(Object.getPrototypeOf, Object);
function transform3(object, iteratee, accumulator) {
  var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
    return iteratee(accumulator, value, index2, object2);
  });
  return accumulator;
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}
var mapTag = "[object Map]";
var setTag = "[object Set]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag2 = getTag$1(value);
  if (tag2 == mapTag || tag2 == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  if (initAccum && length3) {
    accumulator = array[++index2];
  }
  while (++index2 < length3) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
}
var _ = {
  has,
  constant,
  each: forEach2,
  filter,
  isUndefined,
  union,
  transform: transform3,
  size,
  isArray,
  map,
  keys,
  values,
  isEmpty,
  isFunction,
  reduce
};
var DEFAULT_EDGE_NAME = "\0";
var GRAPH_NODE = "\0";
var EDGE_KEY_DELIM = "";
function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;
  this._label = void 0;
  this._defaultNodeLabelFn = _.constant(void 0);
  this._defaultEdgeLabelFn = _.constant(void 0);
  this._nodes = {};
  if (this._isCompound) {
    this._parent = {};
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }
  this._in = {};
  this._preds = {};
  this._out = {};
  this._sucs = {};
  this._edgeObjs = {};
  this._edgeLabels = {};
}
Graph.prototype._nodeCount = 0;
Graph.prototype._edgeCount = 0;
Graph.prototype.isDirected = function() {
  return this._isDirected;
};
Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};
Graph.prototype.isCompound = function() {
  return this._isCompound;
};
Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};
Graph.prototype.graph = function() {
  return this._label;
};
Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};
Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};
Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};
Graph.prototype.sources = function() {
  const self2 = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self2._in[v]);
  });
};
Graph.prototype.sinks = function() {
  const self2 = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self2._out[v]);
  });
};
Graph.prototype.setNodes = function(vs, value) {
  const args = arguments;
  const self2 = this;
  _.each(vs, function(v) {
    if (args.length > 1) {
      self2.setNode(v, value);
    } else {
      self2.setNode(v);
    }
  });
  return this;
};
Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }
  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};
Graph.prototype.node = function(v) {
  return this._nodes[v];
};
Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};
Graph.prototype.removeNode = function(v) {
  const self2 = this;
  if (_.has(this._nodes, v)) {
    const removeEdge = function(e) {
      self2.removeEdge(self2._edgeObjs[e]);
    };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        self2.setParent(child);
      });
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};
Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }
  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    parent += "";
    for (let ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }
    this.setNode(parent);
  }
  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};
Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};
Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    const parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};
Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }
  if (this._isCompound) {
    const children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};
Graph.prototype.predecessors = function(v) {
  const predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};
Graph.prototype.successors = function(v) {
  const sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};
Graph.prototype.neighbors = function(v) {
  const preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};
Graph.prototype.isLeaf = function(v) {
  let neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};
Graph.prototype.filterNodes = function(filter3) {
  const copy4 = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy4.setGraph(this.graph());
  const self2 = this;
  _.each(this._nodes, function(value, v) {
    if (filter3(v)) {
      copy4.setNode(v, value);
    }
  });
  _.each(this._edgeObjs, function(e) {
    if (copy4.hasNode(e.v) && copy4.hasNode(e.w)) {
      copy4.setEdge(e, self2.edge(e));
    }
  });
  const parents = {};
  function findParent(v) {
    const parent = self2.parent(v);
    if (parent === void 0 || copy4.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }
  if (this._isCompound) {
    _.each(copy4.nodes(), function(v) {
      copy4.setParent(v, findParent(v));
    });
  }
  return copy4;
};
Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};
Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};
Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};
Graph.prototype.setPath = function(vs, value) {
  const self2 = this;
  const args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self2.setEdge(v, w, value);
    } else {
      self2.setEdge(v, w);
    }
    return w;
  });
  return this;
};
Graph.prototype.setEdge = function() {
  let v, w, name, value;
  let valueSpecified = false;
  const arg0 = arguments[0];
  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }
  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }
  const e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }
  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }
  this.setNode(v);
  this.setNode(w);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
  const edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  v = edgeObj.v;
  w = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};
Graph.prototype.edge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return this._edgeLabels[e];
};
Graph.prototype.hasEdge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return _.has(this._edgeLabels, e);
};
Graph.prototype.removeEdge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  const edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};
Graph.prototype.inEdges = function(v, u) {
  const inV = this._in[v];
  if (inV) {
    const edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) {
      return edge.v === u;
    });
  }
};
Graph.prototype.outEdges = function(v, w) {
  const outV = this._out[v];
  if (outV) {
    const edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) {
      return edge.w === w;
    });
  }
};
Graph.prototype.nodeEdges = function(v, w) {
  const inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};
function incrementOrInitEntry(map4, k) {
  if (map4[k]) {
    map4[k]++;
  } else {
    map4[k] = 1;
  }
}
function decrementOrRemoveEntry(map4, k) {
  if (!--map4[k]) {
    delete map4[k];
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  let v = "" + v_;
  let w = "" + w_;
  if (!isDirected && v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v_, w_, name) {
  let v = "" + v_;
  let w = "" + w_;
  if (!isDirected && v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  const edgeObj = { v, w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x2) {
    return x2.key;
  });
};
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};
PriorityQueue.prototype.priority = function(key) {
  const index2 = this._keyIndices[key];
  if (index2 !== void 0) {
    return this._arr[index2].priority;
  }
};
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};
PriorityQueue.prototype.add = function(key, priority) {
  const keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    const arr2 = this._arr;
    const index2 = arr2.length;
    keyIndices[key] = index2;
    arr2.push({ key, priority });
    this._decrease(index2);
    return true;
  }
  return false;
};
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  const min4 = this._arr.pop();
  delete this._keyIndices[min4.key];
  this._heapify(0);
  return min4.key;
};
PriorityQueue.prototype.decrease = function(key, priority) {
  const index2 = this._keyIndices[key];
  if (priority > this._arr[index2].priority) {
    throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
  }
  this._arr[index2].priority = priority;
  this._decrease(index2);
};
PriorityQueue.prototype._heapify = function(i2) {
  const arr2 = this._arr;
  const l = 2 * i2;
  const r = l + 1;
  let largest = i2;
  if (l < arr2.length) {
    largest = arr2[l].priority < arr2[largest].priority ? l : largest;
    if (r < arr2.length) {
      largest = arr2[r].priority < arr2[largest].priority ? r : largest;
    }
    if (largest !== i2) {
      this._swap(i2, largest);
      this._heapify(largest);
    }
  }
};
PriorityQueue.prototype._decrease = function(index2) {
  const arr2 = this._arr;
  const priority = arr2[index2].priority;
  let parent;
  while (index2 !== 0) {
    parent = index2 >> 1;
    if (arr2[parent].priority < priority) {
      break;
    }
    this._swap(index2, parent);
    index2 = parent;
  }
};
PriorityQueue.prototype._swap = function(i2, j) {
  const arr2 = this._arr;
  const keyIndices = this._keyIndices;
  const origArrI = arr2[i2];
  const origArrJ = arr2[j];
  arr2[i2] = origArrJ;
  arr2[j] = origArrI;
  keyIndices[origArrJ.key] = i2;
  keyIndices[origArrI.key] = j;
};
var DEFAULT_WEIGHT_FUNC$1 = _.constant(1);
var DEFAULT_WEIGHT_FUNC = _.constant(1);
topsort.CycleException = CycleException;
function topsort(g) {
  const visited = {};
  const stack = {};
  const results = [];
  function visit(node2) {
    if (_.has(stack, node2)) {
      throw new CycleException();
    }
    if (!_.has(visited, node2)) {
      stack[node2] = true;
      visited[node2] = true;
      _.each(g.predecessors(node2), visit);
      delete stack[node2];
      results.push(node2);
    }
  }
  _.each(g.sinks(), visit);
  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
function CycleException() {
}
CycleException.prototype = new Error();

// ../pintora-diagrams/lib/util/graph.js
function createLayoutGraph(opts) {
  return new Graph(opts);
}
function getGraphBounds(g, opts = {}) {
  let left = opts.startLeft || 0;
  let right = 0;
  let top = opts.startTop || 0;
  let bottom = 0;
  g.nodes().forEach((k) => {
    const node2 = g.node(k);
    if (!node2)
      return;
    if (opts.filterNode && !opts.filterNode(node2))
      return;
    left = Math.min(node2.outerLeft || node2.x, left);
    const width2 = node2.outerWidth || node2.width || 0;
    right = Math.max(node2.outerRight || node2.x + width2 / 2, right);
    top = Math.min(node2.outerTop || node2.y, top);
    const height = node2.outerHeight || node2.height || 0;
    bottom = Math.max(node2.outerBottom || node2.y + height / 2, bottom);
  });
  const graphOpts = g.graph();
  const marginx = graphOpts.marginx || 0;
  const marginy = graphOpts.marginy || 0;
  return {
    left,
    right,
    top,
    bottom,
    width: right - left + marginx,
    height: bottom - top + marginy
  };
}
function isGraphVertical(g) {
  return g.graph().rankdir === "TB";
}
function getGraphSplinesOption(edgeType) {
  if (["polyline", "ortho"].includes(edgeType)) {
    return edgeType;
  }
  return "polyline";
}

// ../pintora-diagrams/lib/er/artist-util.js
var MARKER_GENERATORS = {
  [Cardinality.ONLY_ONE]() {
    const mark = makeMark("path", {
      path: "M9,-9 L9,9 M15,-9 L15,9"
    }, { class: "er-marker--only-one" });
    return mark;
  },
  [Cardinality.ZERO_OR_ONE](attrs) {
    const circle = makeMark("circle", {
      ...attrs,
      fill: "#fff",
      x: 28,
      y: 0,
      r: 6
    });
    const path4 = makeMark("path", {
      ...attrs,
      path: "M14,-9 L14,9"
    });
    const group = {
      type: "group",
      class: "er-marker--zero-or-one",
      children: [circle, path4]
    };
    return group;
  },
  [Cardinality.ONE_OR_MORE]() {
    const mark = makeMark("path", {
      path: "M-18,0 Q 0,18 18,0 Q 0,-18 -18,0 M24,-9 L24,9"
    }, { class: "er-marker--one-or-more" });
    return mark;
  },
  [Cardinality.ZERO_OR_MORE](attrs) {
    const circle = makeMark("circle", {
      ...attrs,
      fill: "#fff",
      x: 28,
      y: 0,
      r: 6
    });
    const path4 = makeMark("path", {
      ...attrs,
      path: "M-18,0 Q 0,18 18,0 Q 0,-18 -18,0"
    });
    const group = {
      type: "group",
      class: "er-marker--zero-or-more",
      children: [circle, path4]
    };
    return group;
  }
};
function drawMarkerTo(dest, type, rad, attrs) {
  const generator = MARKER_GENERATORS[type];
  if (!generator)
    return;
  const mark = generator(attrs || {});
  safeAssign(mark.attrs, attrs || {});
  const finalMatrix = mat3_exports.create();
  mat3_exports.translate(finalMatrix, mat3_exports.create(), [dest.x, dest.y]);
  mat3_exports.rotate(finalMatrix, finalMatrix, rad);
  mark.matrix = finalMatrix;
  if (mark.class)
    mark.class = `er-marker ${mark.class}`;
  return mark;
}
var TableCell = class _TableCell {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.order = 0;
  }
  static fromMark(mark, name, opts = {}) {
    const cell = new _TableCell();
    cell.mark = mark;
    cell.name = name;
    cell.width = mark.attrs.width;
    cell.height = mark.attrs.height;
    Object.assign(cell, opts);
    if (!("order" in opts)) {
      if (name in CELL_ORDER) {
        cell.order = CELL_ORDER[name];
      }
    }
    return cell;
  }
};
var TableRow = class {
  constructor() {
    this.cellMap = /* @__PURE__ */ new Map();
  }
  addCells(cells) {
    const validCells = cells.filter((o) => Boolean(o));
    validCells.forEach((cell) => {
      this.cellMap.set(cell.name, cell);
    });
  }
  getCell(name) {
    return this.cellMap.get(name);
  }
  map(fn) {
    return Array.from(this.cellMap.values()).map(fn);
  }
};
var TableBuilder = class {
  constructor() {
    this.rows = [];
  }
  addRow(row) {
    this.rows.push(row);
  }
};
var CELL_ORDER = {
  key: 1,
  type: 2,
  name: 3,
  comment: 4
};

// ../../node_modules/.pnpm/d3-path@3.0.1/node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/constant.js
function constant_default(x2) {
  return function constant3() {
    return x2;
  };
}

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/line.js
function line_default(x2, y2) {
  var defined = constant_default(true), context = null, curve = linear_default, output = null;
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x : constant_default(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y : constant_default(y2);
  function line(data) {
    var i2, n2 = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path_default());
    for (i2 = 0; i2 <= n2; ++i2) {
      if (!(i2 < n2 && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i2, data), +y2(d, i2, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_3) {
    return arguments.length ? (x2 = typeof _3 === "function" ? _3 : constant_default(+_3), line) : x2;
  };
  line.y = function(_3) {
    return arguments.length ? (y2 = typeof _3 === "function" ? _3 : constant_default(+_3), line) : y2;
  };
  line.defined = function(_3) {
    return arguments.length ? (defined = typeof _3 === "function" ? _3 : constant_default(!!_3), line) : defined;
  };
  line.curve = function(_3) {
    return arguments.length ? (curve = _3, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_3) {
    return arguments.length ? (_3 == null ? context = output = null : output = curve(context = _3), line) : context;
  };
  return line;
}

// ../../node_modules/.pnpm/d3-shape@3.1.0/node_modules/d3-shape/src/curve/basis.js
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basis_default(context) {
  return new Basis(context);
}

// ../pintora-diagrams/lib/util/line-util.js
function getPointsCurvePath(points, factory = basis_default) {
  const pathString = line_default().curve(factory)(points.map((o) => [o.x, o.y]));
  return pathString;
}
function getPointsLinearPath(points) {
  const [startPoint, ...restPoints] = points;
  return [
    ["M", startPoint.x, startPoint.y],
    ...restPoints.map((point2) => {
      return ["L", point2.x, point2.y];
    })
  ];
}
function getMedianPoint(points) {
  const len2 = points.length;
  const index2 = Math.floor(len2 / 2);
  return { index: index2, point: points[index2] };
}

// ../pintora-diagrams/lib/util/bound.js
var MARK_BOUND_CALCULATORS = {
  rect({ attrs }) {
    return {
      left: attrs.x,
      right: attrs.x + attrs.width,
      top: attrs.y,
      bottom: attrs.y + attrs.height
    };
  },
  circle({ attrs }) {
    return {
      left: attrs.x - attrs.r,
      right: attrs.x + attrs.r,
      top: attrs.y - attrs.r,
      bottom: attrs.y + attrs.r
    };
  },
  ellipse({ attrs }) {
    return {
      left: attrs.cx - attrs.rx,
      right: attrs.cx + attrs.rx,
      bottom: attrs.cy - attrs.ry,
      top: attrs.cy + attrs.ry
    };
  },
  line({ attrs }) {
    return {
      left: Math.min(attrs.x1, attrs.x2),
      right: Math.max(attrs.x1, attrs.x2),
      top: Math.min(attrs.y1, attrs.y2),
      bottom: Math.max(attrs.y1, attrs.y2)
    };
  },
  path() {
    return makeBounds();
  }
};
function calcBound(marks, opts = {}) {
  let left = 0;
  let top = 0;
  let right = 0;
  let bottom = 0;
  const allMarks = /* @__PURE__ */ new Set();
  if (opts.recursive) {
    let recursiveAddMark = function(m) {
      if (allMarks.has(m))
        return;
      allMarks.add(m);
      if ("children" in m) {
        m.children.forEach((child) => recursiveAddMark(child));
      }
    };
    marks.forEach((child) => recursiveAddMark(child));
  } else {
    marks.forEach((child) => allMarks.add(child));
  }
  for (const mark of allMarks.values()) {
    const { type } = mark;
    const calculator = MARK_BOUND_CALCULATORS[type];
    let bound = {
      left: null,
      top: null,
      right: null,
      bottom: null
    };
    if (calculator) {
      bound = calculator(mark);
    } else {
      console.warn("[calcBound] missing calculator", type);
    }
    if (bound.left !== null)
      left = Math.min(bound.left, left);
    if (bound.top !== null)
      top = Math.min(bound.top, top);
    if (bound.right !== null)
      right = Math.max(bound.right, right);
    if (bound.bottom !== null)
      bottom = Math.max(bound.bottom, bottom);
  }
  const width2 = right - left;
  const height = bottom - top;
  return { left, top, right, bottom, width: width2, height };
}
function updateBoundsByPoints(bounds, points) {
  points.forEach((p) => {
    bounds.left = Math.min(bounds.left, p.x);
    bounds.right = Math.max(bounds.right, p.x);
    bounds.top = Math.min(bounds.top, p.y);
    bounds.bottom = Math.max(bounds.bottom, p.y);
    bounds.width = bounds.right - bounds.left;
    bounds.height = bounds.bottom - bounds.top;
  });
  return bounds;
}
function floorValues(o) {
  for (const k of Object.keys(o)) {
    if (o[k])
      o[k] = Math.floor(o[k]);
  }
  return o;
}

// ../../node_modules/.pnpm/@pintora+dagre@0.10.10/node_modules/@pintora/dagre/dist/dagre-layout.js
function arrayEach$1(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key = props[fromRight ? length3 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor$1 = createBaseFor$1();
var baseFor$2 = baseFor$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var freeGlobal$1 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$2 = freeGlobal$1;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$2 || freeSelf$1 || Function("return this")();
var root$2 = root$1;
var Symbol$1 = root$2.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$t = Object.prototype;
var hasOwnProperty$n = objectProto$t.hasOwnProperty;
var nativeObjectToString$3 = objectProto$t.toString;
var symToStringTag$3 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$n.call(value, symToStringTag$3), tag2 = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag2;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var objectProto$s = Object.prototype;
var nativeObjectToString$2 = objectProto$s.toString;
function objectToString$1(value) {
  return nativeObjectToString$2.call(value);
}
var nullTag$1 = "[object Null]";
var undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var argsTag$6 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$1(value) && baseGetTag$1(value) == argsTag$6;
}
var objectProto$r = Object.prototype;
var hasOwnProperty$m = objectProto$r.hasOwnProperty;
var propertyIsEnumerable$3 = objectProto$r.propertyIsEnumerable;
var isArguments$1 = baseIsArguments$1(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$1(value) && hasOwnProperty$m.call(value, "callee") && !propertyIsEnumerable$3.call(value, "callee");
};
var isArguments$2 = isArguments$1;
var isArray$1 = Array.isArray;
var isArray$2 = isArray$1;
function stubFalse$1() {
  return false;
}
var freeExports$4 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$4 = freeExports$4 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$4 = freeModule$4 && freeModule$4.exports === freeExports$4;
var Buffer$2 = moduleExports$4 ? root$2.Buffer : void 0;
var nativeIsBuffer$1 = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer$1 = nativeIsBuffer$1 || stubFalse$1;
var isBuffer$2 = isBuffer$1;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length3) {
  var type = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER$3 : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var argsTag$5 = "[object Arguments]";
var arrayTag$4 = "[object Array]";
var boolTag$5 = "[object Boolean]";
var dateTag$5 = "[object Date]";
var errorTag$4 = "[object Error]";
var funcTag$4 = "[object Function]";
var mapTag$b = "[object Map]";
var numberTag$5 = "[object Number]";
var objectTag$6 = "[object Object]";
var regexpTag$5 = "[object RegExp]";
var setTag$b = "[object Set]";
var stringTag$6 = "[object String]";
var weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$5 = "[object ArrayBuffer]";
var dataViewTag$7 = "[object DataView]";
var float32Tag$3 = "[object Float32Array]";
var float64Tag$3 = "[object Float64Array]";
var int8Tag$3 = "[object Int8Array]";
var int16Tag$3 = "[object Int16Array]";
var int32Tag$3 = "[object Int32Array]";
var uint8Tag$3 = "[object Uint8Array]";
var uint8ClampedTag$3 = "[object Uint8ClampedArray]";
var uint16Tag$3 = "[object Uint16Array]";
var uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$5] = typedArrayTags$1[boolTag$5] = typedArrayTags$1[dataViewTag$7] = typedArrayTags$1[dateTag$5] = typedArrayTags$1[errorTag$4] = typedArrayTags$1[funcTag$4] = typedArrayTags$1[mapTag$b] = typedArrayTags$1[numberTag$5] = typedArrayTags$1[objectTag$6] = typedArrayTags$1[regexpTag$5] = typedArrayTags$1[setTag$b] = typedArrayTags$1[stringTag$6] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags$1[baseGetTag$1(value)];
}
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$3 = freeExports$3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$3 = freeModule$3 && freeModule$3.exports === freeExports$3;
var freeProcess$1 = moduleExports$3 && freeGlobal$2.process;
var nodeUtil$1 = function() {
  try {
    var types = freeModule$3 && freeModule$3.require && freeModule$3.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess$1 && freeProcess$1.binding && freeProcess$1.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$2 = nodeUtil$1;
var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray$1 ? baseUnary$1(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray$2 = isTypedArray$1;
var objectProto$q = Object.prototype;
var hasOwnProperty$l = objectProto$q.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes$1(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$l.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$1(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$p = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$p;
  return value === proto;
}
function overArg$1(func, transform7) {
  return function(arg) {
    return func(transform7(arg));
  };
}
var nativeKeys$1 = overArg$1(Object.keys, Object);
var nativeKeys$2 = nativeKeys$1;
var objectProto$o = Object.prototype;
var hasOwnProperty$k = objectProto$o.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$1(object)) {
    return nativeKeys$2(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$k.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag$1 = "[object AsyncFunction]";
var funcTag$3 = "[object Function]";
var genTag$2 = "[object GeneratorFunction]";
var proxyTag$1 = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag2 = baseGetTag$1(value);
  return tag2 == funcTag$3 || tag2 == genTag$2 || tag2 == asyncTag$1 || tag2 == proxyTag$1;
}
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);
}
function baseForOwn$1(object, iteratee) {
  return object && baseFor$2(object, iteratee, keys$1);
}
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length3) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach$1 = createBaseEach$1(baseForOwn$1);
var baseEach$2 = baseEach$1;
function identity$1(value) {
  return value;
}
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$1;
}
function forEach$1(collection, iteratee) {
  var func = isArray$2(collection) ? arrayEach$1 : baseEach$2;
  return func(collection, castFunction$1(iteratee));
}
var symbolTag$5 = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && baseGetTag$1(value) == symbolTag$5;
}
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp$1 = /^\w*$/;
function isKey$1(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
var coreJsData$1 = root$2["__core-js_shared__"];
var coreJsData$2 = coreJsData$1;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$2 = Function.prototype;
var objectProto$n = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$j = objectProto$n.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$j).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
var nativeCreate$1 = getNative$1(Object, "create");
var nativeCreate$2 = nativeCreate$1;
function hashClear$1() {
  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
  this.size = 0;
}
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$m = Object.prototype;
var hasOwnProperty$i = objectProto$m.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$i.call(data, key) ? data[key] : void 0;
}
var objectProto$l = Object.prototype;
var hasOwnProperty$h = objectProto$l.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== void 0 : hasOwnProperty$h.call(data, key);
}
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
function Hash$1(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype["delete"] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf$1(array, key) {
  var length3 = array.length;
  while (length3--) {
    if (eq$1(array[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf$1(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache$1(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype["delete"] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;
var Map$1 = getNative$1(root$2, "Map");
var Map$2 = Map$1;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$2 || ListCache$1)(),
    "string": new Hash$1()
  };
}
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData$1(map4, key) {
  var data = map4.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete$1(key) {
  var result = getMapData$1(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
function mapCacheSet$1(key, value) {
  var data = getMapData$1(this, key), size4 = data.size;
  data.set(key, value);
  this.size += data.size == size4 ? 0 : 1;
  return this;
}
function MapCache$1(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype["delete"] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$1)();
  return memoized;
}
memoize$1.Cache = MapCache$1;
var MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$1(func) {
  var result = memoize$1(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE$1) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped$1(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number4 || match);
  });
  return result;
});
var stringToPath$2 = stringToPath$1;
function arrayMap$1(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
  while (++index2 < length3) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var INFINITY$5 = 1 / 0;
var symbolProto$4 = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolToString$1 = symbolProto$4 ? symbolProto$4.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$5 ? "-0" : result;
}
function toString$1(value) {
  return value == null ? "" : baseToString$1(value);
}
function castPath$1(value, object) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey$1(value, object) ? [value] : stringToPath$2(toString$1(value));
}
var INFINITY$4 = 1 / 0;
function toKey$1(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$4 ? "-0" : result;
}
function baseGet$1(object, path4) {
  path4 = castPath$1(path4, object);
  var index2 = 0, length3 = path4.length;
  while (object != null && index2 < length3) {
    object = object[toKey$1(path4[index2++])];
  }
  return index2 && index2 == length3 ? object : void 0;
}
var defineProperty$1 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$2 = defineProperty$1;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var objectProto$k = Object.prototype;
var hasOwnProperty$g = objectProto$k.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$g.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function baseSet(object, path4, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path4 = castPath$1(path4, object);
  var index2 = -1, length3 = path4.length, lastIndex = length3 - 1, nested = object;
  while (nested != null && ++index2 < length3) {
    var key = toKey$1(path4[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex$1(path4[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function basePickBy(object, paths, predicate) {
  var index2 = -1, length3 = paths.length, result = {};
  while (++index2 < length3) {
    var path4 = paths[index2], value = baseGet$1(object, path4);
    if (predicate(value, path4)) {
      baseSet(result, castPath$1(path4, object), value);
    }
  }
  return result;
}
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
function hasPath$1(object, path4, hasFunc) {
  path4 = castPath$1(path4, object);
  var index2 = -1, length3 = path4.length, result = false;
  while (++index2 < length3) {
    var key = toKey$1(path4[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength$1(length3) && isIndex$1(key, length3) && (isArray$2(object) || isArguments$2(object));
}
function hasIn$1(object, path4) {
  return object != null && hasPath$1(object, path4, baseHasIn$1);
}
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path4) {
    return hasIn$1(object, path4);
  });
}
function arrayPush$1(array, values4) {
  var index2 = -1, length3 = values4.length, offset = array.length;
  while (++index2 < length3) {
    array[offset + index2] = values4[index2];
  }
  return array;
}
var spreadableSymbol$1 = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$2(value) || isArguments$2(value) || !!(spreadableSymbol$1 && value && value[spreadableSymbol$1]);
}
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length3 = array.length;
  predicate || (predicate = isFlattenable$1);
  result || (result = []);
  while (++index2 < length3) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush$1(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function flatten(array) {
  var length3 = array == null ? 0 : array.length;
  return length3 ? baseFlatten$1(array, 1) : [];
}
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$3 = Math.max;
function overRest$1(func, start, transform7) {
  start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length3 = nativeMax$3(args.length - start, 0), array = Array(length3);
    while (++index2 < length3) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform7(array);
    return apply$1(func, this, otherArgs);
  };
}
function constant$1(value) {
  return function() {
    return value;
  };
}
var baseSetToString$1 = !defineProperty$2 ? identity$1 : function(func, string) {
  return defineProperty$2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$1(string),
    "writable": true
  });
};
var baseSetToString$2 = baseSetToString$1;
var HOT_COUNT$1 = 800;
var HOT_SPAN$1 = 16;
var nativeNow$1 = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT$1) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString$1 = shortOut$1(baseSetToString$2);
var setToString$2 = setToString$1;
function flatRest(func) {
  return setToString$2(overRest$1(func, void 0, flatten), func + "");
}
var pick2 = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick$1 = pick2;
function baseRest$1(func, start) {
  return setToString$2(overRest$1(func, start, identity$1), func + "");
}
function isIterateeCall(value, index2, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$1(object) && isIndex$1(index2, object.length) : type == "string" && index2 in object) {
    return eq$1(object[index2], value);
  }
  return false;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$j = Object.prototype;
var hasOwnProperty$f = objectProto$j.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$f.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
}
var objectProto$i = Object.prototype;
var hasOwnProperty$e = objectProto$i.hasOwnProperty;
var defaults = baseRest$1(function(object, sources) {
  object = Object(object);
  var index2 = -1;
  var length3 = sources.length;
  var guard = length3 > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length3 = 1;
  }
  while (++index2 < length3) {
    var source = sources[index2];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq$1(value, objectProto$i[key]) && !hasOwnProperty$e.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults$1 = defaults;
function stackClear$1() {
  this.__data__ = new ListCache$1();
  this.size = 0;
}
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet$1(key) {
  return this.__data__.get(key);
}
function stackHas$1(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$2 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack$1(entries) {
  var data = this.__data__ = new ListCache$1(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear$1;
Stack$1.prototype["delete"] = stackDelete$1;
Stack$1.prototype.get = stackGet$1;
Stack$1.prototype.has = stackHas$1;
Stack$1.prototype.set = stackSet$1;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
function SetCache$1(values4) {
  var index2 = -1, length3 = values4 == null ? 0 : values4.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length3) {
    this.add(values4[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd$1;
SetCache$1.prototype.has = setCacheHas$1;
function arraySome$1(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas$1(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$b = 1;
var COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$1(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array$1 = root$2.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function mapToArray$1(map4) {
  var index2 = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray$1(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$a = 1;
var COMPARE_UNORDERED_FLAG$6 = 2;
var boolTag$4 = "[object Boolean]";
var dateTag$4 = "[object Date]";
var errorTag$3 = "[object Error]";
var mapTag$a = "[object Map]";
var numberTag$4 = "[object Number]";
var regexpTag$4 = "[object RegExp]";
var setTag$a = "[object Set]";
var stringTag$5 = "[object String]";
var symbolTag$4 = "[object Symbol]";
var arrayBufferTag$4 = "[object ArrayBuffer]";
var dataViewTag$6 = "[object DataView]";
var symbolProto$3 = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolValueOf$2 = symbolProto$3 ? symbolProto$3.valueOf : void 0;
function equalByTag$1(object, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag$6:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
      return eq$1(+object, +other);
    case errorTag$3:
      return object.name == other.name && object.message == other.message;
    case regexpTag$4:
    case stringTag$5:
      return object == other + "";
    case mapTag$a:
      var convert = mapToArray$1;
    case setTag$a:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
      convert || (convert = setToArray$1);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$6;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$4:
      if (symbolValueOf$2) {
        return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
      }
  }
  return false;
}
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$2(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
function arrayFilter$1(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length3) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray$1() {
  return [];
}
var objectProto$h = Object.prototype;
var propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols$2 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$2(object), function(symbol) {
    return propertyIsEnumerable$2.call(object, symbol);
  });
};
var getSymbols$2 = getSymbols$1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols$2);
}
var COMPARE_PARTIAL_FLAG$9 = 1;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$1(object), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$d.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView$1 = getNative$1(root$2, "DataView");
var DataView$2 = DataView$1;
var Promise$2 = getNative$1(root$2, "Promise");
var Promise$3 = Promise$2;
var Set$2 = getNative$1(root$2, "Set");
var Set$3 = Set$2;
var WeakMap$1 = getNative$1(root$2, "WeakMap");
var WeakMap$2 = WeakMap$1;
var mapTag$9 = "[object Map]";
var objectTag$5 = "[object Object]";
var promiseTag$1 = "[object Promise]";
var setTag$9 = "[object Set]";
var weakMapTag$3 = "[object WeakMap]";
var dataViewTag$5 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$2);
var mapCtorString$1 = toSource$1(Map$2);
var promiseCtorString$1 = toSource$1(Promise$3);
var setCtorString$1 = toSource$1(Set$3);
var weakMapCtorString$1 = toSource$1(WeakMap$2);
var getTag$2 = baseGetTag$1;
if (DataView$2 && getTag$2(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$2 && getTag$2(new Map$2()) != mapTag$9 || Promise$3 && getTag$2(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$2(new Set$3()) != setTag$9 || WeakMap$2 && getTag$2(new WeakMap$2()) != weakMapTag$3) {
  getTag$2 = function(value) {
    var result = baseGetTag$1(value), Ctor = result == objectTag$5 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$5;
        case mapCtorString$1:
          return mapTag$9;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$9;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var getTag$3 = getTag$2;
var COMPARE_PARTIAL_FLAG$8 = 1;
var argsTag$4 = "[object Arguments]";
var arrayTag$3 = "[object Array]";
var objectTag$4 = "[object Object]";
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag$3 : getTag$3(object), othTag = othIsArr ? arrayTag$3 : getTag$3(other);
  objTag = objTag == argsTag$4 ? objectTag$4 : objTag;
  othTag = othTag == argsTag$4 ? objectTag$4 : othTag;
  var objIsObj = objTag == objectTag$4, othIsObj = othTag == objectTag$4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$2(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$c.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$1(value) && !isObjectLike$1(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var COMPARE_PARTIAL_FLAG$7 = 1;
var COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length3) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable$1(value) {
  return value === value && !isObject$1(value);
}
function getMatchData$1(object) {
  var result = keys$1(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
function matchesStrictComparable$1(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches$1(source) {
  var matchData = getMatchData$1(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch$1(object, source, matchData);
  };
}
function get$1(object, path4, defaultValue) {
  var result = object == null ? void 0 : baseGet$1(object, path4);
  return result === void 0 ? defaultValue : result;
}
var COMPARE_PARTIAL_FLAG$6 = 1;
var COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$1(path4, srcValue) {
  if (isKey$1(path4) && isStrictComparable$1(srcValue)) {
    return matchesStrictComparable$1(toKey$1(path4), srcValue);
  }
  return function(object) {
    var objValue = get$1(object, path4);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path4) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep$1(path4) {
  return function(object) {
    return baseGet$1(object, path4);
  };
}
function property$1(path4) {
  return isKey$1(path4) ? baseProperty$1(toKey$1(path4)) : basePropertyDeep$1(path4);
}
function baseIteratee$1(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$2(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
  }
  return property$1(value);
}
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee$1(iteratee);
  baseForOwn$1(object, function(value, key, object2) {
    baseAssignValue(result, key, iteratee(value, key, object2));
  });
  return result;
}
function baseMap$1(collection, iteratee) {
  var index2 = -1, result = isArrayLike$1(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map$1(collection, iteratee) {
  var func = isArray$2(collection) ? arrayMap$1 : baseMap$1;
  return func(collection, baseIteratee$1(iteratee));
}
var nativeCeil = Math.ceil;
var nativeMax$2 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index2 = -1, length3 = nativeMax$2(nativeCeil((end - start) / (step || 1)), 0), result = Array(length3);
  while (length3--) {
    result[fromRight ? length3 : ++index2] = start;
    start += step;
  }
  return result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$3 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$3 || value === -INFINITY$3) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}
var range = createRange();
var range$1 = range;
function baseValues$1(object, props) {
  return arrayMap$1(props, function(key) {
    return object[key];
  });
}
function values$1(object) {
  return object == null ? [] : baseValues$1(object, keys$1(object));
}
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  if (initAccum && length3) {
    accumulator = array[++index2];
  }
  while (++index2 < length3) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
function reduce$1(collection, iteratee, accumulator) {
  var func = isArray$2(collection) ? arrayReduce$1 : baseReduce$1, initAccum = arguments.length < 3;
  return func(collection, baseIteratee$1(iteratee), accumulator, initAccum, baseEach$2);
}
function baseExtremum(array, iteratee, comparator) {
  var index2 = -1, length3 = array.length;
  while (++index2 < length3) {
    var value = array[index2], current = iteratee(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol$1(current) : comparator(current, computed))) {
      var computed = current, result = value;
    }
  }
  return result;
}
function baseLt(value, other) {
  return value < other;
}
function minBy(array, iteratee) {
  return array && array.length ? baseExtremum(array, baseIteratee$1(iteratee), baseLt) : void 0;
}
function baseGt(value, other) {
  return value > other;
}
function maxBy(array, iteratee) {
  return array && array.length ? baseExtremum(array, baseIteratee$1(iteratee), baseGt) : void 0;
}
function min3(array) {
  return array && array.length ? baseExtremum(array, identity$1, baseLt) : void 0;
}
function max3(array) {
  return array && array.length ? baseExtremum(array, identity$1, baseGt) : void 0;
}
function baseFilter$1(collection, predicate) {
  var result = [];
  baseEach$2(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
function filter$1(collection, predicate) {
  var func = isArray$2(collection) ? arrayFilter$1 : baseFilter$1;
  return func(collection, baseIteratee$1(predicate));
}
var idCounter = 0;
function uniqueId(prefix) {
  var id9 = ++idCounter;
  return toString$1(prefix) + id9;
}
function baseZipObject(props, values4, assignFunc) {
  var index2 = -1, length3 = props.length, valsLength = values4.length, result = {};
  while (++index2 < length3) {
    var value = index2 < valsLength ? values4[index2] : void 0;
    assignFunc(result, props[index2], value);
  }
  return result;
}
function zipObject(props, values4) {
  return baseZipObject(props || [], values4 || [], assignValue);
}
function baseSortBy(array, comparer) {
  var length3 = array.length;
  array.sort(comparer);
  while (length3--) {
    array[length3] = array[length3].value;
  }
  return array;
}
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol$1(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol$1(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
function compareMultiple(object, other, orders) {
  var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length3 = objCriteria.length, ordersLength = orders.length;
  while (++index2 < length3) {
    var result = compareAscending(objCriteria[index2], othCriteria[index2]);
    if (result) {
      if (index2 >= ordersLength) {
        return result;
      }
      var order2 = orders[index2];
      return result * (order2 == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap$1(iteratees, function(iteratee) {
      if (isArray$2(iteratee)) {
        return function(value) {
          return baseGet$1(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$1];
  }
  var index2 = -1;
  iteratees = arrayMap$1(iteratees, baseUnary$1(baseIteratee$1));
  var result = baseMap$1(collection, function(value, key, collection2) {
    var criteria = arrayMap$1(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index2, "value": value };
  });
  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}
var sortBy = baseRest$1(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length3 = iteratees.length;
  if (length3 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length3 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);
});
var sortBy$1 = sortBy;
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike$1(collection)) {
      var iteratee = baseIteratee$1(predicate);
      collection = keys$1(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index2 = findIndexFunc(collection, predicate, fromIndex);
    return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
  };
}
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length3 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var nativeMax$1 = Math.max;
function findIndex(array, predicate, fromIndex) {
  var length3 = array == null ? 0 : array.length;
  if (!length3) {
    return -1;
  }
  var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index2 < 0) {
    index2 = nativeMax$1(length3 + index2, 0);
  }
  return baseFindIndex$1(array, baseIteratee$1(predicate), index2);
}
var find = createFind(findIndex);
var find$1 = find;
function baseToPairs(object, props) {
  return arrayMap$1(props, function(key) {
    return [key, object[key]];
  });
}
function setToPairs(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = [value, value];
  });
  return result;
}
var mapTag$8 = "[object Map]";
var setTag$8 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag2 = getTag$3(object);
    if (tag2 == mapTag$8) {
      return mapToArray$1(object);
    }
    if (tag2 == setTag$8) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}
var toPairs = createToPairs(keys$1);
var toPairs$1 = toPairs;
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length3 = props.length;
  while (++index2 < length3) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseAssign(object, source) {
  return object && copyObject(source, keys$1(source), object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0;
var allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length3 = buffer.length, result = allocUnsafe ? allocUnsafe(length3) : new buffer.constructor(length3);
  buffer.copy(result);
  return result;
}
function copyArray(source, array) {
  var index2 = -1, length3 = source.length;
  array || (array = Array(length3));
  while (++index2 < length3) {
    array[index2] = source[index2];
  }
  return array;
}
function copySymbols(source, object) {
  return copyObject(source, getSymbols$2(source), object);
}
var getPrototype$1 = overArg$1(Object.getPrototypeOf, Object);
var getPrototype$2 = getPrototype$1;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$2(object));
    object = getPrototype$2(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function getAllKeysIn(object) {
  return baseGetAllKeys$1(object, keysIn, getSymbolsIn$1);
}
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
function initCloneArray(array) {
  var length3 = array.length, result = new array.constructor(length3);
  if (length3 && typeof array[0] == "string" && hasOwnProperty$b.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$3 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var mapTag$7 = "[object Map]";
var numberTag$3 = "[object Number]";
var regexpTag$3 = "[object RegExp]";
var setTag$7 = "[object Set]";
var stringTag$4 = "[object String]";
var symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]";
var dataViewTag$4 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag(object, tag2, isDeep) {
  var Ctor = object.constructor;
  switch (tag2) {
    case arrayBufferTag$3:
      return cloneArrayBuffer(object);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);
    case dataViewTag$4:
      return cloneDataView(object, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray(object, isDeep);
    case mapTag$7:
      return new Ctor();
    case numberTag$3:
    case stringTag$4:
      return new Ctor(object);
    case regexpTag$3:
      return cloneRegExp(object);
    case setTag$7:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object);
  }
}
var objectCreate$1 = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$1(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$2 = baseCreate$1;
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate$2(getPrototype$2(object)) : {};
}
var mapTag$6 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike$1(value) && getTag$3(value) == mapTag$6;
}
var nodeIsMap = nodeUtil$2 && nodeUtil$2.isMap;
var isMap = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$6 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike$1(value) && getTag$3(value) == setTag$6;
}
var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
var isSet = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$3 = "[object Arguments]";
var arrayTag$2 = "[object Array]";
var boolTag$2 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var errorTag$2 = "[object Error]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var mapTag$5 = "[object Map]";
var numberTag$2 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$2 = "[object RegExp]";
var setTag$5 = "[object Set]";
var stringTag$3 = "[object String]";
var symbolTag$2 = "[object Symbol]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$5] = cloneableTags[numberTag$2] = cloneableTags[objectTag$3] = cloneableTags[regexpTag$2] = cloneableTags[setTag$5] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag2 = getTag$3(value), isFunc = tag2 == funcTag$2 || tag2 == genTag$1;
    if (isBuffer$2(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag2 == objectTag$3 || tag2 == argsTag$3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag2, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1;
var CLONE_SYMBOLS_FLAG = 4;
function cloneDeep2(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function has$1(o, k) {
  return Boolean(o && k && k in o);
}
function last2(list) {
  if (!(list && list.length))
    return;
  return list[list.length - 1];
}
function isUndefined$1(o) {
  return typeof o === "undefined";
}
var objectProto$d2 = Object.prototype;
var hasOwnProperty$a2 = objectProto$d2.hasOwnProperty;
function baseHas2(object, key) {
  return object != null && hasOwnProperty$a2.call(object, key);
}
var isArray2 = Array.isArray;
var freeGlobal2 = typeof global == "object" && global && global.Object === Object && global;
var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
var Symbol3 = root2.Symbol;
var objectProto$c2 = Object.prototype;
var hasOwnProperty$92 = objectProto$c2.hasOwnProperty;
var nativeObjectToString$12 = objectProto$c2.toString;
var symToStringTag$12 = Symbol3 ? Symbol3.toStringTag : void 0;
function getRawTag2(value) {
  var isOwn = hasOwnProperty$92.call(value, symToStringTag$12), tag2 = value[symToStringTag$12];
  try {
    value[symToStringTag$12] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$12.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$12] = tag2;
    } else {
      delete value[symToStringTag$12];
    }
  }
  return result;
}
var objectProto$b2 = Object.prototype;
var nativeObjectToString2 = objectProto$b2.toString;
function objectToString2(value) {
  return nativeObjectToString2.call(value);
}
var nullTag2 = "[object Null]";
var undefinedTag2 = "[object Undefined]";
var symToStringTag2 = Symbol3 ? Symbol3.toStringTag : void 0;
function baseGetTag2(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag2 : nullTag2;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag2(value) : objectToString2(value);
}
function isObjectLike2(value) {
  return value != null && typeof value == "object";
}
var symbolTag$12 = "[object Symbol]";
function isSymbol2(value) {
  return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag$12;
}
var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp2 = /^\w*$/;
function isKey2(value, object) {
  if (isArray2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
    return true;
  }
  return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object(object);
}
function isObject2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag2 = "[object AsyncFunction]";
var funcTag$12 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var proxyTag2 = "[object Proxy]";
function isFunction2(value) {
  if (!isObject2(value)) {
    return false;
  }
  var tag2 = baseGetTag2(value);
  return tag2 == funcTag$12 || tag2 == genTag2 || tag2 == asyncTag2 || tag2 == proxyTag2;
}
var coreJsData2 = root2["__core-js_shared__"];
var maskSrcKey2 = function() {
  var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked2(func) {
  return !!maskSrcKey2 && maskSrcKey2 in func;
}
var funcProto$12 = Function.prototype;
var funcToString$12 = funcProto$12.toString;
function toSource2(func) {
  if (func != null) {
    try {
      return funcToString$12.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto$a2 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty$82 = objectProto$a2.hasOwnProperty;
var reIsNative2 = RegExp(
  "^" + funcToString2.call(hasOwnProperty$82).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative2(value) {
  if (!isObject2(value) || isMasked2(value)) {
    return false;
  }
  var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
  return pattern.test(toSource2(value));
}
function getValue2(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative2(object, key) {
  var value = getValue2(object, key);
  return baseIsNative2(value) ? value : void 0;
}
var nativeCreate2 = getNative2(Object, "create");
function hashClear2() {
  this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  this.size = 0;
}
function hashDelete2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$22 = "__lodash_hash_undefined__";
var objectProto$92 = Object.prototype;
var hasOwnProperty$72 = objectProto$92.hasOwnProperty;
function hashGet2(key) {
  var data = this.__data__;
  if (nativeCreate2) {
    var result = data[key];
    return result === HASH_UNDEFINED$22 ? void 0 : result;
  }
  return hasOwnProperty$72.call(data, key) ? data[key] : void 0;
}
var objectProto$82 = Object.prototype;
var hasOwnProperty$62 = objectProto$82.hasOwnProperty;
function hashHas2(key) {
  var data = this.__data__;
  return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty$62.call(data, key);
}
var HASH_UNDEFINED$12 = "__lodash_hash_undefined__";
function hashSet2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED$12 : value;
  return this;
}
function Hash2(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash2.prototype.clear = hashClear2;
Hash2.prototype["delete"] = hashDelete2;
Hash2.prototype.get = hashGet2;
Hash2.prototype.has = hashHas2;
Hash2.prototype.set = hashSet2;
function listCacheClear2() {
  this.__data__ = [];
  this.size = 0;
}
function eq2(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf2(array, key) {
  var length3 = array.length;
  while (length3--) {
    if (eq2(array[length3][0], key)) {
      return length3;
    }
  }
  return -1;
}
var arrayProto2 = Array.prototype;
var splice2 = arrayProto2.splice;
function listCacheDelete2(key) {
  var data = this.__data__, index2 = assocIndexOf2(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice2.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet2(key) {
  var data = this.__data__, index2 = assocIndexOf2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas2(key) {
  return assocIndexOf2(this.__data__, key) > -1;
}
function listCacheSet2(key, value) {
  var data = this.__data__, index2 = assocIndexOf2(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache2(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache2.prototype.clear = listCacheClear2;
ListCache2.prototype["delete"] = listCacheDelete2;
ListCache2.prototype.get = listCacheGet2;
ListCache2.prototype.has = listCacheHas2;
ListCache2.prototype.set = listCacheSet2;
var Map3 = getNative2(root2, "Map");
function mapCacheClear2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash2(),
    "map": new (Map3 || ListCache2)(),
    "string": new Hash2()
  };
}
function isKeyable2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData2(map4, key) {
  var data = map4.__data__;
  return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete2(key) {
  var result = getMapData2(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet2(key) {
  return getMapData2(this, key).get(key);
}
function mapCacheHas2(key) {
  return getMapData2(this, key).has(key);
}
function mapCacheSet2(key, value) {
  var data = getMapData2(this, key), size4 = data.size;
  data.set(key, value);
  this.size += data.size == size4 ? 0 : 1;
  return this;
}
function MapCache2(entries) {
  var index2 = -1, length3 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length3) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache2.prototype.clear = mapCacheClear2;
MapCache2.prototype["delete"] = mapCacheDelete2;
MapCache2.prototype.get = mapCacheGet2;
MapCache2.prototype.has = mapCacheHas2;
MapCache2.prototype.set = mapCacheSet2;
var FUNC_ERROR_TEXT2 = "Expected a function";
function memoize2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize2.Cache || MapCache2)();
  return memoized;
}
memoize2.Cache = MapCache2;
var MAX_MEMOIZE_SIZE2 = 500;
function memoizeCapped2(func) {
  var result = memoize2(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE2) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar2 = /\\(\\)?/g;
var stringToPath2 = memoizeCapped2(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName2, function(match, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar2, "$1") : number4 || match);
  });
  return result;
});
function arrayMap2(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length, result = Array(length3);
  while (++index2 < length3) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var INFINITY$22 = 1 / 0;
var symbolProto$12 = Symbol3 ? Symbol3.prototype : void 0;
var symbolToString2 = symbolProto$12 ? symbolProto$12.toString : void 0;
function baseToString2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray2(value)) {
    return arrayMap2(value, baseToString2) + "";
  }
  if (isSymbol2(value)) {
    return symbolToString2 ? symbolToString2.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$22 ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString2(value);
}
function castPath2(value, object) {
  if (isArray2(value)) {
    return value;
  }
  return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
}
var argsTag$22 = "[object Arguments]";
function baseIsArguments2(value) {
  return isObjectLike2(value) && baseGetTag2(value) == argsTag$22;
}
var objectProto$72 = Object.prototype;
var hasOwnProperty$52 = objectProto$72.hasOwnProperty;
var propertyIsEnumerable$12 = objectProto$72.propertyIsEnumerable;
var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments2 : function(value) {
  return isObjectLike2(value) && hasOwnProperty$52.call(value, "callee") && !propertyIsEnumerable$12.call(value, "callee");
};
var MAX_SAFE_INTEGER$12 = 9007199254740991;
var reIsUint2 = /^(?:0|[1-9]\d*)$/;
function isIndex2(value, length3) {
  var type = typeof value;
  length3 = length3 == null ? MAX_SAFE_INTEGER$12 : length3;
  return !!length3 && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
}
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var INFINITY$12 = 1 / 0;
function toKey2(value) {
  if (typeof value == "string" || isSymbol2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$12 ? "-0" : result;
}
function hasPath2(object, path4, hasFunc) {
  path4 = castPath2(path4, object);
  var index2 = -1, length3 = path4.length, result = false;
  while (++index2 < length3) {
    var key = toKey2(path4[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length3) {
    return result;
  }
  length3 = object == null ? 0 : object.length;
  return !!length3 && isLength2(length3) && isIndex2(key, length3) && (isArray2(object) || isArguments2(object));
}
function has2(object, path4) {
  return object != null && hasPath2(object, path4, baseHas2);
}
function arrayEach2(array, iteratee) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
function createBaseFor2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length3 = props.length;
    while (length3--) {
      var key = props[fromRight ? length3 : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor2 = createBaseFor2();
function baseTimes2(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
function stubFalse2() {
  return false;
}
var freeExports$12 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$12 = freeExports$12 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$12 = freeModule$12 && freeModule$12.exports === freeExports$12;
var Buffer3 = moduleExports$12 ? root2.Buffer : void 0;
var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
var isBuffer2 = nativeIsBuffer2 || stubFalse2;
var argsTag$12 = "[object Arguments]";
var arrayTag$12 = "[object Array]";
var boolTag$12 = "[object Boolean]";
var dateTag$12 = "[object Date]";
var errorTag$12 = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag$42 = "[object Map]";
var numberTag$12 = "[object Number]";
var objectTag$22 = "[object Object]";
var regexpTag$12 = "[object RegExp]";
var setTag$42 = "[object Set]";
var stringTag$22 = "[object String]";
var weakMapTag$12 = "[object WeakMap]";
var arrayBufferTag$12 = "[object ArrayBuffer]";
var dataViewTag$22 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
var typedArrayTags2 = {};
typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
typedArrayTags2[argsTag$12] = typedArrayTags2[arrayTag$12] = typedArrayTags2[arrayBufferTag$12] = typedArrayTags2[boolTag$12] = typedArrayTags2[dataViewTag$22] = typedArrayTags2[dateTag$12] = typedArrayTags2[errorTag$12] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag$42] = typedArrayTags2[numberTag$12] = typedArrayTags2[objectTag$22] = typedArrayTags2[regexpTag$12] = typedArrayTags2[setTag$42] = typedArrayTags2[stringTag$22] = typedArrayTags2[weakMapTag$12] = false;
function baseIsTypedArray2(value) {
  return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
}
function baseUnary2(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess2 = moduleExports2 && freeGlobal2.process;
var nodeUtil2 = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
  } catch (e) {
  }
}();
var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
var objectProto$62 = Object.prototype;
var hasOwnProperty$42 = objectProto$62.hasOwnProperty;
function arrayLikeKeys2(value, inherited) {
  var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes2(value.length, String) : [], length3 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$42.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex2(key, length3)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$52 = Object.prototype;
function isPrototype2(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$52;
  return value === proto;
}
function overArg2(func, transform7) {
  return function(arg) {
    return func(transform7(arg));
  };
}
var nativeKeys2 = overArg2(Object.keys, Object);
var objectProto$42 = Object.prototype;
var hasOwnProperty$32 = objectProto$42.hasOwnProperty;
function baseKeys2(object) {
  if (!isPrototype2(object)) {
    return nativeKeys2(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$32.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike2(value) {
  return value != null && isLength2(value.length) && !isFunction2(value);
}
function keys2(object) {
  return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
}
function baseForOwn2(object, iteratee) {
  return object && baseFor2(object, iteratee, keys2);
}
function createBaseEach2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike2(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length3 = collection.length, index2 = fromRight ? length3 : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length3) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach2 = createBaseEach2(baseForOwn2);
function identity3(value) {
  return value;
}
function castFunction2(value) {
  return typeof value == "function" ? value : identity3;
}
function forEach3(collection, iteratee) {
  var func = isArray2(collection) ? arrayEach2 : baseEach2;
  return func(collection, castFunction2(iteratee));
}
var DataView3 = getNative2(root2, "DataView");
var Promise$12 = getNative2(root2, "Promise");
var Set$1 = getNative2(root2, "Set");
var WeakMap3 = getNative2(root2, "WeakMap");
var mapTag$32 = "[object Map]";
var objectTag$12 = "[object Object]";
var promiseTag2 = "[object Promise]";
var setTag$32 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag$12 = "[object DataView]";
var dataViewCtorString2 = toSource2(DataView3);
var mapCtorString2 = toSource2(Map3);
var promiseCtorString2 = toSource2(Promise$12);
var setCtorString2 = toSource2(Set$1);
var weakMapCtorString2 = toSource2(WeakMap3);
var getTag2 = baseGetTag2;
if (DataView3 && getTag2(new DataView3(new ArrayBuffer(1))) != dataViewTag$12 || Map3 && getTag2(new Map3()) != mapTag$32 || Promise$12 && getTag2(Promise$12.resolve()) != promiseTag2 || Set$1 && getTag2(new Set$1()) != setTag$32 || WeakMap3 && getTag2(new WeakMap3()) != weakMapTag2) {
  getTag2 = function(value) {
    var result = baseGetTag2(value), Ctor = result == objectTag$12 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString2:
          return dataViewTag$12;
        case mapCtorString2:
          return mapTag$32;
        case promiseCtorString2:
          return promiseTag2;
        case setCtorString2:
          return setTag$32;
        case weakMapCtorString2:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag$12 = getTag2;
var stringTag$12 = "[object String]";
function isString2(value) {
  return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag$12;
}
function baseProperty2(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var asciiSize2 = baseProperty2("length");
var rsAstralRange$12 = "\\ud800-\\udfff";
var rsComboMarksRange$12 = "\\u0300-\\u036f";
var reComboHalfMarksRange$12 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange$12 = "\\u20d0-\\u20ff";
var rsComboRange$12 = rsComboMarksRange$12 + reComboHalfMarksRange$12 + rsComboSymbolsRange$12;
var rsVarRange$12 = "\\ufe0e\\ufe0f";
var rsZWJ$12 = "\\u200d";
var reHasUnicode2 = RegExp("[" + rsZWJ$12 + rsAstralRange$12 + rsComboRange$12 + rsVarRange$12 + "]");
function hasUnicode2(string) {
  return reHasUnicode2.test(string);
}
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange2 + "]";
var rsCombo2 = "[" + rsComboRange2 + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange2 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange2 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
function unicodeSize2(string) {
  var result = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result;
  }
  return result;
}
function stringSize2(string) {
  return hasUnicode2(string) ? unicodeSize2(string) : asciiSize2(string);
}
var mapTag$22 = "[object Map]";
var setTag$22 = "[object Set]";
function size2(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike2(collection)) {
    return isString2(collection) ? stringSize2(collection) : collection.length;
  }
  var tag2 = getTag$12(collection);
  if (tag2 == mapTag$22 || tag2 == setTag$22) {
    return collection.size;
  }
  return baseKeys2(collection).length;
}
function constant2(value) {
  return function() {
    return value;
  };
}
function arrayFilter2(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length3) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function baseFilter2(collection, predicate) {
  var result = [];
  baseEach2(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
function stackClear2() {
  this.__data__ = new ListCache2();
  this.size = 0;
}
function stackDelete2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet2(key) {
  return this.__data__.get(key);
}
function stackHas2(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE$12 = 200;
function stackSet2(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache2) {
    var pairs = data.__data__;
    if (!Map3 || pairs.length < LARGE_ARRAY_SIZE$12 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack2(entries) {
  var data = this.__data__ = new ListCache2(entries);
  this.size = data.size;
}
Stack2.prototype.clear = stackClear2;
Stack2.prototype["delete"] = stackDelete2;
Stack2.prototype.get = stackGet2;
Stack2.prototype.has = stackHas2;
Stack2.prototype.set = stackSet2;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function setCacheAdd2(value) {
  this.__data__.set(value, HASH_UNDEFINED2);
  return this;
}
function setCacheHas2(value) {
  return this.__data__.has(value);
}
function SetCache2(values4) {
  var index2 = -1, length3 = values4 == null ? 0 : values4.length;
  this.__data__ = new MapCache2();
  while (++index2 < length3) {
    this.add(values4[index2]);
  }
}
SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
SetCache2.prototype.has = setCacheHas2;
function arraySome2(array, predicate) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas2(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$52 = 1;
var COMPARE_UNORDERED_FLAG$32 = 2;
function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$52, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$32 ? new SetCache2() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome2(other, function(othValue2, othIndex) {
        if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array3 = root2.Uint8Array;
function mapToArray2(map4) {
  var index2 = -1, result = Array(map4.size);
  map4.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray2(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$42 = 1;
var COMPARE_UNORDERED_FLAG$22 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag$12 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag$12 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var symbolProto2 = Symbol3 ? Symbol3.prototype : void 0;
var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag2(object, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq2(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag$12:
      var convert = mapToArray2;
    case setTag$12:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$42;
      convert || (convert = setToArray2);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$22;
      stack.set(object, other);
      var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
function arrayPush2(array, values4) {
  var index2 = -1, length3 = values4.length, offset = array.length;
  while (++index2 < length3) {
    array[offset + index2] = values4[index2];
  }
  return array;
}
function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
}
function stubArray2() {
  return [];
}
var objectProto$32 = Object.prototype;
var propertyIsEnumerable2 = objectProto$32.propertyIsEnumerable;
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
function getAllKeys2(object) {
  return baseGetAllKeys2(object, keys2, getSymbols2);
}
var COMPARE_PARTIAL_FLAG$32 = 1;
var objectProto$22 = Object.prototype;
var hasOwnProperty$22 = objectProto$22.hasOwnProperty;
function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$32, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$22.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$22 = 1;
var argsTag2 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag2 = "[object Object]";
var objectProto$12 = Object.prototype;
var hasOwnProperty$12 = objectProto$12.hasOwnProperty;
function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag$12(object), othTag = othIsArr ? arrayTag2 : getTag$12(other);
  objTag = objTag == argsTag2 ? objectTag2 : objTag;
  othTag = othTag == argsTag2 ? objectTag2 : othTag;
  var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer2(object)) {
    if (!isBuffer2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack2());
    return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$22)) {
    var objIsWrapped = objIsObj && hasOwnProperty$12.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$12.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack2());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack2());
  return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack);
}
var COMPARE_PARTIAL_FLAG$12 = 1;
var COMPARE_UNORDERED_FLAG$12 = 2;
function baseIsMatch2(object, source, matchData, customizer) {
  var index2 = matchData.length, length3 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length3;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length3) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack2();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG$12 | COMPARE_UNORDERED_FLAG$12, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable2(value) {
  return value === value && !isObject2(value);
}
function getMatchData2(object) {
  var result = keys2(object), length3 = result.length;
  while (length3--) {
    var key = result[length3], value = object[key];
    result[length3] = [key, value, isStrictComparable2(value)];
  }
  return result;
}
function matchesStrictComparable2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches2(source) {
  var matchData = getMatchData2(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch2(object, source, matchData);
  };
}
function baseGet2(object, path4) {
  path4 = castPath2(path4, object);
  var index2 = 0, length3 = path4.length;
  while (object != null && index2 < length3) {
    object = object[toKey2(path4[index2++])];
  }
  return index2 && index2 == length3 ? object : void 0;
}
function get2(object, path4, defaultValue) {
  var result = object == null ? void 0 : baseGet2(object, path4);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn2(object, key) {
  return object != null && key in Object(object);
}
function hasIn2(object, path4) {
  return object != null && hasPath2(object, path4, baseHasIn2);
}
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
function baseMatchesProperty2(path4, srcValue) {
  if (isKey2(path4) && isStrictComparable2(srcValue)) {
    return matchesStrictComparable2(toKey2(path4), srcValue);
  }
  return function(object) {
    var objValue = get2(object, path4);
    return objValue === void 0 && objValue === srcValue ? hasIn2(object, path4) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
  };
}
function basePropertyDeep2(path4) {
  return function(object) {
    return baseGet2(object, path4);
  };
}
function property2(path4) {
  return isKey2(path4) ? baseProperty2(toKey2(path4)) : basePropertyDeep2(path4);
}
function baseIteratee2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity3;
  }
  if (typeof value == "object") {
    return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
  }
  return property2(value);
}
function filter2(collection, predicate) {
  var func = isArray2(collection) ? arrayFilter2 : baseFilter2;
  return func(collection, baseIteratee2(predicate));
}
function isUndefined2(value) {
  return value === void 0;
}
var spreadableSymbol2 = Symbol3 ? Symbol3.isConcatSpreadable : void 0;
function isFlattenable2(value) {
  return isArray2(value) || isArguments2(value) || !!(spreadableSymbol2 && value && value[spreadableSymbol2]);
}
function baseFlatten2(array, depth, predicate, isStrict, result) {
  var index2 = -1, length3 = array.length;
  predicate || (predicate = isFlattenable2);
  result || (result = []);
  while (++index2 < length3) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten2(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush2(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function apply2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax2 = Math.max;
function overRest2(func, start, transform7) {
  start = nativeMax2(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length3 = nativeMax2(args.length - start, 0), array = Array(length3);
    while (++index2 < length3) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform7(array);
    return apply2(func, this, otherArgs);
  };
}
var defineProperty2 = function() {
  try {
    var func = getNative2(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var baseSetToString2 = !defineProperty2 ? identity3 : function(func, string) {
  return defineProperty2(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant2(string),
    "writable": true
  });
};
var HOT_COUNT2 = 800;
var HOT_SPAN2 = 16;
var nativeNow2 = Date.now;
function shortOut2(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT2) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString2 = shortOut2(baseSetToString2);
function baseRest2(func, start) {
  return setToString2(overRest2(func, start, identity3), func + "");
}
function baseFindIndex2(array, predicate, fromIndex, fromRight) {
  var length3 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length3) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN2(value) {
  return value !== value;
}
function strictIndexOf2(array, value, fromIndex) {
  var index2 = fromIndex - 1, length3 = array.length;
  while (++index2 < length3) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf2(array, value, fromIndex) {
  return value === value ? strictIndexOf2(array, value, fromIndex) : baseFindIndex2(array, baseIsNaN2, fromIndex);
}
function arrayIncludes2(array, value) {
  var length3 = array == null ? 0 : array.length;
  return !!length3 && baseIndexOf2(array, value, 0) > -1;
}
function arrayIncludesWith2(array, value, comparator) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  while (++index2 < length3) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
function noop2() {
}
var INFINITY2 = 1 / 0;
var createSet2 = !(Set$1 && 1 / setToArray2(new Set$1([, -0]))[1] == INFINITY2) ? noop2 : function(values4) {
  return new Set$1(values4);
};
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq2(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes2, length3 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith2;
  } else if (length3 >= LARGE_ARRAY_SIZE2) {
    var set3 = iteratee ? null : createSet2(array);
    if (set3) {
      return setToArray2(set3);
    }
    isCommon = false;
    includes = cacheHas2;
    seen = new SetCache2();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length3) {
      var value = array[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
function isArrayLikeObject2(value) {
  return isObjectLike2(value) && isArrayLike2(value);
}
var union2 = baseRest2(function(arrays) {
  return baseUniq2(baseFlatten2(arrays, 1, isArrayLikeObject2, true));
});
var objectCreate2 = Object.create;
var baseCreate2 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject2(proto)) {
      return {};
    }
    if (objectCreate2) {
      return objectCreate2(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
function transform4(object, iteratee, accumulator) {
  var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
  iteratee = baseIteratee2(iteratee);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject2(object)) {
      accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index2, object2) {
    return iteratee(accumulator, value, index2, object2);
  });
  return accumulator;
}
function baseMap2(collection, iteratee) {
  var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
  baseEach2(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map2(collection, iteratee) {
  var func = isArray2(collection) ? arrayMap2 : baseMap2;
  return func(collection, baseIteratee2(iteratee));
}
function baseValues2(object, props) {
  return arrayMap2(props, function(key) {
    return object[key];
  });
}
function values2(object) {
  return object == null ? [] : baseValues2(object, keys2(object));
}
var mapTag2 = "[object Map]";
var setTag2 = "[object Set]";
var objectProto2 = Object.prototype;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
function isEmpty2(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
    return !value.length;
  }
  var tag2 = getTag$12(value);
  if (tag2 == mapTag2 || tag2 == setTag2) {
    return !value.size;
  }
  if (isPrototype2(value)) {
    return !baseKeys2(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
function arrayReduce2(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length3 = array == null ? 0 : array.length;
  if (initAccum && length3) {
    accumulator = array[++index2];
  }
  while (++index2 < length3) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
function baseReduce2(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
function reduce2(collection, iteratee, accumulator) {
  var func = isArray2(collection) ? arrayReduce2 : baseReduce2, initAccum = arguments.length < 3;
  return func(collection, baseIteratee2(iteratee), accumulator, initAccum, baseEach2);
}
var _2 = {
  has: has2,
  constant: constant2,
  each: forEach3,
  filter: filter2,
  isUndefined: isUndefined2,
  union: union2,
  transform: transform4,
  size: size2,
  isArray: isArray2,
  map: map2,
  keys: keys2,
  values: values2,
  isEmpty: isEmpty2,
  isFunction: isFunction2,
  reduce: reduce2
};
var DEFAULT_EDGE_NAME2 = "\0";
var GRAPH_NODE2 = "\0";
var EDGE_KEY_DELIM2 = "";
function Graph2(opts) {
  this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
  this._label = void 0;
  this._defaultNodeLabelFn = _2.constant(void 0);
  this._defaultEdgeLabelFn = _2.constant(void 0);
  this._nodes = {};
  if (this._isCompound) {
    this._parent = {};
    this._children = {};
    this._children[GRAPH_NODE2] = {};
  }
  this._in = {};
  this._preds = {};
  this._out = {};
  this._sucs = {};
  this._edgeObjs = {};
  this._edgeLabels = {};
}
Graph2.prototype._nodeCount = 0;
Graph2.prototype._edgeCount = 0;
Graph2.prototype.isDirected = function() {
  return this._isDirected;
};
Graph2.prototype.isMultigraph = function() {
  return this._isMultigraph;
};
Graph2.prototype.isCompound = function() {
  return this._isCompound;
};
Graph2.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};
Graph2.prototype.graph = function() {
  return this._label;
};
Graph2.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_2.isFunction(newDefault)) {
    newDefault = _2.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};
Graph2.prototype.nodeCount = function() {
  return this._nodeCount;
};
Graph2.prototype.nodes = function() {
  return _2.keys(this._nodes);
};
Graph2.prototype.sources = function() {
  const self2 = this;
  return _2.filter(this.nodes(), function(v) {
    return _2.isEmpty(self2._in[v]);
  });
};
Graph2.prototype.sinks = function() {
  const self2 = this;
  return _2.filter(this.nodes(), function(v) {
    return _2.isEmpty(self2._out[v]);
  });
};
Graph2.prototype.setNodes = function(vs, value) {
  const args = arguments;
  const self2 = this;
  _2.each(vs, function(v) {
    if (args.length > 1) {
      self2.setNode(v, value);
    } else {
      self2.setNode(v);
    }
  });
  return this;
};
Graph2.prototype.setNode = function(v, value) {
  if (_2.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }
  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE2;
    this._children[v] = {};
    this._children[GRAPH_NODE2][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};
Graph2.prototype.node = function(v) {
  return this._nodes[v];
};
Graph2.prototype.hasNode = function(v) {
  return _2.has(this._nodes, v);
};
Graph2.prototype.removeNode = function(v) {
  const self2 = this;
  if (_2.has(this._nodes, v)) {
    const removeEdge = function(e) {
      self2.removeEdge(self2._edgeObjs[e]);
    };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _2.each(this.children(v), function(child) {
        self2.setParent(child);
      });
      delete this._children[v];
    }
    _2.each(_2.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _2.each(_2.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};
Graph2.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }
  if (_2.isUndefined(parent)) {
    parent = GRAPH_NODE2;
  } else {
    parent += "";
    for (let ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }
    this.setNode(parent);
  }
  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};
Graph2.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};
Graph2.prototype.parent = function(v) {
  if (this._isCompound) {
    const parent = this._parent[v];
    if (parent !== GRAPH_NODE2) {
      return parent;
    }
  }
};
Graph2.prototype.children = function(v) {
  if (_2.isUndefined(v)) {
    v = GRAPH_NODE2;
  }
  if (this._isCompound) {
    const children = this._children[v];
    if (children) {
      return _2.keys(children);
    }
  } else if (v === GRAPH_NODE2) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};
Graph2.prototype.predecessors = function(v) {
  const predsV = this._preds[v];
  if (predsV) {
    return _2.keys(predsV);
  }
};
Graph2.prototype.successors = function(v) {
  const sucsV = this._sucs[v];
  if (sucsV) {
    return _2.keys(sucsV);
  }
};
Graph2.prototype.neighbors = function(v) {
  const preds = this.predecessors(v);
  if (preds) {
    return _2.union(preds, this.successors(v));
  }
};
Graph2.prototype.isLeaf = function(v) {
  let neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};
Graph2.prototype.filterNodes = function(filter3) {
  const copy4 = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy4.setGraph(this.graph());
  const self2 = this;
  _2.each(this._nodes, function(value, v) {
    if (filter3(v)) {
      copy4.setNode(v, value);
    }
  });
  _2.each(this._edgeObjs, function(e) {
    if (copy4.hasNode(e.v) && copy4.hasNode(e.w)) {
      copy4.setEdge(e, self2.edge(e));
    }
  });
  const parents = {};
  function findParent(v) {
    const parent = self2.parent(v);
    if (parent === void 0 || copy4.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }
  if (this._isCompound) {
    _2.each(copy4.nodes(), function(v) {
      copy4.setParent(v, findParent(v));
    });
  }
  return copy4;
};
Graph2.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_2.isFunction(newDefault)) {
    newDefault = _2.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};
Graph2.prototype.edgeCount = function() {
  return this._edgeCount;
};
Graph2.prototype.edges = function() {
  return _2.values(this._edgeObjs);
};
Graph2.prototype.setPath = function(vs, value) {
  const self2 = this;
  const args = arguments;
  _2.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self2.setEdge(v, w, value);
    } else {
      self2.setEdge(v, w);
    }
    return w;
  });
  return this;
};
Graph2.prototype.setEdge = function() {
  let v, w, name, value;
  let valueSpecified = false;
  const arg0 = arguments[0];
  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }
  v = "" + v;
  w = "" + w;
  if (!_2.isUndefined(name)) {
    name = "" + name;
  }
  const e = edgeArgsToId2(this._isDirected, v, w, name);
  if (_2.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }
  if (!_2.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }
  this.setNode(v);
  this.setNode(w);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
  const edgeObj = edgeArgsToObj2(this._isDirected, v, w, name);
  v = edgeObj.v;
  w = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry2(this._preds[w], v);
  incrementOrInitEntry2(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};
Graph2.prototype.edge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId2(this._isDirected, arguments[0]) : edgeArgsToId2(this._isDirected, v, w, name);
  return this._edgeLabels[e];
};
Graph2.prototype.hasEdge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId2(this._isDirected, arguments[0]) : edgeArgsToId2(this._isDirected, v, w, name);
  return _2.has(this._edgeLabels, e);
};
Graph2.prototype.removeEdge = function(v, w, name) {
  const e = arguments.length === 1 ? edgeObjToId2(this._isDirected, arguments[0]) : edgeArgsToId2(this._isDirected, v, w, name);
  const edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry2(this._preds[w], v);
    decrementOrRemoveEntry2(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};
Graph2.prototype.inEdges = function(v, u) {
  const inV = this._in[v];
  if (inV) {
    const edges = _2.values(inV);
    if (!u) {
      return edges;
    }
    return _2.filter(edges, function(edge) {
      return edge.v === u;
    });
  }
};
Graph2.prototype.outEdges = function(v, w) {
  const outV = this._out[v];
  if (outV) {
    const edges = _2.values(outV);
    if (!w) {
      return edges;
    }
    return _2.filter(edges, function(edge) {
      return edge.w === w;
    });
  }
};
Graph2.prototype.nodeEdges = function(v, w) {
  const inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};
function incrementOrInitEntry2(map4, k) {
  if (map4[k]) {
    map4[k]++;
  } else {
    map4[k] = 1;
  }
}
function decrementOrRemoveEntry2(map4, k) {
  if (!--map4[k]) {
    delete map4[k];
  }
}
function edgeArgsToId2(isDirected, v_, w_, name) {
  let v = "" + v_;
  let w = "" + w_;
  if (!isDirected && v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM2 + w + EDGE_KEY_DELIM2 + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME2 : name);
}
function edgeArgsToObj2(isDirected, v_, w_, name) {
  let v = "" + v_;
  let w = "" + w_;
  if (!isDirected && v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  const edgeObj = { v, w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId2(isDirected, edgeObj) {
  return edgeArgsToId2(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function components(g) {
  const visited = {};
  const cmpts = [];
  let cmpt;
  function dfs2(v) {
    if (_2.has(visited, v))
      return;
    visited[v] = true;
    cmpt.push(v);
    _2.each(g.successors(v), dfs2);
    _2.each(g.predecessors(v), dfs2);
  }
  _2.each(g.nodes(), function(v) {
    cmpt = [];
    dfs2(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });
  return cmpts;
}
function PriorityQueue2() {
  this._arr = [];
  this._keyIndices = {};
}
PriorityQueue2.prototype.size = function() {
  return this._arr.length;
};
PriorityQueue2.prototype.keys = function() {
  return this._arr.map(function(x2) {
    return x2.key;
  });
};
PriorityQueue2.prototype.has = function(key) {
  return _2.has(this._keyIndices, key);
};
PriorityQueue2.prototype.priority = function(key) {
  const index2 = this._keyIndices[key];
  if (index2 !== void 0) {
    return this._arr[index2].priority;
  }
};
PriorityQueue2.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};
PriorityQueue2.prototype.add = function(key, priority) {
  const keyIndices = this._keyIndices;
  key = String(key);
  if (!_2.has(keyIndices, key)) {
    const arr2 = this._arr;
    const index2 = arr2.length;
    keyIndices[key] = index2;
    arr2.push({ key, priority });
    this._decrease(index2);
    return true;
  }
  return false;
};
PriorityQueue2.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  const min4 = this._arr.pop();
  delete this._keyIndices[min4.key];
  this._heapify(0);
  return min4.key;
};
PriorityQueue2.prototype.decrease = function(key, priority) {
  const index2 = this._keyIndices[key];
  if (priority > this._arr[index2].priority) {
    throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
  }
  this._arr[index2].priority = priority;
  this._decrease(index2);
};
PriorityQueue2.prototype._heapify = function(i2) {
  const arr2 = this._arr;
  const l = 2 * i2;
  const r = l + 1;
  let largest = i2;
  if (l < arr2.length) {
    largest = arr2[l].priority < arr2[largest].priority ? l : largest;
    if (r < arr2.length) {
      largest = arr2[r].priority < arr2[largest].priority ? r : largest;
    }
    if (largest !== i2) {
      this._swap(i2, largest);
      this._heapify(largest);
    }
  }
};
PriorityQueue2.prototype._decrease = function(index2) {
  const arr2 = this._arr;
  const priority = arr2[index2].priority;
  let parent;
  while (index2 !== 0) {
    parent = index2 >> 1;
    if (arr2[parent].priority < priority) {
      break;
    }
    this._swap(index2, parent);
    index2 = parent;
  }
};
PriorityQueue2.prototype._swap = function(i2, j) {
  const arr2 = this._arr;
  const keyIndices = this._keyIndices;
  const origArrI = arr2[i2];
  const origArrJ = arr2[j];
  arr2[i2] = origArrJ;
  arr2[j] = origArrI;
  keyIndices[origArrJ.key] = i2;
  keyIndices[origArrI.key] = j;
};
var DEFAULT_WEIGHT_FUNC$12 = _2.constant(1);
function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(
    g,
    String(source),
    weightFn || DEFAULT_WEIGHT_FUNC$12,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runDijkstra(g, source, weightFn, edgeFn) {
  const results = {};
  const pq = new PriorityQueue2();
  let v, vEntry;
  const updateNeighbors = function(edge) {
    const w = edge.v !== v ? edge.v : edge.w;
    const wEntry = results[w];
    const weight = weightFn(edge);
    const distance3 = vEntry.distance + weight;
    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    }
    if (distance3 < wEntry.distance) {
      wEntry.distance = distance3;
      wEntry.predecessor = v;
      pq.decrease(w, distance3);
    }
  };
  g.nodes().forEach(function(v2) {
    const distance3 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
    results[v2] = { distance: distance3 };
    pq.add(v2, distance3);
  });
  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }
    edgeFn(v).forEach(updateNeighbors);
  }
  return results;
}
function dijkstraAll(g, weightFunc, edgeFunc) {
  return _2.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}
function tarjan(g) {
  let index2 = 0;
  const stack = [];
  const visited = {};
  const results = [];
  function dfs2(v) {
    const entry = visited[v] = {
      onStack: true,
      lowlink: index2,
      index: index2++
    };
    stack.push(v);
    g.successors(v).forEach(function(w) {
      if (!_2.has(visited, w)) {
        dfs2(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });
    if (entry.lowlink === entry.index) {
      const cmpt = [];
      let w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }
  g.nodes().forEach(function(v) {
    if (!_2.has(visited, v)) {
      dfs2(v);
    }
  });
  return results;
}
function findCycles(g) {
  return _2.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}
var DEFAULT_WEIGHT_FUNC2 = _2.constant(1);
function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(
    g,
    weightFn || DEFAULT_WEIGHT_FUNC2,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runFloydWarshall(g, weightFn, edgeFn) {
  const results = {};
  const nodes = g.nodes();
  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      const w = edge.v === v ? edge.w : edge.v;
      const d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });
  nodes.forEach(function(k) {
    const rowK = results[k];
    nodes.forEach(function(i2) {
      const rowI = results[i2];
      nodes.forEach(function(j) {
        const ik = rowI[k];
        const kj = rowK[j];
        const ij = rowI[j];
        const altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
topsort2.CycleException = CycleException2;
function topsort2(g) {
  const visited = {};
  const stack = {};
  const results = [];
  function visit(node2) {
    if (_2.has(stack, node2)) {
      throw new CycleException2();
    }
    if (!_2.has(visited, node2)) {
      stack[node2] = true;
      visited[node2] = true;
      _2.each(g.predecessors(node2), visit);
      delete stack[node2];
      results.push(node2);
    }
  }
  _2.each(g.sinks(), visit);
  if (_2.size(visited) !== g.nodeCount()) {
    throw new CycleException2();
  }
  return results;
}
function CycleException2() {
}
CycleException2.prototype = new Error();
function isAcyclic(g) {
  try {
    topsort2(g);
  } catch (e) {
    if (e instanceof topsort2.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}
function dfs$1(g, vs, order2) {
  if (!_2.isArray(vs)) {
    vs = [vs];
  }
  const navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
  const acc = [];
  const visited = {};
  _2.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }
    doDfs(g, v, order2 === "post", visited, navigation, acc);
  });
  return acc;
}
function doDfs(g, v, postorder2, visited, navigation, acc) {
  if (!_2.has(visited, v)) {
    visited[v] = true;
    if (!postorder2) {
      acc.push(v);
    }
    _2.each(navigation(v), function(w) {
      doDfs(g, w, postorder2, visited, navigation, acc);
    });
    if (postorder2) {
      acc.push(v);
    }
  }
}
function postorder$2(g, vs) {
  return dfs$1(g, vs, "post");
}
function preorder$1(g, vs) {
  return dfs$1(g, vs, "pre");
}
function prim(g, weightFunc) {
  const result = new Graph2();
  const parents = {};
  const pq = new PriorityQueue2();
  let v;
  function updateNeighbors(edge) {
    const w = edge.v === v ? edge.w : edge.v;
    const pri = pq.priority(w);
    if (pri !== void 0) {
      const edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }
  if (g.nodeCount() === 0) {
    return result;
  }
  _2.each(g.nodes(), function(v2) {
    pq.add(v2, Number.POSITIVE_INFINITY);
    result.setNode(v2);
  });
  pq.decrease(g.nodes()[0], 0);
  let init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_2.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }
    g.nodeEdges(v).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components,
  dijkstra,
  dijkstraAll,
  findCycles,
  floydWarshall,
  isAcyclic,
  postorder: postorder$2,
  preorder: preorder$1,
  prim,
  tarjan,
  topsort: topsort2
};
function List() {
  const sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}
List.prototype.dequeue = function() {
  const sentinel = this._sentinel;
  const entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};
List.prototype.enqueue = function(entry) {
  const sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};
List.prototype.toString = function() {
  const strs = [];
  const sentinel = this._sentinel;
  let curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}
var DEFAULT_WEIGHT_FN = (e) => 1;
function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return flatten(map$1(results, function(e) {
    return g.outEdges(e.v, e.w);
  }));
}
function doGreedyFAS(g, buckets, zeroIdx) {
  let results = [];
  const sources = buckets[buckets.length - 1];
  const sinks = buckets[0];
  let entry;
  while (g.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    if (g.nodeCount()) {
      for (let i2 = buckets.length - 2; i2 > 0; --i2) {
        entry = buckets[i2].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g, buckets, zeroIdx, entry, collectPredecessors = false) {
  const results = collectPredecessors ? [] : void 0;
  forEach$1(g.inEdges(entry.v), function(edge) {
    const weight = g.edge(edge);
    const uEntry = g.node(edge.v);
    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  forEach$1(g.outEdges(entry.v), function(edge) {
    const weight = g.edge(edge);
    const w = edge.w;
    const wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g.removeNode(entry.v);
  return results;
}
function buildState(g, weightFn) {
  const fasGraph = new Graph2();
  let maxIn = 0;
  let maxOut = 0;
  forEach$1(g.nodes(), function(v) {
    fasGraph.setNode(v, { v, in: 0, out: 0 });
  });
  forEach$1(g.edges(), function(e) {
    const prevWeight = fasGraph.edge(e.v, e.w) || 0;
    const weight = weightFn(e);
    const edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
  });
  const buckets = range$1(maxOut + maxIn + 3).map(function() {
    return new List();
  });
  const zeroIdx = maxIn + 1;
  forEach$1(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });
  return { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
function run$2(g) {
  const fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
  forEach$1(fas, function(e) {
    const label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, uniqueId("rev"));
  });
  function weightFn(g2) {
    return function(e) {
      return g2.edge(e).weight;
    };
  }
}
function dfsFAS(g) {
  const fas = [];
  const stack = {};
  const visited = {};
  function dfs2(v) {
    if (has$1(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    forEach$1(g.outEdges(v), function(e) {
      if (has$1(stack, e.w)) {
        fas.push(e);
      } else {
        dfs2(e.w);
      }
    });
    delete stack[v];
  }
  forEach$1(g.nodes(), dfs2);
  return fas;
}
function undo$2(g) {
  forEach$1(g.edges(), function(e) {
    const label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);
      const forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}
var acyclic = {
  run: run$2,
  undo: undo$2
};
function addDummyNode(g, type, attrs, name) {
  let v;
  do {
    v = uniqueId(name);
  } while (g.hasNode(v));
  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}
function simplify(g) {
  const simplified = new Graph2().setGraph(g.graph());
  forEach$1(g.nodes(), function(v) {
    simplified.setNode(v, g.node(v));
  });
  forEach$1(g.edges(), function(e) {
    const simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    const label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g) {
  const simplified = new Graph2({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  forEach$1(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  forEach$1(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}
function successorWeights(g) {
  const weightMap = map$1(g.nodes(), function(v) {
    const sucs = {};
    forEach$1(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return zipObject(g.nodes(), weightMap);
}
function predecessorWeights(g) {
  const weightMap = map$1(g.nodes(), function(v) {
    const preds = {};
    forEach$1(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return zipObject(g.nodes(), weightMap);
}
function intersectRect(rect, point2) {
  const x2 = rect.x;
  const y2 = rect.y;
  const dx = point2.x - x2;
  const dy = point2.y - y2;
  let w = rect.width / 2;
  let h = rect.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  let sx;
  let sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g) {
  const layering = map$1(range$1(maxRank(g) + 1), function() {
    return [];
  });
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    const rank2 = node2.rank;
    if (!isUndefined$1(rank2) && typeof node2.order === "number") {
      layering[rank2][node2.order] = v;
    }
  });
  return layering;
}
function normalizeRanks(g) {
  const min$1 = min3(map$1(g.nodes(), function(v) {
    return g.node(v).rank;
  }));
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    if (has$1(node2, "rank")) {
      node2.rank -= min$1;
    }
  });
}
function removeEmptyRanks(g) {
  const offset = min3(map$1(g.nodes(), function(v) {
    return g.node(v).rank;
  }));
  const layers = [];
  forEach$1(g.nodes(), function(v) {
    const rank2 = g.node(v).rank - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v);
  });
  let delta = 0;
  const nodeRankFactor = g.graph().nodeRankFactor;
  forEach$1(layers, function(vs, i2) {
    if (isUndefined$1(vs) && i2 % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      forEach$1(vs, function(v) {
        g.node(v).rank += delta;
      });
    }
  });
}
function addBorderNode$1(g, prefix, rank2, order2) {
  const node2 = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node2.rank = rank2;
    node2.order = order2;
  }
  return addDummyNode(g, "border", node2, prefix);
}
function maxRank(g) {
  return max3(map$1(g.nodes(), function(v) {
    const rank2 = g.node(v).rank;
    if (!isUndefined$1(rank2)) {
      return rank2;
    }
  }));
}
function partition(collection, fn) {
  const result = { lhs: [], rhs: [] };
  forEach$1(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time(name, fn) {
  const start = Date.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (Date.now() - start) + "ms");
  }
}
function notime(name, fn) {
  return fn();
}
function comparePositions(p1, p2) {
  const isXEqual = p1.x === p2.x;
  const isYEqual = p1.y === p2.y;
  const leftOne = p2.x < p1.x ? p2 : p1;
  const topOne = p2.y < p1.y ? p2 : p1;
  const rightOne = p1 === leftOne ? p2 : p1;
  const bottomOne = p1 === topOne ? p2 : p1;
  const dx = rightOne.x - leftOne.x;
  const dy = bottomOne.y - topOne.y;
  return {
    isXEqual,
    isYEqual,
    leftOne,
    rightOne,
    topOne,
    bottomOne,
    dx,
    dy
  };
}
function isInsideRange(v, range2) {
  const [start, end] = range2;
  if (v >= start && v <= end)
    return true;
  return false;
}
function getNum(v, defaultValue = 0) {
  return v || defaultValue;
}
function isNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
var util2 = {
  addDummyNode,
  simplify,
  asNonCompoundGraph,
  successorWeights,
  predecessorWeights,
  intersectRect,
  buildLayerMatrix,
  normalizeRanks,
  removeEmptyRanks,
  addBorderNode: addBorderNode$1,
  maxRank,
  partition,
  time,
  notime
};
function run$1(g) {
  g.graph().dummyChains = [];
  forEach$1(g.edges(), function(edge) {
    normalizeEdge(g, edge);
  });
}
function normalizeEdge(g, e) {
  let v = e.v;
  let vRank = g.node(v).rank;
  const w = e.w;
  const wRank = g.node(w).rank;
  const name = e.name;
  const edgeLabel = g.edge(e);
  const labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1)
    return;
  g.removeEdge(e);
  let dummy;
  let attrs;
  let i2;
  for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e,
      rank: vRank
    };
    dummy = util2.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i2 === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }
  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}
function undo$1(g) {
  forEach$1(g.graph().dummyChains, function(v) {
    let node2 = g.node(v);
    const origLabel = node2.edgeLabel;
    let w = null;
    g.setEdge(node2.edgeObj, origLabel);
    while (node2.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node2.x, y: node2.y });
      if (node2.dummy === "edge-label") {
        origLabel.x = node2.x;
        origLabel.y = node2.y;
        origLabel.width = node2.width;
        origLabel.height = node2.height;
      }
      v = w;
      node2 = g.node(v);
    }
  });
}
var normalize2 = {
  run: run$1,
  undo: undo$1
};
function longestPath(g) {
  const visited = {};
  function dfs2(v) {
    const label = g.node(v);
    if (has$1(visited, v)) {
      return label.rank;
    }
    visited[v] = true;
    const rank2 = min3(map$1(g.outEdges(v), function(e) {
      return dfs2(e.w) - g.edge(e).minlen;
    })) || 0;
    label.rank = rank2;
    return rank2;
  }
  forEach$1(g.sources(), dfs2);
}
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}
function feasibleTree(g) {
  const t = new Graph2({ directed: false });
  const start = g.nodes()[0];
  const size4 = g.nodeCount();
  t.setNode(start, {});
  let edge;
  let delta;
  while (tightTree(t, g) < size4) {
    edge = findMinSlackEdge(t, g);
    if (!edge)
      break;
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }
  return t;
}
function tightTree(t, g) {
  function dfs2(v) {
    forEach$1(g.nodeEdges(v), function(e) {
      const edgeV = e.v;
      const w = v === edgeV ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs2(w);
      }
    });
  }
  forEach$1(t.nodes(), dfs2);
  return t.nodeCount();
}
function findMinSlackEdge(t, g) {
  return minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack(g, e);
    }
  });
}
function shiftRanks(t, g, delta) {
  forEach$1(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}
var { preorder, postorder: postorder$1 } = alg;
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;
function networkSimplex(g) {
  g = simplify(g);
  longestPath(g);
  const t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);
  let e;
  let f;
  while (e = leaveEdge(t)) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}
function initCutValues(t, g) {
  let vs = postorder$1(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  forEach$1(vs, function(v) {
    assignCutValue(t, g, v);
  });
}
function assignCutValue(t, g, child) {
  const childLab = t.node(child);
  const parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}
function calcCutValue(t, g, child) {
  const childLab = t.node(child);
  const parent = childLab.parent;
  let childIsTail = true;
  let graphEdge = g.edge(child, parent);
  let cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  forEach$1(g.nodeEdges(child), function(e) {
    const isOutEdge = e.v === child;
    const other = isOutEdge ? e.w : e.v;
    if (other !== parent) {
      const pointsToHead = isOutEdge === childIsTail;
      const otherWeight = g.edge(e).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        const otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree, root3) {
  if (arguments.length < 2) {
    root3 = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root3);
}
function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  const low = nextLim;
  const label = tree.node(v);
  visited[v] = true;
  forEach$1(tree.neighbors(v), function(w) {
    if (!has$1(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree) {
  return find$1(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}
function enterEdge(t, g, edge) {
  let v = edge.v;
  let w = edge.w;
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }
  const vLabel = t.node(v);
  const wLabel = t.node(w);
  let tailLabel = vLabel;
  let flip = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  const candidates = filter$1(g.edges(), function(edge2) {
    return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
  });
  return minBy(candidates, function(edge2) {
    return slack(g, edge2);
  });
}
function exchangeEdges(t, g, e, f) {
  const v = e.v;
  const w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}
function updateRanks(t, g) {
  const root3 = find$1(t.nodes(), function(v) {
    return !g.node(v).parent;
  });
  let vs = preorder(t, root3);
  vs = vs.slice(1);
  forEach$1(vs, function(v) {
    const parent = t.node(v).parent;
    let edge = g.edge(v, parent);
    let flipped = false;
    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }
    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
function rank(g) {
  switch (g.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g);
      break;
    case "tight-tree":
      tightTreeRanker(g);
      break;
    case "longest-path":
      longestPathRanker(g);
      break;
    default:
      networkSimplexRanker(g);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}
function networkSimplexRanker(g) {
  networkSimplex(g);
}
function parentDummyChains(g) {
  const postorderNums = postorder(g);
  forEach$1(g.graph().dummyChains, function(v) {
    let node2 = g.node(v);
    const edgeObj = node2.edgeObj;
    const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    const path4 = pathData.path;
    const lca = pathData.lca;
    let pathIdx = 0;
    let pathV = path4[pathIdx];
    let ascending2 = true;
    while (v !== edgeObj.w) {
      node2 = g.node(v);
      if (ascending2) {
        while ((pathV = path4[pathIdx]) !== lca && g.node(pathV).maxRank < node2.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending2 = false;
        }
      }
      if (!ascending2) {
        while (pathIdx < path4.length - 1 && g.node(pathV = path4[pathIdx + 1]).minRank <= node2.rank) {
          pathIdx++;
        }
        pathV = path4[pathIdx];
      }
      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}
function findPath(g, postorderNums, v, w) {
  const vPath = [];
  const wPath = [];
  const low = Math.min(postorderNums[v].low, postorderNums[w].low);
  const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  let parent;
  let lca;
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g) {
  const result = {};
  let lim = 0;
  function dfs2(v) {
    const low = lim;
    forEach$1(g.children(v), dfs2);
    result[v] = { low, lim: lim++ };
  }
  forEach$1(g.children(), dfs2);
  return result;
}
function run(g) {
  const root3 = util2.addDummyNode(g, "root", {}, "_root");
  const depths = treeDepths(g);
  const height = Math.max.apply(null, values$1(depths)) - 1;
  const nodeSep = 2 * height + 1;
  g.graph().nestingRoot = root3;
  forEach$1(g.edges(), function(e) {
    g.edge(e).minlen *= nodeSep;
  });
  const weight = sumWeights(g) + 1;
  forEach$1(g.children(), function(child) {
    dfs(g, root3, nodeSep, weight, height, depths, child);
  });
  g.graph().nodeRankFactor = nodeSep;
}
function dfs(g, root3, nodeSep, weight, height, depths, v) {
  const children = g.children(v);
  if (!children.length) {
    if (v !== root3) {
      g.setEdge(root3, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }
  const top = util2.addBorderNode(g, "_bt");
  const bottom = util2.addBorderNode(g, "_bb");
  const label = g.node(v);
  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;
  forEach$1(children, function(child) {
    dfs(g, root3, nodeSep, weight, height, depths, child);
    const childNode = g.node(child);
    const childTop = childNode.borderTop ? childNode.borderTop : child;
    const childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    const thisWeight = childNode.borderTop ? weight : 2 * weight;
    const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g.parent(v)) {
    g.setEdge(root3, top, { weight: 0, minlen: height + depths[v] });
  }
}
function treeDepths(g) {
  const depths = {};
  function dfs2(v, depth) {
    const children = g.children(v);
    if (children && children.length) {
      forEach$1(children, function(child) {
        dfs2(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  forEach$1(g.children(), function(v) {
    dfs2(v, 1);
  });
  return depths;
}
function sumWeights(g) {
  return reduce$1(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}
function cleanup(g) {
  const graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}
var nestingGraph = {
  run,
  cleanup
};
function addBorderSegments(g) {
  function dfs2(v) {
    const children = g.children(v);
    const node2 = g.node(v);
    if (children.length) {
      forEach$1(children, dfs2);
    }
    if (has$1(node2, "minRank")) {
      node2.borderLeft = [];
      node2.borderRight = [];
      for (let rank2 = node2.minRank, maxRank2 = node2.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode(g, "borderLeft", "_bl", v, node2, rank2);
        addBorderNode(g, "borderRight", "_br", v, node2, rank2);
      }
    }
  }
  forEach$1(g.children(), dfs2);
}
function addBorderNode(g, prop, prefix, sg, sgNode, rank2) {
  const label = { width: 0, height: 0, rank: rank2, borderType: prop };
  const prev = sgNode[prop][rank2 - 1];
  const curr = util2.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank2] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}
function adjust(g) {
  const rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}
function undo(g) {
  const rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}
function swapWidthHeight(g) {
  forEach$1(g.nodes(), function(v) {
    swapWidthHeightOne(g.node(v));
  });
  forEach$1(g.edges(), function(e) {
    swapWidthHeightOne(g.edge(e));
  });
}
function swapWidthHeightOne(attrs) {
  const w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}
function reverseY(g) {
  forEach$1(g.nodes(), function(v) {
    reverseYOne(g.node(v));
  });
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    forEach$1(edge.points, reverseYOne);
    if (has$1(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g) {
  forEach$1(g.nodes(), function(v) {
    swapXYOne(g.node(v));
  });
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    forEach$1(edge.points, swapXYOne);
    if (has$1(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  const x2 = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x2;
}
var coordinateSystem = {
  adjust,
  undo
};
function initOrder(g) {
  const visited = {};
  const simpleNodes = filter$1(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  const maxRank2 = max3(map$1(simpleNodes, function(v) {
    return g.node(v).rank;
  }));
  const layers = map$1(range$1(maxRank2 + 1), function() {
    return [];
  });
  function dfs2(v) {
    if (has$1(visited, v))
      return;
    visited[v] = true;
    const node2 = g.node(v);
    layers[node2.rank].push(v);
    forEach$1(g.successors(v).filter((n2) => {
      return !g.children(n2).length;
    }), dfs2);
  }
  const orderedVs = sortBy$1(simpleNodes, function(v) {
    return g.node(v).rank;
  });
  forEach$1(orderedVs, dfs2);
  return layers;
}
function crossCount(g, layering) {
  let cc = 0;
  for (let i2 = 1; i2 < layering.length; ++i2) {
    cc += twoLayerCrossCount(g, layering[i2 - 1], layering[i2]);
  }
  return cc;
}
function twoLayerCrossCount(g, northLayer, southLayer) {
  const southPos = zipObject(southLayer, southLayer.map(function(v, i2) {
    return i2;
  }));
  const southEntries = flatten(map$1(northLayer, function(v) {
    const list = (g.outEdges(v) || []).map(function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    });
    return sortBy$1(list, "pos");
  }));
  let firstIndex = 1;
  while (firstIndex < southLayer.length) {
    firstIndex <<= 1;
  }
  const treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  const tree = map$1(new Array(treeSize), function() {
    return 0;
  });
  let cc = 0;
  southEntries.forEach(function(entry) {
    let index2 = entry.pos + firstIndex;
    tree[index2] += entry.weight;
    let weightSum = 0;
    while (index2 > 0) {
      if (index2 % 2) {
        weightSum += tree[index2 + 1];
      }
      index2 = index2 - 1 >> 1;
      tree[index2] += entry.weight;
    }
    cc += entry.weight * weightSum;
  });
  return cc;
}
function barycenter(g, movable) {
  return map$1(movable, function(v) {
    const inV = g.inEdges(v);
    if (!inV.length) {
      return { v };
    } else {
      const result = reduce$1(inV, function(acc, e) {
        const edge = g.edge(e);
        const nodeU = g.node(e.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}
function resolveConflicts(entries, cg) {
  const mappedEntries = {};
  forEach$1(entries, function(entry, i2) {
    const tmp = mappedEntries[entry.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [entry.v],
      i: i2
    };
    if (!isUndefined$1(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  forEach$1(cg.edges(), function(e) {
    const entryV = mappedEntries[e.v];
    const entryW = mappedEntries[e.w];
    if (!isUndefined$1(entryV) && !isUndefined$1(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });
  const sourceSet = filter$1(mappedEntries, function(entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  const entries = [];
  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (isUndefined$1(uEntry.barycenter) || isUndefined$1(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    const entry = sourceSet.pop();
    entries.push(entry);
    forEach$1(entry["in"].reverse(), handleIn(entry));
    forEach$1(entry.out, handleOut(entry));
  }
  return entries.filter(function(entry) {
    return !entry.merged;
  }).map(function(entry) {
    return pick$1(entry, ["vs", "i", "barycenter", "weight"]);
  });
}
function mergeEntries(target, source) {
  let sum = 0;
  let weight = 0;
  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}
function sort(entries, biasRight) {
  const parts = util2.partition(entries, function(entry) {
    return has$1(entry, "barycenter");
  });
  const sortable = parts.lhs;
  const unsortable = sortBy$1(parts.rhs, function(entry) {
    return -entry.i;
  });
  const vs = [];
  let sum = 0;
  let weight = 0;
  let vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  forEach$1(sortable, function(entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  const result = { vs: flatten(vs) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index2) {
  let last$1;
  while (unsortable.length && (last$1 = last2(unsortable)).i <= index2) {
    unsortable.pop();
    vs.push(last$1.vs);
    index2++;
  }
  return index2;
}
function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}
function sortSubgraph(g, v, cg, biasRight) {
  let movable = g.children(v);
  const node2 = g.node(v);
  const bl = node2 ? node2.borderLeft : void 0;
  const br = node2 ? node2.borderRight : void 0;
  const subgraphs = {};
  if (bl) {
    movable = filter$1(movable, function(w) {
      return w !== bl && w !== br;
    });
  }
  const barycenters = barycenter(g, movable);
  forEach$1(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (has$1(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  const entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);
  const result = sort(entries, biasRight);
  if (bl) {
    result.vs = flatten([bl, result.vs, br]);
    if (g.predecessors(bl).length) {
      const blPred = g.node(g.predecessors(bl)[0]);
      const brPred = g.node(g.predecessors(br)[0]);
      if (!has$1(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries, subgraphs) {
  forEach$1(entries, function(entry) {
    entry.vs = flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }));
  });
}
function mergeBarycenters(target, other) {
  if (!isUndefined$1(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}
function buildLayerGraph(g, rank2, relationship) {
  const root3 = createRootNode(g);
  const result = new Graph2({ compound: true }).setGraph({ root: root3 }).setDefaultNodeLabel(function(v) {
    return g.node(v);
  });
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    const parent = g.parent(v);
    if (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root3);
      forEach$1(g[relationship](v), function(e) {
        const u = e.v === v ? e.w : e.v;
        const edge = result.edge(u, v);
        const weight = !isUndefined$1(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });
      if (has$1(node2, "minRank")) {
        result.setNode(v, {
          borderLeft: node2.borderLeft[rank2],
          borderRight: node2.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g) {
  let v;
  while (g.hasNode(v = uniqueId("_root")))
    ;
  return v;
}
function addSubgraphConstraints(g, cg, vs) {
  const prev = {};
  let rootPrev;
  forEach$1(vs, function(v) {
    let child = g.parent(v);
    let parent;
    let prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
function order(g) {
  const maxRank2 = util2.maxRank(g);
  const downLayerGraphs = buildLayerGraphs(g, range$1(1, maxRank2 + 1), "inEdges");
  const upLayerGraphs = buildLayerGraphs(g, range$1(maxRank2 - 1, -1, -1), "outEdges");
  let layering = initOrder(g);
  assignOrder(g, layering);
  let bestCC = Number.POSITIVE_INFINITY;
  let best;
  for (let i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
    sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2);
    layering = util2.buildLayerMatrix(g);
    const cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = cloneDeep2(layering);
      bestCC = cc;
    }
  }
  assignOrder(g, best);
}
function buildLayerGraphs(g, ranks, relationship) {
  return map$1(ranks, function(rank2) {
    return buildLayerGraph(g, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  const cg = new Graph2();
  forEach$1(layerGraphs, function(lg) {
    const root3 = lg.graph().root;
    const sorted = sortSubgraph(lg, root3, cg, biasRight);
    forEach$1(sorted.vs, function(v, i2) {
      lg.node(v).order = i2;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g, layering) {
  layering.forEach(function(layer) {
    forEach$1(layer, function(v, i2) {
      if (v) {
        g.node(v).order = i2;
      }
    });
  });
}
function findType1Conflicts(g, layering) {
  const conflicts = {};
  function visitLayer(prevLayer, layer) {
    let k0 = 0;
    let scanPos = 0;
    const prevLayerLength = prevLayer.length;
    const lastNode = last2(layer);
    forEach$1(layer, function(v, i2) {
      if (!v)
        return;
      const w = findOtherInnerSegmentNode(g, v);
      const k1 = w ? g.node(w).order : prevLayerLength;
      if (w || v === lastNode) {
        forEach$1(layer.slice(scanPos, i2 + 1), function(scanNode) {
          forEach$1(g.predecessors(scanNode), function(u) {
            const uLabel = g.node(u);
            const uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i2 + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  reduce$1(layering, visitLayer);
  return conflicts;
}
function findType2Conflicts(g, layering) {
  const conflicts = {};
  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    let v;
    forEach$1(range$1(southPos, southEnd), function(i2) {
      v = south[i2];
      if (!v)
        return;
      if (g.node(v).dummy) {
        forEach$1(g.predecessors(v), function(u) {
          const uNode = g.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    let prevNorthPos = -1;
    let nextNorthPos;
    let southPos = 0;
    forEach$1(south, function(v, southLookahead) {
      if (!v)
        return;
      if (g.node(v).dummy === "border") {
        const predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  reduce$1(layering, visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return find$1(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}
function addConflict(conflicts, v, w) {
  if (v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  let conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}
function hasConflict(conflicts, v, w) {
  if (v > w) {
    const tmp = v;
    v = w;
    w = tmp;
  }
  return has$1(conflicts[v], w);
}
function verticalAlignment(g, layering, conflicts, neighborFn) {
  const root3 = {};
  const align = {};
  const pos = {};
  forEach$1(layering, function(layer) {
    forEach$1(layer, function(v, order2) {
      root3[v] = v;
      align[v] = v;
      pos[v] = order2;
    });
  });
  forEach$1(layering, function(layer) {
    let prevIdx = -1;
    forEach$1(layer, function(v) {
      if (!v)
        return;
      let ws = neighborFn(v);
      if (ws.length) {
        ws = sortBy$1(ws, function(w) {
          return pos[w];
        });
        const mp = (ws.length - 1) / 2;
        for (let i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
          const w = ws[i2];
          if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root3[v] = root3[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });
  return { root: root3, align };
}
function horizontalCompaction(g, layering, root3, alignMap, reverseSep) {
  const xs = {};
  const blockG = buildBlockGraph(g, layering, root3, reverseSep);
  const visited = {};
  function pass1(v) {
    if (!has$1(visited, v)) {
      visited[v] = true;
      xs[v] = reduce$1(blockG.inEdges(v) || [], function(max4, e) {
        pass1(e.v);
        return Math.max(max4, xs[e.v] + blockG.edge(e));
      }, 0);
    }
  }
  forEach$1(blockG.nodes(), pass1);
  const borderType = reverseSep ? "borderLeft" : "borderRight";
  function pass2(v) {
    if (visited[v] !== 2) {
      visited[v]++;
      const node2 = g.node(v);
      const min4 = reduce$1(blockG.outEdges(v) || [], (min5, e) => {
        pass2(e.w);
        return Math.min(min5, xs[e.w] - blockG.edge(e));
      }, Number.POSITIVE_INFINITY);
      if (min4 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType) {
        xs[v] = Math.max(xs[v], min4);
      }
    }
  }
  forEach$1(blockG.nodes(), pass2);
  forEach$1(alignMap, function(v) {
    xs[v] = xs[root3[v]];
  });
  return xs;
}
function buildBlockGraph(g, layering, root3, reverseSep) {
  const blockGraph = new Graph2();
  const graphLabel = g.graph();
  const sepFn = makeSepFn(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  forEach$1(layering, function(layer) {
    let u;
    forEach$1(layer, function(v) {
      const vRoot = root3[v];
      blockGraph.setNode(vRoot);
      if (u) {
        const uRoot = root3[u];
        const prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g, xss) {
  return minBy(values$1(xss), function(xs) {
    const min4 = (minBy(toPairs$1(xs), (pair) => pair[1] - width(g, pair[0]) / 2) || ["k", 0])[1];
    const max4 = (maxBy(toPairs$1(xs), (pair) => pair[1] + width(g, pair[0]) / 2) || ["k", 0])[1];
    return max4 - min4;
  });
}
function alignCoordinates(xss, alignTo) {
  const alignToVals = values$1(alignTo);
  const alignToMin = min3(alignToVals);
  const alignToMax = max3(alignToVals);
  forEach$1(["u", "d"], function(vert) {
    forEach$1(["l", "r"], function(horiz) {
      const alignment = vert + horiz;
      const xs = xss[alignment];
      if (xs === alignTo) {
        return;
      }
      const xsVals = values$1(xs);
      const delta = horiz === "l" ? alignToMin - min3(xsVals) : alignToMax - max3(xsVals);
      if (delta) {
        xss[alignment] = mapValues(xs, function(x2) {
          return x2 + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      const xs = sortBy$1(map$1(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX(g) {
  const layering = util2.buildLayerMatrix(g);
  const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
  const xss = {};
  let adjustedLayering;
  forEach$1(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : values$1(layering).reverse();
    forEach$1(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = map$1(adjustedLayering, function(inner) {
          return values$1(inner).reverse();
        });
      }
      const neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      const verticalAlign = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      let xs = horizontalCompaction(g, adjustedLayering, verticalAlign.root, verticalAlign.align, horiz === "r");
      if (horiz === "r") {
        xs = mapValues(xs, function(x2) {
          return -x2;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  const smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}
function makeSepFn(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    const vLabel = g.node(v);
    const wLabel = g.node(w);
    if (!(vLabel && wLabel))
      return 0;
    let sum = 0;
    let delta;
    sum += vLabel.marginr || 0;
    sum += getNodeWidth(vLabel) / 2;
    if (has$1(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -getNodeWidth(vLabel) / 2;
          break;
        case "r":
          delta = getNodeWidth(vLabel) / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += wLabel.marginl || 0;
    sum += getNodeWidth(wLabel) / 2;
    if (has$1(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = getNodeWidth(wLabel) / 2;
          break;
        case "r":
          delta = -getNodeWidth(wLabel) / 2;
          break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum;
  };
}
function getNodeWidth(node2) {
  if (!node2)
    return 0;
  return Math.max(node2.minwidth || 0, node2.width);
}
function width(g, v) {
  const node2 = g.node(v);
  return getNodeWidth(node2);
}
function position(g) {
  doPositionY(g);
  forEach$1(positionX(g), function(x2, v) {
    const node2 = g.node(v);
    if (node2)
      node2.x = x2;
  });
}
function doPositionY(g) {
  const layering = util2.buildLayerMatrix(g);
  const rankSep = g.graph().ranksep;
  let prevY = 0;
  const rankOffsets = {};
  g.nodes().forEach((v) => {
    const node2 = g.node(v);
    const rank2 = isNumber(node2.minRank) ? node2.minRank : node2.rank;
    if (!rankOffsets[rank2]) {
      rankOffsets[rank2] = {
        marginTop: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0
      };
    }
    const item = rankOffsets[rank2];
    item.marginTop = Math.max(getNum(node2.margint), item.marginTop);
    item.marginBottom = Math.max(getNum(node2.marginb), item.marginBottom);
    item.paddingTop = Math.max(getNum(node2.paddingt), item.paddingTop);
    item.paddingBottom = Math.max(getNum(node2.paddingb), item.paddingBottom);
  });
  forEach$1(layering, function(layer, i2) {
    let yOffsetMarginT = 0;
    let yOffsetMarginB = 0;
    let yOffsetPaddingT = 0;
    let yOffsetPaddingB = 0;
    let maxHeight = 0;
    for (const v of layer) {
      if (v) {
        const node2 = g.node(v);
        if (rankOffsets[node2.rank]) {
          const item = rankOffsets[node2.rank];
          yOffsetMarginT = Math.max(item.marginTop, yOffsetMarginT);
          yOffsetMarginB = Math.max(item.marginBottom, yOffsetMarginB);
          yOffsetPaddingT = Math.max(item.paddingTop, yOffsetPaddingT);
          yOffsetPaddingB = Math.max(item.paddingBottom, yOffsetPaddingB);
        }
        maxHeight = Math.max(maxHeight, node2.height + getNum(node2.margint) + getNum(node2.marginb) + getNum(node2.paddingt) + getNum(node2.paddingb));
      }
    }
    for (const v of layer) {
      if (v)
        g.node(v).y = prevY + yOffsetMarginT + maxHeight / 2;
    }
    prevY += maxHeight + rankSep + yOffsetMarginT + yOffsetMarginB + yOffsetPaddingT + yOffsetPaddingB;
  });
}
function layout(g, opts) {
  const time3 = opts && opts.debugTiming ? util2.time : util2.notime;
  time3("layout", function() {
    const layoutGraph = time3("  buildLayoutGraph", function() {
      return buildLayoutGraph(g);
    });
    time3("  runLayout", function() {
      runLayout(layoutGraph, time3);
    });
    time3("  updateInputGraph", function() {
      updateInputGraph(g, layoutGraph);
    });
  });
}
function runLayout(g, time3) {
  time3("    makeSpaceForEdgeLabels", function() {
    makeSpaceForEdgeLabels(g);
  });
  time3("    removeSelfEdges", function() {
    removeSelfEdges(g);
  });
  time3("    acyclic", function() {
    acyclic.run(g);
  });
  time3("    nestingGraph.run", function() {
    nestingGraph.run(g);
  });
  time3("    rank", function() {
    rank(g);
  });
  time3("    injectEdgeLabelProxies", function() {
    injectEdgeLabelProxies(g);
  });
  time3("    removeEmptyRanks", function() {
    removeEmptyRanks(g);
  });
  time3("    nestingGraph.cleanup", function() {
    nestingGraph.cleanup(g);
  });
  time3("    normalizeRanks", function() {
    normalizeRanks(g);
  });
  time3("    assignRankMinMax", function() {
    assignRankMinMax(g);
  });
  time3("    removeEdgeLabelProxies", function() {
    removeEdgeLabelProxies(g);
  });
  time3("    normalize.run", function() {
    normalize2.run(g);
  });
  time3("    parentDummyChains", function() {
    parentDummyChains(g);
  });
  time3("    addBorderSegments", function() {
    addBorderSegments(g);
  });
  time3("    order", function() {
    order(g);
  });
  time3("    insertSelfEdges", function() {
    insertSelfEdges(g);
  });
  time3("    adjustCoordinateSystem", function() {
    coordinateSystem.adjust(g);
  });
  time3("    position", function() {
    position(g);
  });
  time3("    positionSelfEdges", function() {
    positionSelfEdges(g);
  });
  time3("    removeBorderNodes", function() {
    removeBorderNodes(g);
  });
  time3("    normalize.undo", function() {
    normalize2.undo(g);
  });
  time3("    fixupEdgeLabelCoords", function() {
    fixupEdgeLabelCoords(g);
  });
  time3("    undoCoordinateSystem", function() {
    coordinateSystem.undo(g);
  });
  time3("    translateGraph", function() {
    translateGraph(g);
  });
  time3("    assignNodeIntersects", function() {
    assignNodeIntersects(g);
  });
  time3("    reversePoints", function() {
    reversePointsForReversedEdges(g);
  });
  time3("    acyclic.undo", function() {
    acyclic.undo(g);
  });
}
function updateInputGraph(inputGraph, layoutGraph) {
  forEach$1(inputGraph.nodes(), function(v) {
    const inputLabel = inputGraph.node(v);
    const layoutLabel = layoutGraph.node(v);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  forEach$1(inputGraph.edges(), function(e) {
    const inputLabel = inputGraph.edge(e);
    const layoutLabel = layoutGraph.edge(e);
    inputLabel.points = layoutLabel.points;
    inputLabel.labelPoint = layoutLabel.labelPoint;
    if (has$1(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = [
  "nodesep",
  "edgesep",
  "ranksep",
  "marginx",
  "marginy"
];
var graphDefaults = {
  ranksep: 50,
  edgesep: 20,
  nodesep: 50,
  rankdir: "tb",
  splines: "polyline",
  avoid_label_on_border: false
};
var graphAttrs = [
  "acyclicer",
  "ranker",
  "rankdir",
  "align",
  "splines",
  "avoid_label_on_border"
];
var nodeNumAttrs = [
  "width",
  "height",
  "marginl",
  "marginr",
  "margint",
  "marginb",
  "paddingt",
  "paddingb",
  "minwidth"
];
var nodeDefaults = {
  width: 0,
  height: 0,
  marginl: 0,
  marginr: 0,
  margint: 0,
  marginb: 0
};
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  const g = new Graph2({
    multigraph: true,
    compound: true
  });
  const graph = canonicalize(inputGraph.graph());
  g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pick$1(graph, graphAttrs), {
    borderRanks: /* @__PURE__ */ new Set()
  }));
  forEach$1(inputGraph.nodes(), function(v) {
    const node2 = canonicalize(inputGraph.node(v));
    g.setNode(v, defaults$1(selectNumberAttrs(node2, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });
  forEach$1(inputGraph.edges(), function(e) {
    const edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pick$1(edge, edgeAttrs)));
  });
  return g;
}
function makeSpaceForEdgeLabels(g) {
  const graph = g.graph();
  graph.ranksep /= 2;
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g) {
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    if (edge.width && edge.height) {
      const v = g.node(e.v);
      const w = g.node(e.w);
      const label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
      util2.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g) {
  let maxRank2 = 0;
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    if (node2.borderTop) {
      node2.minRank = g.node(node2.borderTop).rank;
      node2.maxRank = g.node(node2.borderBottom).rank;
      maxRank2 = Math.max(maxRank2, node2.maxRank);
    }
  });
  g.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g) {
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    if (node2.dummy === "edge-proxy") {
      g.edge(node2.e).labelRank = node2.rank;
      g.removeNode(v);
    }
  });
}
function translateGraph(g) {
  let minX = Number.POSITIVE_INFINITY;
  let maxX = 0;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = 0;
  const graphLabel = g.graph();
  const marginX = graphLabel.marginx || 0;
  const marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    const x2 = attrs.x;
    const y2 = attrs.y;
    const w = Math.max(("minwidth" in attrs ? attrs.minwidth : 0) || 0, attrs.width);
    const h = attrs.height;
    minX = Math.min(minX, x2 - w / 2);
    maxX = Math.max(maxX, x2 + w / 2);
    minY = Math.min(minY, y2 - h / 2);
    maxY = Math.max(maxY, y2 + h / 2);
  }
  forEach$1(g.nodes(), function(v) {
    getExtremes(g.node(v));
  });
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    if (has$1(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    node2.x -= minX;
    node2.y -= minY;
  });
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    forEach$1(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (has$1(edge, "x")) {
      edge.x -= minX;
    }
    if (has$1(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}
function assignNodeIntersects(g) {
  const { rankdir, splines, borderRanks, nodesep, avoid_label_on_border } = g.graph();
  const isTopBottom = rankdir.toUpperCase() === "TB";
  const isBottomTop = rankdir.toUpperCase() === "BT";
  const isVerticalLayout = isBottomTop || isTopBottom;
  const isOrthogonal = splines === "ortho";
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    const nodeV = g.node(e.v);
    const nodeW = g.node(e.w);
    let p1 = null;
    let p2 = null;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
      edge.points.unshift(util2.intersectRect(nodeV, p1));
      edge.points.push(util2.intersectRect(nodeW, p2));
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
      const pointsBetween = edge.points.slice(1, edge.points.length - 1);
      if (avoid_label_on_border) {
        const isLabelPointOnBorder = borderRanks.has(nodeV.rank + 1);
        if (isLabelPointOnBorder) {
          p1.y += nodesep;
        }
      }
      const labelPoint = { ...p1 };
      edge.labelPoint = labelPoint;
      const origInterWithV = util2.intersectRect(nodeV, labelPoint);
      const origInterWithW = util2.intersectRect(nodeW, p2);
      let edgePointsArranged = false;
      if (isOrthogonal) {
        const nodesInfo = comparePositions(nodeV, nodeW);
        const { leftOne, rightOne, bottomOne, topOne } = nodesInfo;
        const lastPointInBetween = pointsBetween.length ? pointsBetween[pointsBetween.length - 1] : null;
        const rangeOfVWCenter = {
          x: [leftOne.x, rightOne.x],
          y: [topOne.y, bottomOne.y]
        };
        if (isVerticalLayout && !nodesInfo.isXEqual && isInsideRange(labelPoint.x, rangeOfVWCenter.x)) {
          const topRectBottomBound = topOne.y + topOne.height / 2;
          const bottomRectUpperBound = bottomOne.y - bottomOne.height / 2;
          const newInterWithV = {
            ...origInterWithV
          };
          const newInterWithW = {
            ...origInterWithW
          };
          newInterWithV.y = Math.max(origInterWithV.y, topRectBottomBound);
          newInterWithW.y = Math.min(origInterWithW.y, bottomRectUpperBound);
          p1 = { x: newInterWithV.x, y: labelPoint.y };
          p2 = { x: newInterWithW.x, y: (lastPointInBetween || labelPoint).y };
          const newPoints = [
            newInterWithV,
            p1,
            labelPoint,
            ...pointsBetween,
            p2,
            newInterWithW
          ];
          const overlapXRange = [
            rightOne.x - rightOne.width / 2,
            leftOne.x + leftOne.width / 2
          ];
          if (overlapXRange[0] < overlapXRange[1]) {
            const isAllInRange = newPoints.every((p) => {
              return isInsideRange(p.x, overlapXRange);
            });
            if (isAllInRange) {
              for (const p of newPoints) {
                p.x = labelPoint.x;
              }
            }
          }
          edge.points = newPoints;
          edgePointsArranged = true;
        } else if (!isVerticalLayout && !nodesInfo.isYEqual && isInsideRange(labelPoint.y, rangeOfVWCenter.y)) {
          const { leftOne: leftOne2, rightOne: rightOne2 } = nodesInfo;
          const leftRectRightBound = leftOne2.x + leftOne2.width / 2;
          const rightRectLeftBound = rightOne2.x - rightOne2.width / 2;
          const newInterWithV = {
            ...origInterWithV,
            x: Math.max(origInterWithV.x, leftRectRightBound)
          };
          const newInterWithW = {
            ...origInterWithW,
            x: Math.min(origInterWithW.x, rightRectLeftBound)
          };
          p1 = { x: labelPoint.x, y: newInterWithV.y };
          p2 = { x: (lastPointInBetween || labelPoint).x, y: newInterWithW.y };
          const newPoints = [
            newInterWithV,
            p1,
            labelPoint,
            ...pointsBetween,
            p2,
            newInterWithW
          ];
          const overlapYRange = [
            bottomOne.y - bottomOne.height / 2,
            topOne.y + topOne.height / 2
          ];
          if (overlapYRange[0] < overlapYRange[1]) {
            const isAllInRange = newPoints.every((p) => {
              return isInsideRange(p.y, overlapYRange);
            });
            if (isAllInRange) {
              for (const p of newPoints) {
                p.y = labelPoint.y;
              }
            }
          }
          edge.points = newPoints;
          edgePointsArranged = true;
        }
      }
      if (!edgePointsArranged) {
        const intersectWithV = util2.intersectRect(nodeV, labelPoint);
        const intersectWithW = util2.intersectRect(nodeW, p2);
        edge.points.unshift(intersectWithV);
        edge.points.push(intersectWithW);
      }
    }
  });
}
function fixupEdgeLabelCoords(g) {
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    if (has$1(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g) {
  forEach$1(g.edges(), function(e) {
    const edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g) {
  const { borderRanks } = g.graph();
  forEach$1(g.nodes(), function(v) {
    if (g.children(v).length) {
      const node2 = g.node(v);
      const t = g.node(node2.borderTop);
      const b10 = g.node(node2.borderBottom);
      const l = g.node(last2(node2.borderLeft));
      const r = g.node(last2(node2.borderRight));
      borderRanks.add(t.rank);
      borderRanks.add(b10.rank);
      const widthBetweenBorder = Math.abs(r.x - l.x);
      node2.width = Math.max(widthBetweenBorder, node2.minwidth || 0);
      if (node2.minwidth && node2.minwidth > widthBetweenBorder) {
        const wOffset = node2.minwidth - widthBetweenBorder;
        const originalRightEdge = Math.min(l.x, r.x) + widthBetweenBorder;
        addOffsetFromX(wOffset, originalRightEdge);
      }
      node2.height = Math.abs(b10.y - t.y);
      node2.x = l.x + node2.width / 2;
      node2.y = t.y + node2.height / 2;
    }
  });
  forEach$1(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
  function addOffsetFromX(wOffset, startX) {
    const visited = {};
    const dfs2 = (v) => {
      if (visited[v])
        return;
      visited[v] = true;
      const node2 = g.node(v);
      if (node2.x >= startX)
        node2.x += wOffset;
      for (const child of g.children(v))
        dfs2(child);
    };
    for (const v of g.nodes())
      dfs2(v);
  }
}
function removeSelfEdges(g) {
  forEach$1(g.edges(), function(e) {
    if (e.v === e.w) {
      const node2 = g.node(e.v);
      if (!node2.selfEdges) {
        node2.selfEdges = [];
      }
      node2.selfEdges.push({ e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}
function insertSelfEdges(g) {
  const layers = util2.buildLayerMatrix(g);
  layers.forEach(function(layer) {
    let orderShift = 0;
    layer.forEach(function(v, i2) {
      const node2 = g.node(v);
      node2.order = i2 + orderShift;
      forEach$1(node2.selfEdges, function(selfEdge) {
        util2.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node2.rank,
          order: i2 + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node2.selfEdges;
    });
  });
}
function positionSelfEdges(g) {
  forEach$1(g.nodes(), function(v) {
    const node2 = g.node(v);
    if (node2.dummy === "selfedge") {
      const selfNode = g.node(node2.e.v);
      const x2 = selfNode.x + selfNode.width / 2;
      const y2 = selfNode.y;
      const dx = node2.x - x2;
      const dy = selfNode.height / 2;
      g.setEdge(node2.e, node2.label);
      g.removeNode(v);
      node2.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ];
      node2.label.x = node2.x;
      node2.label.y = node2.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return mapValues(pick$1(obj, attrs), Number);
}
function canonicalize(attrs) {
  const newAttrs = {};
  forEach$1(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}
var index = {
  layout,
  util: util2
};

// ../pintora-diagrams/lib/util/dagre-wrapper.js
var DagreWrapper = class {
  constructor(g) {
    this.g = g;
  }
  doLayout() {
    index.layout(this.g);
  }
  callNodeOnLayout() {
    const graph = this.g;
    graph.nodes().forEach(function(v) {
      const nodeData = graph.node(v);
      if (nodeData) {
        if (nodeData.onLayout) {
          nodeData.onLayout(nodeData);
        }
      }
    });
  }
  callEdgeOnLayout() {
    const graph = this.g;
    graph.edges().forEach(function(e) {
      const edgeData = graph.edge(e);
      if (edgeData) {
        if (edgeData.onLayout) {
          edgeData.onLayout(edgeData);
        }
      }
    });
  }
  getGraphBounds() {
    return getGraphBounds(this.g);
  }
};

// ../pintora-diagrams/lib/er/artist.js
var conf2;
var erArtist = {
  draw(ir, config2, opts) {
    conf2 = getConf2(ir);
    const rootMark = {
      type: "group",
      attrs: {},
      children: []
    };
    const g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: false
    }).setGraph({
      rankdir: conf2.layoutDirection,
      nodesep: 80,
      edgesep: conf2.edgesep,
      ranksep: conf2.ranksep,
      splines: getGraphSplinesOption(conf2.edgeType)
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    const dagreWrapper = new DagreWrapper(g);
    drawEntities(rootMark, ir, g);
    const relationships = addRelationships(ir.relationships, g);
    drawInheritances(ir, g, rootMark);
    dagreWrapper.doLayout();
    dagreWrapper.callNodeOnLayout();
    dagreWrapper.callEdgeOnLayout();
    const relationsGroup = {
      type: "group",
      children: [],
      class: "er__relations"
    };
    const relationshipsBounds = makeBounds();
    relationships.forEach(function(rel) {
      const { bounds: relationBounds } = drawRelationshipFromLayout(relationsGroup, rel, g);
      tryExpandBounds(relationshipsBounds, relationBounds);
    });
    rootMark.children.unshift(relationsGroup);
    const bounds = dagreWrapper.getGraphBounds();
    tryExpandBounds(bounds, relationshipsBounds);
    const pad2 = conf2.diagramPadding;
    const { title } = ir;
    let titleSize = void 0;
    let titleMark = void 0;
    if (title) {
      const titleFont = { fontSize: conf2.fontSize, fontFamily: conf2.fontFamily };
      const titleResult = makeTitleMark(title, titleFont, { fill: conf2.textColor });
      titleSize = titleResult.titleSize;
      titleMark = titleResult.mark;
      titleMark.class = "er__title";
      rootMark.children.push(titleMark);
      titleSize.height += conf2.fontSize;
    }
    const { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds: bounds,
      padX: pad2,
      padY: pad2,
      useMaxWidth: conf2.useMaxWidth,
      containerSize: opts === null || opts === void 0 ? void 0 : opts.containerSize,
      titleSize,
      titleMark
    });
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
};
function getFontConfig(conf6) {
  return {
    fontSize: conf6.fontSize,
    fontFamily: conf6.fontFamily
  };
}
var drawAttributes = (group, entityText, attributes) => {
  const attribPaddingY = conf2.entityPaddingY / 2;
  const attribPaddingX = conf2.entityPaddingX / 2;
  const attrFontSize = conf2.fontSize * 0.85;
  const labelBBox = { width: Math.ceil(entityText.attrs.width), height: Math.ceil(entityText.attrs.height) };
  let maxRowContentWidth = 0;
  let cumulativeHeight = labelBBox.height + attribPaddingY * 2;
  let attrNum = 1;
  const attributeGroup = makeEmptyGroup();
  group.children.push(attributeGroup);
  const tableBuilder = new TableBuilder();
  attributes.forEach((item) => {
    const attrPrefix = `${entityText.attrs.id}-attr-${attrNum}`;
    const makeLabelTextMark = (name, text) => {
      return makeMark("text", {
        ...getTextDimensionsInPresicion(text, fontConfig),
        ...getBaseText(),
        id: `${attrPrefix}-${name}`,
        text,
        textAlign: "left",
        textBaseline: "middle",
        ...fontConfig
      }, { class: "er__entity-label" });
    };
    const fontConfig = { ...getFontConfig(conf2), fontSize: attrFontSize };
    let keyCell;
    if (item.attributeKey) {
      keyCell = TableCell.fromMark(makeLabelTextMark("key", item.attributeKey), "key");
    }
    const typeCell = TableCell.fromMark(makeLabelTextMark("type", item.attributeType), "type");
    const nameCell = TableCell.fromMark(makeLabelTextMark("name", item.attributeName), "name");
    let commentCell;
    if (item.comment) {
      commentCell = TableCell.fromMark(makeLabelTextMark("name", item.comment), "comment");
    }
    const row = new TableRow();
    row.addCells([typeCell, nameCell, keyCell, commentCell]);
    maxRowContentWidth = Math.max(maxRowContentWidth, row.map((v) => {
      var _a;
      return ((_a = v.mark) === null || _a === void 0 ? void 0 : _a.attrs.width) || 0;
    }).reduce((acc, num) => acc + num, 0));
    const cellUnitHeights = row.map((v) => {
      var _a;
      return ((_a = v.mark) === null || _a === void 0 ? void 0 : _a.attrs.height) || 0;
    });
    cumulativeHeight += Math.max(...cellUnitHeights) + attribPaddingY * 2;
    attrNum += 1;
    tableBuilder.addRow(row);
  });
  const columnMaxWidths = {
    key: 0,
    type: 0,
    name: 0,
    comment: 0
  };
  tableBuilder.rows.forEach((row) => {
    row.map((cell) => {
      columnMaxWidths[cell.name] = Math.floor(Math.max(columnMaxWidths[cell.name], cell.width));
    });
  });
  const cellOffsets = {
    key: 0,
    type: 0,
    name: 0,
    comment: 0
  };
  let cumulativeOffsetX = 0;
  Object.keys(cellOffsets).sort((a, b10) => CELL_ORDER[a] - CELL_ORDER[b10]).forEach((k) => {
    cellOffsets[k] = cumulativeOffsetX;
    if (columnMaxWidths[k]) {
      cumulativeOffsetX += Math.floor(columnMaxWidths[k] + 2 * attribPaddingX);
    }
  });
  const bBox = {
    width: Math.ceil(Math.max(conf2.minEntityWidth, cumulativeOffsetX, labelBBox.width + attribPaddingX * 2)),
    height: attributes.length > 0 ? cumulativeHeight : Math.max(conf2.minEntityHeight, labelBBox.height + conf2.entityPaddingY * 2)
  };
  if (attributes.length > 0) {
    let makeAttribLabelRect = function(attrs) {
      return makeMark("rect", {
        fill: attributeFill,
        stroke: conf2.stroke,
        ...attrs
      });
    };
    entityText.matrix = mat3_exports.fromTranslation(mat3_exports.create(), [bBox.width / 2, attribPaddingY + labelBBox.height / 2]);
    let heightOffset = toFixed(labelBBox.height + attribPaddingY * 2);
    let attribStyle = "attributeBoxOdd";
    const attributeFill = conf2.attributeFill;
    const cellOrderKeys = Object.keys(CELL_ORDER);
    tableBuilder.rows.forEach((row) => {
      const rowSegs = row.map((v) => v.mark);
      const rowTextHeight = rowSegs.reduce((out, mark) => Math.max(out, mark.attrs.height), 0);
      const rowHeight = toFixed(rowTextHeight + attribPaddingY * 2);
      const alignY = toFixed(heightOffset + attribPaddingY + rowTextHeight / 2);
      const rowGroup = makeEmptyGroup();
      attributeGroup.children.push(rowGroup);
      let lastColumnRect;
      let rectWidthSum = 0;
      cellOrderKeys.forEach((name) => {
        if (!columnMaxWidths[name])
          return;
        const cell = row.getCell(name);
        const offsetX = cellOffsets[name];
        const rect = makeAttribLabelRect({
          x: offsetX,
          y: heightOffset,
          width: columnMaxWidths[name] + attribPaddingX * 2,
          height: rowHeight
        });
        rowGroup.children.push(rect);
        rectWidthSum += rect.attrs.width;
        lastColumnRect = rect;
        if (cell) {
          rowGroup.children.push(cell.mark);
          cell.mark.matrix = mat3_exports.fromTranslation(mat3_exports.create(), [offsetX + attribPaddingX, alignY]);
        }
      });
      if (lastColumnRect) {
        lastColumnRect.attrs.width += Math.max(0, bBox.width - rectWidthSum);
      }
      const nodeUnitHeights = row.map((v) => (v === null || v === void 0 ? void 0 : v.mark.attrs.height) || 0);
      heightOffset += toFixed(Math.max(...nodeUnitHeights) + attribPaddingY * 2);
      attribStyle = attribStyle == "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
    });
  } else {
    bBox.height = Math.max(conf2.minEntityHeight, cumulativeHeight);
    entityText.matrix = mat3_exports.fromTranslation(mat3_exports.create(), [bBox.width / 2, bBox.height / 2]);
  }
  return {
    ...bBox,
    attributeGroup
  };
};
var drawEntities = function(rootMark, ir, graph) {
  const keys3 = Object.keys(ir.entities);
  const groups = [];
  keys3.forEach(function(id9) {
    const entity = ir.entities[id9];
    const itemId = entity.itemId;
    const group = makeMark("group", {
      id: id9
    }, { children: [], class: "er__entity" });
    groups.push(group);
    const fontConfig = { ...getFontConfig(conf2), fontWeight: "bold" };
    const textMark = makeMark("text", {
      ...getBaseText(),
      ...getTextDimensionsInPresicion(id9, fontConfig),
      text: id9,
      id: itemId,
      textAlign: "center",
      textBaseline: "middle",
      fill: conf2.textColor,
      ...fontConfig
    }, { itemId, class: "er__entity-label" });
    const rectMark = makeMark("rect", {
      ...getBaseText(),
      fill: conf2.fill,
      stroke: conf2.stroke,
      x: 0,
      y: 0,
      radius: conf2.borderRadius
    }, { itemId, class: "er__entity-box" });
    group.children.push(rectMark, textMark);
    const { width: entityWidth, height: entityHeight, attributeGroup } = drawAttributes(group, textMark, ir.entities[id9].attributes);
    safeAssign(rectMark.attrs, {
      width: entityWidth,
      height: entityHeight
    });
    attributeGroup.itemId = itemId;
    graph.setNode(id9, {
      width: entityWidth,
      height: entityHeight,
      id: id9,
      onLayout(data) {
        const x2 = Math.floor(data.x);
        const y2 = Math.floor(data.y);
        const marks = [rectMark, textMark];
        marks.forEach((mark) => {
          safeAssign(mark.attrs, { x: x2 - rectMark.attrs.width / 2, y: y2 - rectMark.attrs.height / 2 });
        });
        if (attributeGroup) {
          positionGroupContents(attributeGroup, {
            x: toFixed(x2 - entityWidth / 2),
            y: toFixed(y2 - entityHeight / 2),
            width: data.width,
            height: data.height
          });
        }
      }
    });
    rootMark.children.push(group);
  });
  return groups;
};
var getEdgeName = function(rel) {
  return (rel.entityA + rel.roleA + rel.entityB).replace(/\s/g, "");
};
var addRelationships = function(relationships, g) {
  relationships.forEach(function(r) {
    g.setEdge(r.entityA, r.entityB, { name: getEdgeName(r), relationship: r });
  });
  return relationships;
};
var relCnt = 0;
var drawRelationshipFromLayout = function(group, rel, g) {
  relCnt++;
  const bounds = makeBounds();
  const edge = g.edge(rel.entityA, rel.entityB);
  if (!("relationship" in edge))
    return;
  const [startPoint, ...restPoints] = edge.points;
  const secondPoint = restPoints[0];
  const lastPoint = restPoints[restPoints.length - 1];
  updateBoundsByPoints(bounds, edge.points);
  let pathCommands;
  if (conf2.edgeType === "curved") {
    const pathString = getPointsCurvePath(edge.points);
    pathCommands = pathString;
  } else {
    pathCommands = getPointsLinearPath(edge.points);
  }
  const itemId = rel.itemId;
  const linePath = makeMark("path", {
    path: pathCommands,
    stroke: conf2.edgeColor,
    lineJoin: "round"
  }, { itemId });
  if (rel.relSpec.relType === Identification.NON_IDENTIFYING) {
    linePath.attrs.lineDash = [4, 4];
  }
  const endMarkerDirection = calcDirection(restPoints[restPoints.length - 1], restPoints[restPoints.length - 2]);
  const endMarker = drawMarkerTo(lastPoint, rel.relSpec.cardA, endMarkerDirection, {
    stroke: conf2.stroke,
    id: `${edge.name}-end`
  });
  const startMarkerDirection = calcDirection(startPoint, secondPoint);
  const startMarker = drawMarkerTo(startPoint, rel.relSpec.cardB, startMarkerDirection, {
    stroke: conf2.stroke,
    id: `${edge.name}-start`
  });
  const labelPoint = edge.labelPoint || getPointAt(edge.points, 0.4, true);
  const labelX = labelPoint.x;
  const labelY = labelPoint.y;
  const labelId = "rel" + relCnt;
  const fontConfig = { ...getFontConfig(conf2), fontWeight: 400 };
  const labelMark = makeMark("text", {
    text: rel.roleA,
    id: labelId,
    textAlign: "center",
    textBaseline: "middle",
    x: labelX,
    y: labelY,
    fill: conf2.textColor,
    ...fontConfig
  }, { itemId, class: "er__relationship-label" });
  const labelDims = getTextDimensionsInPresicion(rel.roleA, fontConfig);
  labelDims.width += conf2.fontSize / 2;
  labelDims.height += conf2.fontSize / 2;
  const labelBg = makeLabelBg(labelDims, { x: labelX, y: labelY }, { id: `#${labelId}`, fill: conf2.labelBackground });
  const labelBgBound = calcBound([labelBg]);
  tryExpandBounds(bounds, labelBgBound);
  const insertingMarks = [linePath, labelBg, labelMark, startMarker, endMarker].filter((o) => !!o);
  group.children.push(...insertingMarks);
  return { bounds };
};
function drawInheritances(ir, g, rootMark) {
  const fontConfig = getFontConfig(conf2);
  const inheritanceGroup = makeEmptyGroup();
  rootMark.children.push(inheritanceGroup);
  ir.inheritances.forEach((inh) => {
    const LABEL_TEXT = "ISA";
    const labelDims = getTextDimensionsInPresicion(LABEL_TEXT, fontConfig);
    const labelMark = makeMark("text", {
      text: LABEL_TEXT,
      textAlign: "center",
      textBaseline: "middle",
      fill: conf2.textColor,
      ...fontConfig
    }, { class: "er__relationship-label" });
    inheritanceGroup.children.push(labelMark);
    const labelId = `inherit-${inh.sup}-${inh.sub}`;
    const triangleBaseLength = Math.max(labelDims.width, labelDims.height) * 1.8;
    const size4 = {
      width: triangleBaseLength,
      // add extra height, otherwise edge will point through the triangle
      height: Math.ceil(triangleBaseLength * Math.sin(Math.PI / 3)) + 5
    };
    let inheritNodeCenter;
    g.setNode(labelId, {
      ...size4,
      onLayout(data) {
        inheritNodeCenter = {
          x: toFixed(data.x),
          y: toFixed(data.y)
        };
      }
    });
    g.setEdge(labelId, inh.sup, {
      isInheritance: true,
      onLayout(edge) {
        const linePath = makeLinePath(edge, conf2);
        inheritanceGroup.children.push(linePath);
        const rad = calcDirection(edge.points[0], edge.points[1]);
        const { mark: triangle } = makeTriangle(inheritNodeCenter, triangleBaseLength, rad + Math.PI / 2, {
          stroke: conf2.edgeColor,
          fill: conf2.attributeFill,
          lineJoin: "round"
        });
        inheritanceGroup.children.unshift(triangle);
        const labelOffseX = -labelDims.width * Math.cos(rad) / 4;
        const labelOffseY = -labelDims.height * Math.sin(rad);
        safeAssign(labelMark.attrs, {
          x: inheritNodeCenter.x + labelOffseX,
          y: inheritNodeCenter.y + labelOffseY
        });
      }
    });
    g.setEdge(inh.sub, labelId, {
      isInheritance: true,
      onLayout(edge) {
        const linePath = makeLinePath(edge, conf2);
        inheritanceGroup.children.push(linePath);
      }
    });
  });
}
function makeLinePath(edge, conf6) {
  const pathCommands = conf6.edgeType === "curved" ? getPointsCurvePath(edge.points) : getPointsLinearPath(edge.points);
  const linePath = makeMark("path", {
    path: pathCommands,
    stroke: conf6.edgeColor,
    lineJoin: "round"
  });
  return linePath;
}
var artist_default2 = erArtist;

// ../pintora-diagrams/lib/er/parser/erDiagram.js
var moo2 = __toESM(require_moo());
function id2(d) {
  return d[0];
}
var COLOR2 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE2 = /@param/;
var CONFIG_DIRECTIVE3 = /@config/;
var L_PAREN2 = /\(/;
var R_PAREN2 = /\)/;
function getTokenValue2(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement2(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue2(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE2 = /%%.*/;
var lexer2 = moo2.compile({
  NL: MOO_NEWLINE,
  WS: { match: / +/, lineBreaks: false },
  QUOTED_WORD: QUOTED_WORD_REGEXP,
  ZERO_OR_ONE: /\|o|o\|/,
  ZERO_OR_MORE: /\}o|o\{/,
  ONE_OR_MORE: /\}\||\|\{/,
  ONLY_ONE: /\|\|/,
  NON_IDENTIFYING: /\.\.|\.\-|\-\./,
  IDENTIFYING: /\-\-/,
  COLON: /:/,
  LEFT_BRACE: /\{/,
  RIGHT_BRACE: /\}/,
  INHERIT: /inherit/,
  PARAM_DIRECTIVE: /@param/,
  COMMENT_LINE: COMMENT_LINE_REGEXP,
  CONFIG_DIRECTIVE: CONFIG_DIRECTIVE3,
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
});
var yy2;
function setYY2(v) {
  yy2 = v;
}
var grammar2 = {
  Lexer: lexer2,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id2 },
    { "name": "color", "symbols": [COLOR2], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE2, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE2, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE3, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement2 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE3, L_PAREN2, "configOpenCloseStatement$ebnf$1", R_PAREN2], "postprocess": handleConfigOpenCloseStatement2 },
    { "name": "comment", "symbols": [COMMENT_LINE2], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"] },
    { "name": "start", "symbols": [{ "literal": "erDiagram" }, "document"] },
    { "name": "document", "symbols": [] },
    { "name": "document", "symbols": ["document", "line"] },
    { "name": "line$ebnf$1", "symbols": [lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": id2 },
    { "name": "line$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"] },
    { "name": "line", "symbols": [lexer2.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement$ebnf$1", "symbols": [] },
    { "name": "statement$ebnf$1", "symbols": ["statement$ebnf$1", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "statement$ebnf$2", "symbols": [] },
    { "name": "statement$ebnf$2", "symbols": ["statement$ebnf$2", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "statement",
      "symbols": ["entityName", "statement$ebnf$1", "relSpec", "statement$ebnf$2", "entityName", lexer2.has("COLON") ? { type: "COLON" } : COLON, "role", lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        yy2.addEntity(d[0]);
        yy2.addEntity(d[4]);
        yy2.addRelationship(d[0], d[6], d[4], d[2]);
      }
    },
    { "name": "statement$ebnf$3", "symbols": [] },
    { "name": "statement$ebnf$3", "symbols": ["statement$ebnf$3", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "statement", "symbols": ["entityName", lexer2.has("WS") ? { type: "WS" } : WS, lexer2.has("INHERIT") ? { type: "INHERIT" } : INHERIT, lexer2.has("WS") ? { type: "WS" } : WS, "entityName", "statement$ebnf$3", lexer2.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => {
      yy2.addEntity(d[4]);
      yy2.addEntity(d[0]);
      const sup = d[4];
      const sub3 = d[0];
      yy2.addInheritance(sup, sub3);
    } },
    { "name": "statement$ebnf$4", "symbols": ["attributes"], "postprocess": id2 },
    { "name": "statement$ebnf$4", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["entityName", "__", { "literal": "{" }, "__", "statement$ebnf$4", "_", { "literal": "}" }, lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        yy2.addEntity(d[0]);
        if (d[4]) {
          yy2.addAttributes(d[0], d[4]);
        }
      }
    },
    { "name": "statement", "symbols": ["entityName", { "literal": "{" }, { "literal": "}" }, lexer2.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => yy2.addEntity(d[0]) },
    { "name": "statement$ebnf$5", "symbols": [] },
    { "name": "statement$ebnf$5", "symbols": ["statement$ebnf$5", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "statement", "symbols": ["entityName", "statement$ebnf$5", lexer2.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => yy2.addEntity(d[0]) },
    { "name": "statement", "symbols": ["titleStatement"] },
    { "name": "statement$ebnf$6", "symbols": [] },
    { "name": "statement$ebnf$6", "symbols": ["statement$ebnf$6", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "statement",
      "symbols": ["paramStatement", "statement$ebnf$6", lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const { type, ...styleParam } = d[0];
        yy2.addParam(styleParam);
      }
    },
    { "name": "statement$ebnf$7", "symbols": [] },
    { "name": "statement$ebnf$7", "symbols": ["statement$ebnf$7", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "statement",
      "symbols": ["configStatement", "statement$ebnf$7", lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        yy2.addOverrideConfig(d[0]);
      }
    },
    { "name": "statement", "symbols": ["comment", lexer2.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": [lexer2.has("NL") ? { type: "NL" } : NL] },
    { "name": "entityName", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": (d) => tv(d[0]) },
    { "name": "attributes", "symbols": ["attribute"], "postprocess": (d) => {
      return [d[0]];
    } },
    {
      "name": "attributes",
      "symbols": ["attribute", "__", "attributes"],
      "postprocess": (d) => {
        return [d[0]].concat(d[2]);
      }
    },
    { "name": "attribute$ebnf$1", "symbols": [] },
    { "name": "attribute$ebnf$1", "symbols": ["attribute$ebnf$1", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "attribute$ebnf$2", "symbols": [lexer2.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD], "postprocess": id2 },
    { "name": "attribute$ebnf$2", "symbols": [], "postprocess": () => null },
    {
      "name": "attribute",
      "symbols": ["attributeType", lexer2.has("WS") ? { type: "WS" } : WS, "attributeName", lexer2.has("WS") ? { type: "WS" } : WS, lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, "attribute$ebnf$1", "attribute$ebnf$2", lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const comment2 = d[6] ? getQuotedWord(d[6]) : "";
        return { attributeType: d[0], attributeName: d[2], attributeKey: tv(d[4]), comment: comment2 };
      }
    },
    { "name": "attribute$ebnf$3", "symbols": [] },
    { "name": "attribute$ebnf$3", "symbols": ["attribute$ebnf$3", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "attribute$ebnf$4", "symbols": [lexer2.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD], "postprocess": id2 },
    { "name": "attribute$ebnf$4", "symbols": [], "postprocess": () => null },
    { "name": "attribute$ebnf$5", "symbols": [] },
    { "name": "attribute$ebnf$5", "symbols": ["attribute$ebnf$5", lexer2.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "attribute",
      "symbols": ["attributeType", lexer2.has("WS") ? { type: "WS" } : WS, "attributeName", "attribute$ebnf$3", "attribute$ebnf$4", "attribute$ebnf$5", lexer2.has("NL") ? { type: "NL" } : NL],
      "postprocess": (d) => {
        const comment2 = d[4] ? getQuotedWord(d[4]) : "";
        return { attributeType: d[0], attributeName: d[2], comment: comment2 };
      }
    },
    { "name": "attributeType", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": (d) => tv(d[0]) },
    { "name": "attributeName", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": (d) => tv(d[0]) },
    {
      "name": "relSpec",
      "symbols": ["cardinality", "relType", "cardinality"],
      "postprocess": function(d) {
        return {
          cardA: d[2],
          relType: d[1],
          cardB: d[0]
        };
      }
    },
    { "name": "cardinality", "symbols": [lexer2.has("ZERO_OR_ONE") ? { type: "ZERO_OR_ONE" } : ZERO_OR_ONE], "postprocess": (d) => yy2.Cardinality.ZERO_OR_ONE },
    { "name": "cardinality", "symbols": [lexer2.has("ZERO_OR_MORE") ? { type: "ZERO_OR_MORE" } : ZERO_OR_MORE], "postprocess": (d) => yy2.Cardinality.ZERO_OR_MORE },
    { "name": "cardinality", "symbols": [lexer2.has("ONE_OR_MORE") ? { type: "ONE_OR_MORE" } : ONE_OR_MORE], "postprocess": (d) => yy2.Cardinality.ONE_OR_MORE },
    { "name": "cardinality", "symbols": [lexer2.has("ONLY_ONE") ? { type: "ONLY_ONE" } : ONLY_ONE], "postprocess": (d) => yy2.Cardinality.ONLY_ONE },
    { "name": "relType", "symbols": [lexer2.has("NON_IDENTIFYING") ? { type: "NON_IDENTIFYING" } : NON_IDENTIFYING], "postprocess": (d) => yy2.Identification.NON_IDENTIFYING },
    { "name": "relType", "symbols": [lexer2.has("IDENTIFYING") ? { type: "IDENTIFYING" } : IDENTIFYING], "postprocess": (d) => yy2.Identification.IDENTIFYING },
    { "name": "role", "symbols": [lexer2.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD], "postprocess": (d) => {
      return getQuotedWord(d[0]);
    } },
    { "name": "role", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": (d) => tv(d[0]) },
    { "name": "titleStatement", "symbols": [{ "literal": "title" }, lexer2.has("COLON") ? { type: "COLON" } : COLON, "words", lexer2.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => {
      yy2.addTitle(d[2].trim());
    } },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer2.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1$subexpression$1"] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer2.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer2.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": ["words$ebnf$1"],
      "postprocess": function(d) {
        return d[0].map((o) => tv(o[0])).join("");
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer2.has("WS") ? { type: "WS" } : WS] }
};
var erDiagram_default = grammar2;

// ../pintora-diagrams/lib/er/parser.js
setYY2(db_default2);
var parse2 = genParserWithRules(erDiagram_default);

// ../pintora-diagrams/lib/er/event-recognizer.js
var ENTITY_ITEM_PATTERN = /^entity\-/;
var RELATIONSHIP_ITEM_PATTERN = /^relationship\-/;
var createErDiagramEvent = diagramEventMakerFactory("er");
var eventRecognizer2 = new BaseEventRecognizer().addPatternRecognizerRule(ENTITY_ITEM_PATTERN, (e, m, ir) => {
  const entityName = m.itemId.replace(ENTITY_ITEM_PATTERN, "");
  return createErDiagramEvent(e, m, m.itemId, "entity", ir.entities[entityName]);
}).addPatternRecognizerRule(RELATIONSHIP_ITEM_PATTERN, (e, m, ir) => {
  const data = ir.relationships.find((r) => r.itemId === m.itemId);
  return createErDiagramEvent(e, m, m.itemId, "relationship", data);
});

// ../pintora-diagrams/lib/er/index.js
var erDiagram = {
  pattern: /^\s*erDiagram/,
  parser: {
    parse(text) {
      parse2(text);
      return db_default2.getDiagramIR();
    }
  },
  artist: artist_default2,
  configKey: configKey2,
  eventRecognizer: eventRecognizer2,
  clear() {
    db_default2.clear();
  }
};

// ../pintora-diagrams/lib/component/db.js
var LineType;
(function(LineType2) {
  LineType2["DOTTED_ARROW"] = "DOTTED_ARROW";
  LineType2["SOLID_ARROW"] = "SOLID_ARROW";
  LineType2["STRAIGHT"] = "STRAIGHT";
  LineType2["DOTTED"] = "DOTTED";
})(LineType || (LineType = {}));
var ComponentDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.aliases = {};
    this.components = {};
    this.interfaces = {};
    this.groups = {};
    this.relationships = [];
    this.LineType = LineType;
  }
  addComponent(name, comp) {
    if (this.components[name])
      return;
    this.components[name] = comp;
    this.aliases[name] = comp;
  }
  addInterface(name, interf) {
    if (this.interfaces[name])
      return;
    this.interfaces[name] = interf;
    this.aliases[name] = interf;
  }
  addGroup(name, group) {
    if (this.groups[name])
      return;
    this.groups[name] = group;
    this.aliases[name] = group;
  }
  addRelationship(r) {
    this.relationships.push(r);
  }
  apply(part) {
    if (Array.isArray(part)) {
      return part.map((p) => this.apply(p));
    }
    if (!part)
      return;
    switch (part.type) {
      case "addParam": {
        this.configParams.push(part);
        break;
      }
      case "overrideConfig": {
        this.addOverrideConfig(part);
        break;
      }
      case "setTitle": {
        this.title = part.text;
        break;
      }
      default: {
      }
    }
  }
  fillMissingElements() {
    const elements = [];
    const groupMap = {};
    const walkGroup = (group) => {
      groupMap[group.name] = group;
      group.children.forEach((child) => {
        if ("groupType" in child) {
          return walkGroup(child);
        }
        elements.push(child);
      });
    };
    for (const group of Object.values(this.groups)) {
      walkGroup(group);
    }
    this.relationships.forEach((r) => {
      elements.push(r.from);
      elements.push(r.to);
    });
    function addNewElementToGroup(element) {
      const parentGroup = groupMap[element.parent];
      if (parentGroup)
        parentGroup.children.push(element);
    }
    elements.forEach((element) => {
      const { name, type } = element;
      if (this.aliases[name]) {
      } else {
        if (type === "component") {
          if (!this.components[name] && !this.groups[name]) {
            this.addComponent(name, element);
            addNewElementToGroup(element);
          }
        } else if (type === "interface") {
          if (!this.interfaces[name]) {
            this.addInterface(name, element);
            addNewElementToGroup(element);
          }
        }
      }
    });
    this.relationships.forEach((r) => {
      ;
      [r.from, r.to].forEach((e) => {
        const aliasEntity = this.aliases[e.name];
        if (aliasEntity) {
          if ("type" in aliasEntity && aliasEntity.type !== e.type) {
            Object.assign(e, aliasEntity);
          }
        }
      });
    });
  }
  getDiagramIR() {
    return {
      components: this.components,
      interfaces: this.interfaces,
      groups: this.groups,
      relationships: this.relationships,
      ...this.getBaseDiagramIR()
    };
  }
  clear() {
    super.clear();
    this.aliases = {};
    this.components = {};
    this.interfaces = {};
    this.groups = {};
    this.relationships = [];
  }
};
var db3 = new ComponentDb();
var db_default3 = db3;

// ../pintora-diagrams/lib/component/config.js
var defaultConfig3 = {
  diagramPadding: 15,
  edgeType: "polyline",
  edgesep: 20,
  ranksep: 40,
  componentPadding: 15,
  componentBackground: PALETTE.yellow,
  componentBorderColor: PALETTE.orange,
  groupBackground: PALETTE.white,
  groupBorderColor: PALETTE.normalDark,
  groupBorderWidth: 2,
  relationLineColor: PALETTE.orange,
  textColor: PALETTE.normalDark,
  fontSize: 14,
  fontFamily: DEFAULT_FONT_FAMILY,
  lineWidth: 1,
  labelBackground: PALETTE.white,
  interfaceSize: 16,
  useMaxWidth: false,
  hideGroupType: false
};
var COMPONENT_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig3),
  componentBackground: { valueType: "color" },
  componentBorderColor: { valueType: "color" },
  groupBackground: { valueType: "color" },
  groupBorderColor: { valueType: "color" },
  relationLineColor: { valueType: "color" },
  textColor: { valueType: "color" },
  labelBackground: { valueType: "color" },
  hideGroupType: { valueType: "boolean" }
};
var configKey3 = "component";
var configurator3 = makeConfigurator({
  defaultConfig: defaultConfig3,
  configKey: configKey3,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(COMPONENT_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    return {
      componentBackground: t.primaryColor,
      componentBorderColor: t.primaryBorderColor,
      groupBackground: t.groupBackground,
      groupBorderColor: t.primaryBorderColor,
      relationLineColor: t.primaryColor,
      labelBackground: t.canvasBackground || t.background1,
      textColor: t.textColor
    };
  }
});
var getConf3 = configurator3.getConfig;

// ../pintora-diagrams/lib/component/artist.js
var conf3;
function getEdgeName2(relationship) {
  return `${relationship.from.name}_${relationship.to.name}_${relationship.message}`;
}
var componentArtist = {
  draw(ir, config2, opts) {
    conf3 = getConf3(ir, config2);
    const rootMark = {
      type: "group",
      attrs: {},
      children: []
    };
    const g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: true
    }).setGraph({
      nodesep: 20,
      edgesep: conf3.edgesep,
      ranksep: conf3.ranksep,
      splines: getGraphSplinesOption(conf3.edgeType),
      avoid_label_on_border: true
    });
    const dagreWrapper = new DagreWrapper(g);
    drawComponentsTo(rootMark, ir, g);
    drawInterfacesTo(rootMark, ir, g);
    drawGroupsTo(rootMark, ir, g);
    drawRelationshipsTo(rootMark, ir, g);
    dagreWrapper.doLayout();
    const { labelBounds } = adjustMarkInGraph(dagreWrapper);
    const gBounds = tryExpandBounds(dagreWrapper.getGraphBounds(), labelBounds);
    const pad2 = conf3.diagramPadding;
    const { title } = ir;
    let titleSize = void 0;
    let titleMark = void 0;
    if (title) {
      const titleFont = { fontSize: conf3.fontSize, fontFamily: conf3.fontFamily };
      const titleResult = makeTitleMark(title, titleFont, { fill: conf3.textColor });
      titleSize = titleResult.titleSize;
      titleMark = titleResult.mark;
      titleMark.class = "component__title";
      rootMark.children.push(titleMark);
      titleSize.height += conf3.fontSize;
    }
    const { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds,
      padX: pad2,
      padY: pad2,
      useMaxWidth: conf3.useMaxWidth,
      containerSize: opts === null || opts === void 0 ? void 0 : opts.containerSize,
      titleSize,
      titleMark
    });
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
};
function drawComponentsTo(parentMark, ir, g) {
  const groups = [];
  const fontConfig = getFontConfig2(conf3);
  for (const component of Object.values(ir.components)) {
    const id9 = component.name;
    const label = component.label || component.name;
    const componentLabelDims = calculateTextDimensions(label || "", fontConfig);
    const compWidth = Math.round(componentLabelDims.width + conf3.componentPadding * 2);
    const compHeight = Math.round(componentLabelDims.height + conf3.componentPadding * 2);
    const rectMark = makeMark("rect", {
      width: compWidth,
      height: compHeight,
      fill: conf3.componentBackground,
      stroke: conf3.componentBorderColor,
      lineWidth: conf3.lineWidth,
      radius: 4
    }, { class: "component__component-rect" });
    const textMark = makeMark("text", {
      text: label,
      fill: conf3.textColor,
      textAlign: "center",
      textBaseline: "middle",
      ...fontConfig
    });
    const group = makeMark("group", {}, {
      children: [rectMark, textMark],
      class: "component__component"
    });
    groups.push(group);
    parentMark.children.push(group);
    g.setNode(id9, {
      width: compWidth,
      height: compHeight,
      id: id9,
      onLayout(data) {
        const { x: x2, y: y2 } = data;
        safeAssign(rectMark.attrs, { x: x2 - compWidth / 2, y: y2 - compHeight / 2 });
        safeAssign(textMark.attrs, { x: x2, y: y2 });
      }
    });
  }
}
function drawInterfacesTo(parentMark, ir, g) {
  const groups = [];
  const fontConfig = getFontConfig2(conf3);
  for (const interf of Object.values(ir.interfaces)) {
    const id9 = interf.name;
    const label = interf.label || interf.name;
    const labelDims = calculateTextDimensions(label, fontConfig);
    const interfaceSize = conf3.interfaceSize;
    const circleMark = makeMark("circle", {
      x: 0,
      y: 0,
      r: interfaceSize / 2,
      fill: conf3.componentBackground,
      stroke: conf3.componentBorderColor,
      lineWidth: conf3.lineWidth
    }, { class: "component__interface" });
    const textMark = makeMark("text", {
      text: label,
      fill: conf3.textColor,
      textAlign: "center",
      textBaseline: "top",
      ...fontConfig
    });
    const group = makeMark("group", {}, {
      children: [circleMark, textMark],
      class: "component__group"
    });
    groups.push(group);
    parentMark.children.push(group);
    const outerWidth = Math.max(interfaceSize, labelDims.width);
    const nodeHeight = interfaceSize + labelDims.height;
    const layoutNode = {
      width: interfaceSize,
      height: nodeHeight,
      id: id9,
      outerWidth,
      onLayout(data) {
        const { x: x2, y: y2 } = data;
        safeAssign(circleMark.attrs, { x: x2, y: y2 - labelDims.height / 2 + 2 });
        safeAssign(textMark.attrs, { x: x2, y: y2 + 2 });
      }
    };
    g.setNode(id9, layoutNode);
    if (labelDims.width > interfaceSize) {
      const marginH = (labelDims.width - interfaceSize) / 2;
      layoutNode.marginl = marginH;
      layoutNode.marginr = marginH;
    }
  }
}
function drawGroupsTo(parentMark, ir, g) {
  for (const cGroup of Object.values(ir.groups)) {
    const groupId = cGroup.name;
    const groupType = cGroup.groupType;
    let bgMark;
    const symbolDef = symbolRegistry.get(groupType);
    if (symbolDef) {
    } else {
      bgMark = makeMark("rect", {
        fill: conf3.groupBackground,
        stroke: conf3.groupBorderColor,
        lineWidth: conf3.groupBorderWidth,
        radius: 2
      }, { class: "component__group-rect" });
    }
    const fontConfig = getFontConfig2(conf3);
    const groupLabel = cGroup.label || cGroup.name;
    const labelMark = makeMark("text", {
      text: groupLabel,
      fill: conf3.textColor,
      textAlign: "center",
      ...fontConfig,
      fontWeight: "bold"
    }, { class: "component__group-label" });
    let typeMark;
    const typeText = `[${cGroup.groupType}]`;
    if (!conf3.hideGroupType) {
      typeMark = makeMark("text", {
        text: typeText,
        fill: conf3.textColor,
        ...fontConfig,
        textBaseline: "hanging"
        // have to hack a little, otherwise label will collide with rect border in downloaded svg
      }, { class: "component__type" });
    }
    const labelTextDims = calculateTextDimensions(groupLabel, { ...fontConfig, fontWeight: labelMark.attrs.fontWeight });
    const nodeMarginConfig = {};
    if (symbolDef && symbolDef.symbolMargin) {
      Object.assign(nodeMarginConfig, {
        marginl: symbolDef.symbolMargin.left,
        marginr: symbolDef.symbolMargin.right,
        margint: symbolDef.symbolMargin.top,
        marginb: symbolDef.symbolMargin.bottom
      });
    }
    const groupMinWidth = labelTextDims.width + 10;
    g.setNode(groupId, {
      id: groupId,
      minwidth: groupMinWidth,
      ...nodeMarginConfig,
      onLayout(data) {
        const { x: x2, y: y2, width: width2, height } = data;
        const containerWidth = Math.max(width2, labelTextDims.width + 10);
        const node2 = g.node(groupId);
        if (bgMark && bgMark.type === "rect") {
          safeAssign(bgMark.attrs, { x: x2 - containerWidth / 2, y: y2 - height / 2, width: containerWidth, height });
          group.children.unshift(bgMark);
        } else {
          const contentArea = { ...data, width: Math.max(data.width, containerWidth) };
          bgMark = symbolRegistry.create(groupType, {
            mode: "container",
            contentArea,
            attrs: {
              fill: conf3.groupBackground,
              stroke: conf3.groupBorderColor,
              lineWidth: conf3.groupBorderWidth
            }
          });
          if (bgMark) {
            node2.outerHeight = bgMark.symbolBounds.height;
            node2.outerWidth = bgMark.symbolBounds.width;
            group.children.unshift(bgMark);
          }
        }
        safeAssign(labelMark.attrs, { x: x2, y: y2 - height / 2 + labelTextDims.height + 5 });
        if (typeMark) {
          const typeTextDims = calculateTextDimensions(typeText, fontConfig);
          safeAssign(typeMark.attrs, { x: x2 - containerWidth / 2 + 2, y: y2 + height / 2 - 2 - typeTextDims.height });
        }
      }
    });
    for (const child of cGroup.children) {
      if ("name" in child) {
        const childNode = g.node(child.name);
        if (childNode) {
          g.setParent(childNode.id, groupId);
          if (childNode.dummyBoxId) {
            g.setParent(childNode.id, childNode.dummyBoxId);
            g.setParent(childNode.dummyBoxId, groupId);
          }
        }
      }
    }
    const group = makeMark("group", {}, {
      children: compact([labelMark, typeMark])
    });
    parentMark.children.unshift(group);
  }
}
function drawRelationshipsTo(parentMark, ir, g) {
  ir.relationships.forEach(function(r) {
    const lineMark = makeMark("path", {
      path: [],
      stroke: conf3.relationLineColor,
      lineCap: "round"
    }, { class: "component__rel-line" });
    if ([LineType.DOTTED_ARROW, LineType.DOTTED].includes(r.line.lineType)) {
      lineMark.attrs.lineDash = [4, 4];
    }
    let relText;
    let relTextBg;
    let labelDims;
    if (r.message) {
      const fontConfig = getFontConfig2(conf3);
      labelDims = calculateTextDimensions(r.message, fontConfig);
      relText = makeMark("text", {
        text: r.message,
        fill: conf3.textColor,
        textAlign: "center",
        textBaseline: "middle",
        ...fontConfig
      }, { class: "component__rel-text" });
      relTextBg = makeLabelBg(labelDims, { x: 0, y: 0 }, { fill: conf3.labelBackground });
    }
    const shouldDrawArrow = r.line.lineType !== LineType.STRAIGHT;
    g.setEdge(r.from.name, r.to.name, {
      name: getEdgeName2(r),
      relationship: r,
      labelpos: "r",
      // labeloffset: 100,
      labelSize: labelDims,
      onLayout(data, context) {
        const newPath = conf3.edgeType === "curved" ? getPointsCurvePath(data.points) : getPointsLinearPath(data.points);
        lineMark.attrs.path = newPath;
        if (relText) {
          const anchorPoint = data.labelPoint || getPointAt(data.points, 0.4, true);
          safeAssign(relText.attrs, { x: anchorPoint.x, y: anchorPoint.y });
          safeAssign(relTextBg.attrs, {
            x: anchorPoint.x - labelDims.width / 2,
            y: anchorPoint.y - labelDims.height / 2
          });
          const bgAttrs = relTextBg.attrs;
          context.updateBounds({
            left: bgAttrs.x,
            right: bgAttrs.x + bgAttrs.width,
            top: bgAttrs.y,
            bottom: bgAttrs.y + bgAttrs.height,
            width: bgAttrs.width,
            height: bgAttrs.height
          });
        }
        if (shouldDrawArrow) {
          const lastPoint = data.points[data.points.length - 1];
          const pointsForDirection = data.points.slice(-2);
          const arrowRad = calcDirection.apply(null, pointsForDirection);
          const arrowMark = drawArrowTo(lastPoint, 8, arrowRad, {
            color: conf3.relationLineColor
          });
          relationGroupMark.children.push(arrowMark);
        }
      }
    });
    const isFromGroup = r.from.type === "group";
    const isToGroup = r.to.type === "group";
    if (isFromGroup || isToGroup) {
      if (isToGroup) {
        const toGroup = ir.groups[r.to.name];
        const firstChild = toGroup === null || toGroup === void 0 ? void 0 : toGroup.children[0];
        if (firstChild && "name" in firstChild) {
          g.setEdge(r.from.name, firstChild.name, { isDummyEdge: true });
        }
      } else if (isFromGroup) {
        const fromGroup = ir.groups[r.from.name];
        const firstChild = fromGroup === null || fromGroup === void 0 ? void 0 : fromGroup.children[0];
        if (firstChild && "name" in firstChild)
          g.setEdge(firstChild.name, r.to.name, { isDummyEdge: true });
      }
    }
    const relationGroupMark = makeMark("group", {}, {
      children: [lineMark, relTextBg, relText].filter((o) => Boolean(o))
    });
    parentMark.children.push(relationGroupMark);
  });
}
var adjustMarkInGraph = function(dagreWrapper) {
  dagreWrapper.callNodeOnLayout();
  const graph = dagreWrapper.g;
  const labelBounds = makeBounds();
  const updateLabelBounds = (b10) => {
    tryExpandBounds(labelBounds, b10);
  };
  graph.edges().forEach(function(e) {
    const edgeData = graph.edge(e);
    if (edgeData) {
      if (edgeData.onLayout) {
        edgeData.onLayout(edgeData, { updateBounds: updateLabelBounds });
      }
    }
  });
  return { labelBounds };
};
function getFontConfig2(conf6) {
  return {
    fontSize: conf6.fontSize,
    fontFamily: conf6.fontFamily
  };
}
var artist_default3 = componentArtist;

// ../pintora-diagrams/lib/component/parser/componentDiagram.js
var moo3 = __toESM(require_moo());
function id3(d) {
  return d[0];
}
var COLOR3 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE3 = /@param/;
var CONFIG_DIRECTIVE4 = /@config/;
var L_PAREN3 = /\(/;
var R_PAREN3 = /\)/;
function getTokenValue3(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement3(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue3(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE3 = /%%.*/;
var commonTopRules = {
  NL: MOO_NEWLINE,
  WS: { match: / +/, lineBreaks: true },
  L_SQ_BRACKET: { match: /\[/ },
  R_SQ_BRACKET: { match: /\]/ },
  COMMENT_LINE: COMMENT_LINE_REGEXP
};
var commonTextRules = {
  QUOTED_WORD: QUOTED_WORD_REGEXP,
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
};
var lexer3 = moo3.states({
  main: {
    ...commonTopRules,
    L_BRACKET: { match: /\{/ },
    R_BRACKET: { match: /\}/ },
    COLON: /:/,
    ...configLexerMainState,
    ...commonTextRules
  },
  configStatement: {
    ...configLexerconfigStatementState,
    ...commonTextRules
  }
});
var yy3;
function setYY3(v) {
  yy3 = v;
}
var grammar3 = {
  Lexer: lexer3,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id3 },
    { "name": "color", "symbols": [COLOR3], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE3, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE3, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE4, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement3 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE4, L_PAREN3, "configOpenCloseStatement$ebnf$1", R_PAREN3], "postprocess": handleConfigOpenCloseStatement3 },
    { "name": "comment", "symbols": [COMMENT_LINE3], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"] },
    {
      "name": "start",
      "symbols": [{ "literal": "componentDiagram" }, "document"],
      "postprocess": function(d) {
        if (!d[1])
          return;
        yy3.apply(d[1]);
        return d[1];
      }
    },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "line"],
      "postprocess": function(d) {
        return d[1];
      }
    },
    { "name": "line$ebnf$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "line$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"] },
    { "name": "line$ebnf$2", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "line$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$2", lexer3.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => null },
    {
      "name": "statement",
      "symbols": ["UMLElement"],
      "postprocess": function(d) {
        return d[0];
      }
    },
    { "name": "statement", "symbols": ["paramStatement", lexer3.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": [{ "literal": "title" }, lexer3.has("COLON") ? { type: "COLON" } : COLON, "words", lexer3.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => ({ type: "setTitle", text: d[2].trim() }) },
    { "name": "statement", "symbols": ["configOpenCloseStatement", lexer3.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["comment", lexer3.has("NL") ? { type: "NL" } : NL] },
    {
      "name": "UMLElement",
      "symbols": ["group"],
      "postprocess": function(d) {
        const obj = d[0];
        if (obj)
          yy3.addGroup(obj.name, obj);
        return obj;
      }
    },
    {
      "name": "UMLElement",
      "symbols": ["component"],
      "postprocess": function(d) {
        const obj = d[0];
        yy3.addComponent(obj.name, obj);
        return obj;
      }
    },
    {
      "name": "UMLElement",
      "symbols": ["interface"],
      "postprocess": function(d) {
        const obj = d[0];
        yy3.addInterface(obj.name, obj);
        return obj;
      }
    },
    { "name": "UMLElement", "symbols": ["relationship"], "postprocess": id3 },
    { "name": "group$ebnf$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "group$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "group$ebnf$2", "symbols": [] },
    { "name": "group$ebnf$2$subexpression$1", "symbols": ["_", "UMLElement"] },
    { "name": "group$ebnf$2", "symbols": ["group$ebnf$2", "group$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "group",
      "symbols": ["groupType", "group$ebnf$1", "textInsideQuote", "_", lexer3.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "group$ebnf$2", "_", lexer3.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const groupType = tv(d[0][0]);
        const label = d[2] || groupType;
        const name = d[2] || `${groupType}_${Date.now()}`;
        const children = d[5].map((l) => l[1]).filter((o) => o);
        children.forEach((child) => child.parent = name);
        return { type: "group", name, groupType, label, children };
      }
    },
    { "name": "groupType", "symbols": [{ "literal": "package" }] },
    { "name": "groupType", "symbols": [{ "literal": "node" }] },
    { "name": "groupType", "symbols": [{ "literal": "folder" }] },
    { "name": "groupType", "symbols": [{ "literal": "frame" }] },
    { "name": "groupType", "symbols": [{ "literal": "cloud" }] },
    { "name": "groupType", "symbols": [{ "literal": "database" }] },
    { "name": "groupType", "symbols": [{ "literal": "rectangle" }] },
    { "name": "groupType", "symbols": [{ "literal": "component" }] },
    { "name": "component$ebnf$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "component",
      "symbols": [{ "literal": "component" }, "component$ebnf$1", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const name = tv(d[2]);
        return { type: "component", name };
      }
    },
    { "name": "component$ebnf$2", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "component$ebnf$3", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$3", "symbols": [], "postprocess": () => null },
    { "name": "component$ebnf$4", "symbols": ["elementLabel"] },
    { "name": "component$ebnf$4", "symbols": ["component$ebnf$4", "elementLabel"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "component",
      "symbols": [{ "literal": "component" }, "component$ebnf$2", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, "component$ebnf$3", lexer3.has("L_SQ_BRACKET") ? { type: "L_SQ_BRACKET" } : L_SQ_BRACKET, "component$ebnf$4", lexer3.has("R_SQ_BRACKET") ? { type: "R_SQ_BRACKET" } : R_SQ_BRACKET, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const name = tv(d[2]);
        const label = d[5].join("").trim();
        return { type: "component", name, label };
      }
    },
    { "name": "component$ebnf$5", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$5", "symbols": [], "postprocess": () => null },
    { "name": "component$subexpression$1", "symbols": ["textInsideQuote"] },
    { "name": "component$subexpression$1", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "component$ebnf$6", "symbols": [] },
    { "name": "component$ebnf$6", "symbols": ["component$ebnf$6", lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "component",
      "symbols": [{ "literal": "component" }, "component$ebnf$5", "component$subexpression$1", "component$ebnf$6", { "literal": "as" }, "__", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const _l = d[2][0];
        const label = typeof _l === "string" ? _l : tv(_l);
        const name = tv(d[6]);
        return { type: "component", name, label };
      }
    },
    { "name": "component", "symbols": ["shortComponent", lexer3.has("NL") ? { type: "NL" } : NL], "postprocess": id3 },
    { "name": "component$ebnf$7", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$7", "symbols": [], "postprocess": () => null },
    { "name": "component$ebnf$8", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "component$ebnf$8", "symbols": [], "postprocess": () => null },
    {
      "name": "component",
      "symbols": ["shortComponent", "component$ebnf$7", { "literal": "as" }, "component$ebnf$8", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const comp = d[0];
        const name = tv(d[4]);
        return { ...comp, name, label: comp.name };
      }
    },
    { "name": "shortComponent$ebnf$1", "symbols": ["elementLabel"] },
    { "name": "shortComponent$ebnf$1", "symbols": ["shortComponent$ebnf$1", "elementLabel"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "shortComponent",
      "symbols": [lexer3.has("L_SQ_BRACKET") ? { type: "L_SQ_BRACKET" } : L_SQ_BRACKET, "shortComponent$ebnf$1", lexer3.has("R_SQ_BRACKET") ? { type: "R_SQ_BRACKET" } : R_SQ_BRACKET],
      "postprocess": function(d) {
        const name = d[1].join("");
        return { type: "component", name };
      }
    },
    { "name": "elementLabel$subexpression$1", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "elementLabel$subexpression$1", "symbols": [lexer3.has("NL") ? { type: "NL" } : NL] },
    { "name": "elementLabel$subexpression$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS] },
    { "name": "elementLabel", "symbols": ["elementLabel$subexpression$1"], "postprocess": (d) => tv(d[0][0]) },
    {
      "name": "textInsideQuote",
      "symbols": [lexer3.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD],
      "postprocess": function(d) {
        const v = getQuotedWord(d[0]);
        return v;
      }
    },
    { "name": "interface$ebnf$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "interface$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "interface$subexpression$1", "symbols": ["textInsideQuote"] },
    { "name": "interface$subexpression$1", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    {
      "name": "interface",
      "symbols": ["interfaceStart", "interface$ebnf$1", "interface$subexpression$1", lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const _l = d[2][0];
        const name = typeof _l === "string" ? _l : tv(_l);
        return { type: "interface", name };
      }
    },
    { "name": "interface$ebnf$2", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": id3 },
    { "name": "interface$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "interface$subexpression$2", "symbols": ["textInsideQuote"] },
    { "name": "interface$subexpression$2", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "interface$ebnf$3", "symbols": [] },
    { "name": "interface$ebnf$3", "symbols": ["interface$ebnf$3", lexer3.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "interface",
      "symbols": ["interfaceStart", "interface$ebnf$2", "interface$subexpression$2", "interface$ebnf$3", { "literal": "as" }, "__", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const _l = d[2][0];
        const label = typeof _l === "string" ? _l : tv(_l);
        const name = tv(d[6]);
        return { type: "interface", name, label };
      }
    },
    { "name": "interfaceStart$subexpression$1", "symbols": [{ "literal": "interface" }] },
    { "name": "interfaceStart$subexpression$1", "symbols": [{ "literal": "()" }] },
    { "name": "interfaceStart", "symbols": ["interfaceStart$subexpression$1"] },
    { "name": "relationship$ebnf$1$subexpression$1", "symbols": ["__", lexer3.has("COLON") ? { type: "COLON" } : COLON, "__", "words"] },
    { "name": "relationship$ebnf$1", "symbols": ["relationship$ebnf$1$subexpression$1"], "postprocess": id3 },
    { "name": "relationship$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "relationship",
      "symbols": ["elementReference", "_", "relationLine", "_", "elementReference", "relationship$ebnf$1", lexer3.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const from = d[0];
        const to = d[4];
        let message;
        if (d[5]) {
          message = d[5][3];
        }
        const line = d[2];
        const obj = { from, to, line, message };
        yy3.addRelationship(obj);
        return obj;
      }
    },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1$subexpression$1"] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer3.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": ["words$ebnf$1"],
      "postprocess": function(d) {
        return d[0].map((o) => tv(o[0])).join("").trim();
      }
    },
    { "name": "elementReference", "symbols": ["shortComponent"], "postprocess": id3 },
    { "name": "elementReference$ebnf$1$subexpression$1", "symbols": [{ "literal": "()" }, "__"] },
    { "name": "elementReference$ebnf$1", "symbols": ["elementReference$ebnf$1$subexpression$1"], "postprocess": id3 },
    { "name": "elementReference$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "elementReference",
      "symbols": ["elementReference$ebnf$1", lexer3.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT],
      "postprocess": function(d) {
        const interf = { type: "interface", name: tv(d[1]) };
        return interf;
      }
    },
    { "name": "relationLine", "symbols": [{ "literal": "-->" }], "postprocess": (d) => ({ lineType: yy3.LineType.SOLID_ARROW }) },
    { "name": "relationLine", "symbols": [{ "literal": "<--" }], "postprocess": (d) => ({ lineType: yy3.LineType.SOLID_ARROW, isReversed: true }) },
    { "name": "relationLine", "symbols": [{ "literal": "..>" }], "postprocess": (d) => ({ lineType: yy3.LineType.DOTTED_ARROW }) },
    { "name": "relationLine", "symbols": [{ "literal": "<.." }], "postprocess": (d) => ({ lineType: yy3.LineType.DOTTED_ARROW, isReversed: true }) },
    { "name": "relationLine", "symbols": [{ "literal": "--" }], "postprocess": (d) => ({ lineType: yy3.LineType.STRAIGHT }) },
    { "name": "relationLine", "symbols": [{ "literal": ".." }], "postprocess": (d) => ({ lineType: yy3.LineType.DOTTED }) }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer3.has("WS") ? { type: "WS" } : WS] }
};
var componentDiagram_default = grammar3;

// ../pintora-diagrams/lib/component/parser.js
setYY3(db_default3);
var parse3 = genParserWithRules(componentDiagram_default);

// ../pintora-diagrams/lib/component/index.js
var componentDiagram = {
  pattern: /^\s*componentDiagram/,
  parser: {
    parse(text) {
      parse3(text);
      db_default3.fillMissingElements();
      return db_default3.getDiagramIR();
    }
  },
  artist: artist_default3,
  configKey: configKey3,
  clear() {
    db_default3.clear();
  }
};

// ../pintora-diagrams/lib/activity/db.js
var ActivityDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.steps = [];
    this.notes = [];
    this.arrowLabels = [];
    this.idCounter = makeIdCounter();
  }
  makeId() {
    return `id-${this.idCounter.next()}`;
  }
  apply(part, ignoreAdd = false, state = {}) {
    if (Array.isArray(part)) {
      const partResults = [];
      let currentStep;
      part.forEach((p) => {
        var _a;
        const result = this.apply(p, ignoreAdd, { ...state, prevStepId: (_a = currentStep === null || currentStep === void 0 ? void 0 : currentStep.value) === null || _a === void 0 ? void 0 : _a.id });
        if (result) {
          partResults.push(result);
          currentStep = result;
        }
      });
      return partResults;
    }
    if (!part)
      return;
    let step;
    switch (part.type) {
      case "addAction":
        {
          const action = { ...part.action, id: this.makeId() };
          step = { type: "action", value: action };
        }
        break;
      case "condition":
        {
          const id9 = this.makeId();
          const thenResult = this.apply(part.then.children, true, { ...state, parentId: id9 });
          const condition = {
            id: id9,
            message: part.message,
            then: {
              label: part.then.label,
              children: thenResult
            }
          };
          if (part.else) {
            const elseResult = this.apply(part.else.children, true, { ...state, parentId: id9 });
            condition.else = {
              label: part.else.label,
              children: elseResult
            };
          }
          step = { type: "condition", value: condition };
        }
        break;
      case "while": {
        const id9 = this.makeId();
        const loopResult = this.apply(part.children, true, { ...state, parentId: id9 });
        const whileSentence = {
          id: id9,
          message: part.message,
          children: loopResult,
          confirmLabel: part.confirmLabel,
          denyLabel: part.denyLabel
        };
        step = { type: "while", value: whileSentence };
        break;
      }
      case "repeat": {
        const id9 = this.makeId();
        const loopResult = this.apply(part.children, true, { ...state, parentId: id9 });
        const sentence = {
          id: id9,
          message: part.message,
          children: loopResult,
          confirmLabel: part.confirmLabel,
          denyLabel: part.denyLabel,
          firstAction: part.firstAction
        };
        step = { type: "repeat", value: sentence };
        break;
      }
      case "switch": {
        const id9 = this.makeId();
        const cases = this.apply(part.children, true, { ...state, parentId: id9 });
        const switchSentence = {
          id: id9,
          message: part.message,
          children: cases
        };
        step = { type: "switch", value: switchSentence };
        break;
      }
      case "case": {
        const id9 = this.makeId();
        const children = this.apply(part.children, true, { ...state, parentId: id9 });
        const caseClause = {
          id: id9,
          confirmLabel: part.confirmLabel,
          children
        };
        step = { type: "case", value: caseClause };
        break;
      }
      case "fork": {
        const id9 = this.makeId();
        const branches = this.apply(part.branches, true, { ...state, parentId: id9 });
        const forkSentence = {
          id: id9,
          shouldMerge: part.shouldMerge,
          branches
        };
        step = { type: "fork", value: forkSentence };
        break;
      }
      case "forkBranch": {
        const id9 = this.makeId();
        const children = this.apply(part.children, true, { ...state, parentId: id9 });
        const forkBranch = {
          id: id9,
          children
        };
        step = { type: "forkBranch", value: forkBranch };
        break;
      }
      case "keyword": {
        step = { type: "keyword", value: { id: this.makeId(), label: part.label } };
        break;
      }
      case "group": {
        const id9 = this.makeId();
        const childrenResult = this.apply(part.children, true, { ...state, parentId: id9 });
        step = { type: "group", value: { id: id9, ...part, children: childrenResult } };
        break;
      }
      case "note": {
        const value = { id: this.makeId(), ...part, text: dedent_default(part.text) };
        const prevStepId = state.prevStepId;
        if (prevStepId) {
          value.target = prevStepId;
        }
        this.notes.push(value);
        break;
      }
      case "arrowLabel": {
        const value = { id: this.makeId(), ...part };
        const prevStepId = state.prevStepId;
        if (prevStepId) {
          value.target = prevStepId;
        }
        this.arrowLabels.push(value);
        break;
      }
      case "setTitle": {
        this.title = part.text;
        break;
      }
      case "addParam": {
        this.configParams.push(part);
        break;
      }
      case "overrideConfig": {
        this.addOverrideConfig(part);
        break;
      }
      default: {
      }
    }
    if (step && !ignoreAdd) {
      this.steps.push(step);
    }
    if (step) {
      step.parentId = state.parentId;
    }
    return step;
  }
  getDiagramIR() {
    return {
      steps: this.steps,
      notes: this.notes,
      arrowLabels: this.arrowLabels,
      ...this.getBaseDiagramIR()
    };
  }
  clear() {
    super.clear();
    this.idCounter.reset();
    this.steps = [];
    this.notes = [];
  }
};
var db4 = new ActivityDb();

// ../pintora-diagrams/lib/activity/config.js
var defaultConfig4 = {
  diagramPadding: 15,
  edgesep: 30,
  edgeType: "polyline",
  useMaxWidth: false,
  actionPaddingX: 10,
  actionPaddingY: 10,
  actionBackground: PALETTE.orange,
  actionBorderColor: PALETTE.normalDark,
  groupBackground: PALETTE.white,
  groupBorderColor: PALETTE.normalDark,
  textColor: PALETTE.normalDark,
  edgeColor: PALETTE.normalDark,
  keywordBackground: PALETTE.normalDark,
  noteTextColor: PALETTE.normalDark,
  noteMargin: 10,
  labelTextColor: PALETTE.normalDark,
  labelBackground: PALETTE.white,
  fontSize: 14,
  fontFamily: DEFAULT_FONT_FAMILY
};
var ACTIVITY_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig4),
  actionPaddingX: { valueType: "size" },
  actionPaddingY: { valueType: "size" },
  actionBackground: { valueType: "color" },
  actionBorderColor: { valueType: "color" },
  groupBackground: { valueType: "color" },
  groupBorderColor: { valueType: "color" },
  textColor: { valueType: "color" },
  edgeColor: { valueType: "color" },
  keywordBackground: { valueType: "color" },
  noteTextColor: { valueType: "color" },
  noteMargin: { valueType: "size" },
  labelBackground: { valueType: "color" },
  labelTextColor: { valueType: "color" },
  fontSize: { valueType: "size" },
  fontFamily: { valueType: "string" }
};
var configKey4 = "activity";
var configurator4 = makeConfigurator({
  defaultConfig: defaultConfig4,
  configKey: configKey4,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(ACTIVITY_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    return {
      actionBackground: t.primaryColor,
      actionBorderColor: t.primaryBorderColor,
      groupBackground: t.groupBackground,
      groupBorderColor: t.primaryBorderColor,
      textColor: t.textColor,
      edgeColor: t.primaryColor,
      keywordBackground: t.textColor,
      labelBackground: t.canvasBackground || t.background1,
      labelTextColor: t.textColor
    };
  }
});
var getConf4 = configurator4.getConfig;

// ../pintora-diagrams/lib/util/env.js
var isDev = typeof location !== "undefined" && location.hostname === "localhost";

// ../pintora-diagrams/lib/activity/artist-util.js
function makeTextMark(conf6, text, textDims, attrs) {
  return makeMark("text", {
    text,
    width: textDims.width,
    height: textDims.height,
    fill: conf6.textColor,
    fontSize: conf6.fontSize,
    fontFamily: conf6.fontFamily,
    textBaseline: "middle",
    textAlign: "center",
    ...attrs
  });
}

// ../pintora-diagrams/lib/activity/artist.js
var conf4;
var model2;
var activityDraw;
var theme2;
function calcTextDims(text, attrs = {}) {
  const _attrs = Object.assign(getFontConfig3(conf4), attrs);
  return calculateTextDimensions(text, _attrs);
}
function isDetachAlikeKeyword(keyword) {
  return ["detach", "kill"].includes(keyword.label);
}
function isEndAlikeKeyword(keyword) {
  return ["end", "stop"].includes(keyword.label);
}
var erArtist2 = {
  draw(ir, config2, opts) {
    conf4 = getConf4(ir, config2);
    model2 = new ArtistModel(ir);
    theme2 = config_default.getConfig().themeConfig.themeVariables;
    const rootMark = makeEmptyGroup();
    const g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: true
    }).setGraph({
      rankdir: "TB",
      nodesep: 60,
      edgesep: conf4.edgesep,
      ranksep: 30,
      splines: getGraphSplinesOption(conf4.edgeType)
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    model2.preProcess();
    const dagreWrapper = new DagreWrapper(g);
    activityDraw = new ActivityDraw(model2, g);
    if (isDev) {
      ;
      window.activityDraw = activityDraw;
    }
    ir.steps.forEach((step) => {
      activityDraw.drawStep(rootMark, step);
    });
    ir.notes.forEach((note) => {
      activityDraw.drawNote(rootMark, note);
    });
    dagreWrapper.doLayout();
    dagreWrapper.callNodeOnLayout();
    const { bounds: edgeBounds } = drawEdges(rootMark, g);
    const bounds = floorValues(tryExpandBounds(dagreWrapper.getGraphBounds(), edgeBounds));
    const { title } = ir;
    let titleSize = void 0;
    let titleMark = void 0;
    if (title) {
      const titleFont = { fontSize: conf4.fontSize, fontFamily: conf4.fontFamily };
      const titleResult = makeTitleMark(title, titleFont, { fill: conf4.textColor });
      titleSize = titleResult.titleSize;
      titleMark = titleResult.mark;
      titleMark.class = "activity__title";
      rootMark.children.push(titleMark);
      titleSize.height += conf4.fontSize;
    }
    const { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds: bounds,
      padX: conf4.diagramPadding,
      padY: conf4.diagramPadding,
      useMaxWidth: conf4.useMaxWidth,
      containerSize: opts === null || opts === void 0 ? void 0 : opts.containerSize,
      titleSize,
      titleMark
    });
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
};
function getActionRectSize(text) {
  const textDims = calcTextDims(text);
  const rectWidth = textDims.width + conf4.actionPaddingX * 2;
  const rectHeight = textDims.height + conf4.actionPaddingY * 2;
  return { rectWidth, rectHeight };
}
var ArtistModel = class {
  constructor(ir) {
    this.ir = ir;
    this.stepModelMap = /* @__PURE__ */ new Map();
    this.stepNotesMap = /* @__PURE__ */ new Map();
    this.stepArrowLabelMap = /* @__PURE__ */ new Map();
  }
  shouldTouchPrevIds(step) {
    return step.type !== "group";
  }
  preProcess() {
    const { ir } = this;
    let prevIds = [];
    const processRecursiveStep = (step, stepModel, opts = {}) => {
      const { childrenKeys = ["children"], parallelChildren = false } = opts;
      const value = step.value;
      const shouldSetPrevId = this.shouldTouchPrevIds(step);
      if (shouldSetPrevId)
        stepModel.prevId = last(prevIds);
      const oldPrevIds = prevIds;
      if (shouldSetPrevId) {
        prevIds = [];
      }
      const endId = `${value.id}-end`;
      safeAssign(stepModel, {
        endId
      });
      childrenKeys.forEach((key) => {
        if (value[key]) {
          value[key].forEach((s) => {
            processStep(s);
            if (parallelChildren) {
              prevIds = [];
            }
          });
        }
      });
      this.stepModelMap.set(value.id, stepModel);
      prevIds = oldPrevIds;
    };
    const processStep = (step) => {
      let stepModel = this.makeStepModel(step);
      switch (step.type) {
        case "action": {
          const action = step.value;
          const { rectWidth, rectHeight } = getActionRectSize(action.message);
          safeAssign(stepModel, {
            width: rectWidth,
            height: rectHeight
          });
          this.stepModelMap.set(action.id, stepModel);
          break;
        }
        case "condition": {
          const condition = step.value;
          stepModel.prevId = last(prevIds);
          const oldPrevIds = prevIds;
          prevIds = [];
          condition.then.children.forEach((s) => processStep(s));
          if (condition.else) {
            prevIds = [];
            condition.else.children.forEach((s) => processStep(s));
          }
          const endId = `${condition.id}-end`;
          safeAssign(stepModel, {
            endId
          });
          this.stepModelMap.set(condition.id, stepModel);
          prevIds = oldPrevIds;
          break;
        }
        case "while": {
          processRecursiveStep(step, stepModel);
          break;
        }
        case "switch": {
          processRecursiveStep(step, stepModel, { parallelChildren: true });
          break;
        }
        case "case": {
          processRecursiveStep(step, stepModel);
          const value = step.value;
          const firstChild = value.children[0];
          const lastChild = last(value.children);
          safeAssign(stepModel, {
            startId: firstChild ? firstChild.value.id : value.id,
            endId: lastChild ? lastChild.value.id : value.id
          });
          break;
        }
        case "repeat": {
          processRecursiveStep(step, stepModel);
          break;
        }
        case "group": {
          processRecursiveStep(step, stepModel);
          const aGroup = step.value;
          if (aGroup.children.length) {
            const firstChild = aGroup.children[0];
            const lastChild = last(aGroup.children);
            safeAssign(stepModel, {
              startId: firstChild.value.id,
              endId: lastChild.value.id
            });
          }
          break;
        }
        case "keyword": {
          const keyword = step.value;
          const { rectWidth, rectHeight } = getActionRectSize(keyword.label);
          safeAssign(stepModel, {
            width: rectWidth,
            height: rectHeight
          });
          this.stepModelMap.set(keyword.id, stepModel);
          break;
        }
        case "fork": {
          const fork = step.value;
          processRecursiveStep(step, stepModel, { childrenKeys: ["branches"], parallelChildren: true });
          const endId = `${fork.id}-end`;
          safeAssign(stepModel, {
            endId,
            innerFrameId: `${fork.id}-frame`
          });
          break;
        }
        case "forkBranch": {
          processRecursiveStep(step, stepModel);
          break;
        }
        default: {
          stepModel = null;
        }
      }
      if (prevIds.length && stepModel && !stepModel.prevId) {
        if (step.type !== "group") {
          const validPrevId = last(prevIds);
          const lastStepModel = this.stepModelMap.get(validPrevId);
          stepModel.prevId = lastStepModel ? lastStepModel.endId || lastStepModel.id : validPrevId;
        }
      }
      let newPrevId;
      if (stepModel && this.shouldTouchPrevIds(step)) {
        if (stepModel.endId) {
          newPrevId = stepModel.endId;
        } else if ("startId" in stepModel) {
          newPrevId = stepModel.startId;
        } else if ("id" in step.value) {
          newPrevId = step.value.id;
        }
      }
      if (newPrevId) {
        prevIds.pop();
        prevIds.push(newPrevId);
      }
    };
    ir.steps.forEach((step) => {
      processStep(step);
    });
    ir.notes.forEach((note) => {
      const parentId = note.target;
      if (parentId && this.stepModelMap.has(parentId)) {
        let stepNotes = this.stepNotesMap.get(parentId);
        if (!stepNotes) {
          stepNotes = [];
          this.stepNotesMap.set(parentId, stepNotes);
        }
        stepNotes.push(note);
      }
    });
    ir.arrowLabels.forEach((arrowLabel) => {
      const parentId = arrowLabel.target;
      if (parentId && this.stepModelMap.has(parentId)) {
        this.stepArrowLabelMap.set(parentId, arrowLabel);
      }
    });
  }
  makeStepModel(step) {
    return {
      ...step,
      id: step.value.id,
      width: 0,
      height: 0
    };
  }
};
var ActivityDraw = class {
  constructor(model3, g) {
    this.model = model3;
    this.g = g;
    this.keywordStepResults = {};
    this.results = {};
    this.traverseStepCollection = (steps, cb) => {
      if (!steps)
        return;
      let shouldStop = false;
      steps.forEach((child) => {
        if (cb(child) === false) {
          shouldStop = true;
          return;
        }
        this.traverseStep(child, cb);
      });
      return !shouldStop;
    };
    this.traverseStep = (step, cb) => {
      if (!step)
        return;
      const value = step.value;
      if ("children" in value) {
        this.traverseStepCollection(value.children, cb);
      } else if ("then" in value) {
        this.traverseStepCollection(value.then.children, cb);
        if (value.else) {
          this.traverseStepCollection(value.else.children, cb);
        }
      } else if ("branches" in value) {
        this.traverseStepCollection(value.branches, cb);
      }
    };
  }
  drawStep(rootMark, step) {
    var _a;
    const g = this.g;
    let result;
    switch (step.type) {
      case "action": {
        result = drawAction(rootMark, step.value, g);
        break;
      }
      case "condition": {
        const condition = step.value;
        result = this.drawCondition(rootMark, condition);
        break;
      }
      case "while": {
        result = this.drawWhile(rootMark, step.value);
        break;
      }
      case "switch": {
        result = this.drawSwitch(rootMark, step.value);
        break;
      }
      case "case": {
        result = this.drawCase(rootMark, step.value);
        break;
      }
      case "repeat": {
        result = this.drawRepeat(rootMark, step.value);
        break;
      }
      case "group": {
        result = this.drawGroup(rootMark, step.value);
        break;
      }
      case "keyword": {
        const keyword = step.value;
        result = this.drawKeyword(rootMark, keyword);
        this.keywordStepResults[keyword.label] = result;
        break;
      }
      case "fork": {
        result = this.drawFork(rootMark, step.value);
        break;
      }
      case "forkBranch": {
        result = this.drawForkBranch(rootMark, step.value);
        break;
      }
      default:
        break;
    }
    if (result && result.stepModel) {
      this.results[result.id] = result;
      if (result.endId)
        this.results[result.endId] = result;
      const prevId = result.stepModel.prevId;
      const startIdOfCurrent = result.stepModel.startId || result.stepModel.id;
      let label = "";
      const arrowLabel = this.model.stepArrowLabelMap.get(prevId);
      if (arrowLabel) {
        label = arrowLabel.text;
      }
      if (prevId) {
        const prevStepModel = this.model.stepModelMap.get(prevId);
        const prevResult = this.results[prevId];
        if (!label && (prevResult === null || prevResult === void 0 ? void 0 : prevResult.outLabel)) {
          label = prevResult.outLabel;
        }
        if (prevId === ((_a = this.keywordStepResults.start) === null || _a === void 0 ? void 0 : _a.id)) {
          g.setEdge(prevId, startIdOfCurrent, { label });
        } else if (prevStepModel && prevStepModel.type === "keyword") {
          g.setEdge(prevId, startIdOfCurrent, { label, isDummyEdge: true });
        } else if (result.hasDetached) {
          g.setEdge(prevId, startIdOfCurrent, { label, isDummyEdge: true });
        } else {
          g.setEdge(prevId, startIdOfCurrent, { label });
        }
      }
    }
    return result ? {
      ...result
    } : null;
  }
  linkResult(start, end, label = "") {
    if (!(start && end))
      return;
    const startId = typeof start === "string" ? start : start.endId || start.id;
    this.g.setEdge(startId, end.id, { label });
  }
  drawCondition(parentMark, condition) {
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(condition.id);
    const { bgMark: decisionBg, textMark, rectWidth, rectHeight } = this.drawDecisionMarks(condition.message);
    this.g.setNode(condition.id, {
      id: condition.id,
      mark: group,
      width: rectWidth,
      height: rectHeight,
      onLayout(data) {
        positionGroupContents(group, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
      }
    });
    const id9 = condition.id;
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId
    };
    const { mark: diamondMark } = this.drawDiamondMark(endId);
    parentMark.children.push(group, diamondMark);
    group.children.push(decisionBg, textMark);
    const drawChildren2 = (children, label) => {
      let hasEnded = false;
      const lastChildResult = last(children.map((child, i2) => {
        if (hasEnded)
          return;
        const childResult = this.drawStep(parentMark, child);
        if (child.type === "keyword") {
          hasEnded = true;
        }
        if (i2 === 0) {
          this.linkResult(id9, childResult, label);
        }
        return childResult;
      }));
      if (lastChildResult) {
        this.g.setEdge(lastChildResult.endId || lastChildResult.id, endId, {
          label: "",
          isDummyEdge: hasEnded
        });
      }
    };
    drawChildren2(condition.then.children, condition.then.label || "yes");
    if (condition.else) {
      drawChildren2(condition.else.children, "no");
    }
    return result;
  }
  drawDecisionMarks(message) {
    const { rectWidth, rectHeight } = getActionRectSize(message);
    const side = Math.ceil(conf4.fontSize * 0.8);
    const decisionBg = makeMark("path", {
      fill: conf4.actionBackground,
      stroke: conf4.actionBorderColor,
      path: [
        ["m", 0, rectHeight / 2],
        ["l", side, rectHeight / 2],
        ["l", rectWidth - side * 2, 0],
        ["l", side, -rectHeight / 2],
        ["l", -side, -rectHeight / 2],
        ["l", -rectWidth + side * 2, 0],
        ["Z"]
      ]
    }, { class: "activity__decision-bg" });
    const textDims = calcTextDims(message);
    const textMark = makeTextMark(conf4, message, textDims, {
      y: rectHeight / 2,
      x: rectWidth / 2,
      fontSize: conf4.fontSize,
      textBaseline: "middle",
      textAlign: "center"
    });
    return {
      bgMark: decisionBg,
      textMark,
      rectWidth,
      rectHeight
    };
  }
  drawDiamondMark(id9, attrs = {}, opts = {}) {
    const diamondSide = 10;
    const diamondMark = makeMark("path", {
      width: 20,
      height: 20,
      path: [
        ["m", -diamondSide, 0],
        ["l", diamondSide, diamondSide],
        ["l", diamondSide, -diamondSide],
        ["l", -diamondSide, -diamondSide],
        ["Z"]
      ],
      fill: conf4.actionBackground,
      stroke: conf4.actionBorderColor,
      ...attrs
    }, { class: opts.class || "activity__condition-end" });
    const moveDiamond = (x2, y2) => {
      const firstCommand = diamondMark.attrs.path[0];
      firstCommand[1] = x2 - diamondSide;
      firstCommand[2] = y2;
    };
    this.g.setNode(id9, {
      id: id9,
      mark: diamondMark,
      width: diamondSide * 2,
      height: diamondSide * 2,
      onLayout(data) {
        moveDiamond(data.x, data.y);
      }
    });
    return {
      mark: diamondMark,
      diamondSide,
      moveDiamond
    };
  }
  drawWhile(parentMark, wh) {
    const { message, id: id9 } = wh;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(wh.id);
    const { bgMark: decisionBg, textMark, rectWidth, rectHeight } = this.drawDecisionMarks(message);
    this.g.setNode(id9, {
      id: id9,
      mark: group,
      width: rectWidth,
      height: rectHeight,
      onLayout(data) {
        positionGroupContents(group, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
      }
    });
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId
    };
    const { mark: diamondMark } = this.drawDiamondMark(endId, {}, { class: "activity__while-end" });
    parentMark.children.push(group, diamondMark);
    group.children.push(decisionBg, textMark);
    const lastChildResult = last(wh.children.map((s, i2) => {
      const childResult = this.drawStep(parentMark, s);
      if (i2 === 0) {
        this.linkResult(id9, childResult, wh.confirmLabel || "");
      }
      return childResult;
    }));
    if (lastChildResult) {
      this.g.setEdge(lastChildResult.endId || lastChildResult.id, id9, { label: "" });
      this.g.setEdge(lastChildResult.endId || lastChildResult.id, endId, { label: "", isDummyEdge: true });
    }
    this.g.setEdge(id9, endId, { label: wh.denyLabel || "" });
    return result;
  }
  drawGroup(parentMark, aGroup) {
    const { id: id9 } = aGroup;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId
    };
    const bgMark = makeMark("rect", {
      fill: aGroup.background || conf4.groupBackground,
      stroke: conf4.groupBorderColor,
      lineWidth: 2,
      radius: 2
    }, { class: "activity__group-rect" });
    const groupLabel = aGroup.label || aGroup.name;
    const fontConfig = getFontConfig3(conf4);
    const labelMark = makeMark("text", {
      text: groupLabel,
      fill: conf4.textColor,
      ...fontConfig,
      fontWeight: "bold",
      textBaseline: "top"
    }, { class: "activity__group-rect" });
    const labelTextDims = calcTextDims(groupLabel, fontConfig);
    const labelId = `${id9}-label`;
    this.g.setNode(labelId, {
      id: labelId,
      mark: labelMark,
      width: labelTextDims.width,
      height: labelTextDims.height
    });
    this.g.setNode(id9, {
      id: id9,
      mark: group,
      onLayout: (data) => {
        const { x: x2, y: y2, width: width2, height } = data;
        const containerWidth = Math.max(width2, labelTextDims.width + 10);
        safeAssign(bgMark.attrs, { x: x2 - containerWidth / 2, y: y2 - height / 2, width: containerWidth, height });
        safeAssign(labelMark.attrs, { x: x2 - containerWidth / 2 + fontConfig.fontSize / 2, y: y2 - height / 2 });
      }
    });
    this.g.setParent(labelId, id9);
    group.children.push(bgMark, labelMark);
    parentMark.children.push(group);
    const setParentRecursive = (m) => {
      if (m.type === "group")
        return;
      unique(compact([m.id, m.startId, m.endId])).forEach((modelId) => {
        if (modelId)
          this.g.setParent(modelId, id9);
      });
      if (m.innerFrameId) {
        this.g.setParent(m.innerFrameId, id9);
      } else {
        this.traverseStep(m, (child) => {
          const childStepModel = this.model.stepModelMap.get(child.value.id);
          if (childStepModel)
            setParentRecursive(childStepModel);
        });
      }
    };
    aGroup.children.map((s) => {
      const childResult = this.drawStep(parentMark, s);
      this.g.setParent(childResult.id, id9);
      setParentRecursive(childResult.stepModel);
      return childResult;
    });
    return result;
  }
  drawSwitch(parentMark, s) {
    const { id: id9, message } = s;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const { bgMark: decisionBg, textMark, rectWidth, rectHeight } = this.drawDecisionMarks(message);
    this.g.setNode(id9, {
      id: id9,
      mark: group,
      width: rectWidth,
      height: rectHeight,
      onLayout(data) {
        positionGroupContents(group, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
      }
    });
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId
    };
    const { mark: diamondMark } = this.drawDiamondMark(endId);
    group.children.push(decisionBg, textMark);
    parentMark.children.push(group, diamondMark);
    s.children.map((caseStep) => {
      const childResult = this.drawStep(parentMark, caseStep);
      this.g.setEdge(id9, childResult.stepModel.startId || childResult.id, {
        label: caseStep.value.confirmLabel,
        simplifyStartEdge: true
      });
      if (!childResult.hasEnded) {
        this.g.setEdge(childResult.endId, endId, { label: "" });
      }
      return childResult;
    });
    return result;
  }
  drawCase(parentMark, c) {
    const { id: id9 } = c;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId,
      hasEnded: false
    };
    parentMark.children.push(group);
    if (c.children.length) {
      c.children.forEach((caseClause) => {
        if (result.hasEnded)
          return;
        if (caseClause.type === "keyword") {
          result.hasEnded = true;
        }
        this.drawStep(parentMark, caseClause);
      });
    } else {
      const holderMark = makeCircle({
        r: 1
      });
      parentMark.children.push(holderMark);
      this.g.setNode(endId, {
        width: 1,
        height: 1,
        mark: holderMark
      });
    }
    return result;
  }
  drawRepeat(parentMark, repeat) {
    const { message, id: id9 } = repeat;
    const denyLabel = repeat.denyLabel || "no";
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const { bgMark: decisionBg, textMark, rectWidth, rectHeight } = this.drawDecisionMarks(message);
    const endId = stepModel.endId;
    const startId = stepModel.id;
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId,
      outLabel: denyLabel
    };
    let startMark;
    if (repeat.firstAction) {
      const firstActionGroup = makeEmptyGroup();
      firstActionGroup.class = "activity__repeat-start";
      const { rectMark, textMark: textMark2, actionInfo } = drawActionMarks({ message: repeat.firstAction.message, conf: conf4 });
      firstActionGroup.children.push(rectMark, textMark2);
      startMark = firstActionGroup;
      this.g.setNode(startId, {
        id: startId,
        mark: firstActionGroup,
        width: actionInfo.rectWidth,
        height: actionInfo.rectHeight,
        onLayout(data) {
          positionGroupContents(firstActionGroup, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
        }
      });
    } else {
      const diamondResult = this.drawDiamondMark(startId, {}, { class: "activity__repeat-start" });
      startMark = diamondResult.mark;
      this.g.setNode(startId, {
        mark: startMark,
        width: diamondResult.diamondSide * 2,
        height: diamondResult.diamondSide * 2,
        onLayout(data) {
          diamondResult.moveDiamond(data.x, data.y);
        }
      });
    }
    result.startMark = startMark;
    this.g.setNode(endId, {
      id: endId,
      mark: group,
      width: rectWidth,
      height: rectHeight,
      onLayout(data) {
        positionGroupContents(group, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
      }
    });
    parentMark.children.push(group, startMark);
    group.children.push(decisionBg, textMark);
    const childrenResults = repeat.children.map((s, i2) => {
      const childResult = this.drawStep(parentMark, s);
      return childResult;
    });
    const firstChildResult = childrenResults[0];
    if (firstChildResult) {
      this.linkResult(startId, firstChildResult);
    }
    const lastChildResult = last(childrenResults);
    if (lastChildResult) {
      const hasEnded = lastChildResult.hasDetached || lastChildResult.hasEnded;
      this.g.setEdge(lastChildResult.endId || lastChildResult.id, endId, { isDummyEdge: hasEnded });
    }
    this.g.setEdge(endId, startId, { label: repeat.confirmLabel || "" });
    return result;
  }
  drawKeyword(parentMark, keyword) {
    const stepModel = model2.stepModelMap.get(keyword.id);
    const group = makeEmptyGroup();
    group.class = "activity__keyword";
    const { label, id: id9 } = keyword;
    const r = 10;
    const stroke = conf4.keywordBackground;
    const fill = conf4.keywordBackground;
    if (label === "start") {
      const bgMark = makeCircle({
        r,
        fill
      });
      group.children.push(bgMark);
    } else if (label === "stop" || label === "end") {
      const bgMark = makeCircle({
        r,
        stroke
      });
      const centerCircle = makeCircle({
        r: r * 0.6,
        fill
      });
      group.children.push(bgMark, centerCircle);
    }
    parentMark.children.push(group);
    this.g.setNode(id9, {
      id: id9,
      mark: group,
      width: r * 2,
      height: r * 2,
      onLayout(data) {
        positionGroupContents(group, { ...data, x: data.x, y: data.y });
      }
    });
    const hasDetached = isDetachAlikeKeyword(keyword);
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      hasEnded: isEndAlikeKeyword(keyword),
      hasDetached
    };
    return result;
  }
  drawFork(parentMark, fork) {
    const { id: id9 } = fork;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const startMark = makeMark("rect", {
      width: 100,
      height: 4,
      x: 0,
      y: 0,
      fill: conf4.keywordBackground,
      radius: 2
    });
    const getFrameBounds = () => {
      const bounds = this.g.node(frameId);
      return bounds;
    };
    const getBorderShrinkedWidth = (bounds) => {
      if (!bounds)
        return;
      const shrinkedWidth = bounds.width;
      const x2 = bounds.x;
      return { ...bounds, width: shrinkedWidth, x: x2 };
    };
    this.g.setNode(id9, {
      id: id9,
      mark: startMark,
      width: startMark.attrs.width,
      height: startMark.attrs.height,
      onLayout: (data) => {
        const fb = getBorderShrinkedWidth(getFrameBounds());
        if (fb) {
          safeAssign(startMark.attrs, { x: fb.x - fb.width / 2, y: data.y - data.height / 2, width: fb.width });
          data.width = fb.width;
        }
      }
    });
    const endId = stepModel.endId;
    const result = {
      id: id9,
      startMark,
      stepModel,
      endId
    };
    const frameId = stepModel.innerFrameId;
    this.g.setNode(frameId, {
      mark: group,
      width: 0
      // onLayout(data) {
      //   console.log('[drawFork] frame onLayout', data)
      // },
    });
    let endMark;
    if (!fork.shouldMerge) {
      endMark = makeMark("rect", {
        ...startMark.attrs
      });
      this.g.setNode(endId, {
        id: endId,
        mark: endMark,
        width: endMark.attrs.width,
        height: endMark.attrs.height,
        onLayout(data) {
          const fb = getBorderShrinkedWidth(getFrameBounds());
          if (fb) {
            safeAssign(endMark.attrs, { x: fb.x - fb.width / 2, y: data.y - data.height / 2, width: fb.width });
            data.width = fb.width;
          }
        }
      });
    } else {
      const { mark: diamondMark, diamondSide, moveDiamond } = this.drawDiamondMark(endId);
      endMark = diamondMark;
      this.g.setNode(endId, {
        id: endId,
        mark: endMark,
        width: endMark.attrs.width,
        height: endMark.attrs.height,
        onLayout(data) {
          const fb = getFrameBounds();
          if (fb) {
            moveDiamond(fb.x + diamondSide + 1, data.y);
          }
        }
      });
    }
    group.children.push(startMark);
    parentMark.children.push(group, endMark);
    fork.branches.map((branch) => {
      var _a;
      const childResult = this.drawStep(group, branch);
      const firstChildId = (_a = branch.value.children[0]) === null || _a === void 0 ? void 0 : _a.value.id;
      if (firstChildId) {
        this.g.setEdge(id9, firstChildId, {
          label: "",
          isForkStartStraightLine: true
        });
      }
      let hasEnded = false;
      const childrenIds = branch.value.children.map((o) => o.value.id);
      childrenIds.forEach((childId) => {
        if (hasEnded)
          return;
        const childStepModel = this.model.stepModelMap.get(childId);
        if (childStepModel && childStepModel.type === "keyword") {
          hasEnded = true;
        }
        this.g.setParent(childId, frameId);
      });
      this.g.setEdge(childResult.endId, endId, {
        label: "",
        isForkEndStraightLine: !fork.shouldMerge,
        isDummyEdge: hasEnded
      });
      return childResult;
    });
    return result;
  }
  drawForkBranch(parentMark, branch) {
    const { id: id9 } = branch;
    const group = makeEmptyGroup();
    const stepModel = model2.stepModelMap.get(id9);
    const result = {
      id: id9,
      startMark: group,
      stepModel,
      endId: ""
    };
    parentMark.children.push(group);
    const childResults = branch.children.map((step) => {
      const childResult = this.drawStep(parentMark, step);
      group.children.push(childResult.startMark);
      return childResult;
    });
    const lastChild = last(childResults);
    if (lastChild) {
      result.endId = lastChild.id;
    }
    return result;
  }
  drawNote(parentMark, note) {
    const { id: id9, text } = note;
    const group = makeMark("group", {
      x: 0,
      y: 0
    }, { children: [], class: "activity__note" });
    parentMark.children.push(group);
    const fontConfig = { fontSize: conf4.fontSize, fontFamily: conf4.fontFamily };
    const textDims = calcTextDims(text, fontConfig);
    const rectAttrs = getBaseNote(theme2);
    const noteModel = {
      width: textDims.width + 2 * conf4.noteMargin,
      height: textDims.height + 2 * conf4.noteMargin
    };
    const noteRect = {
      type: "rect",
      class: "note__bg",
      attrs: rectAttrs
    };
    const textMark = {
      type: "text",
      attrs: { fill: conf4.noteTextColor, text, textBaseline: "middle", ...fontConfig }
    };
    const targetStepModel = this.model.stepModelMap.get(note.target);
    if (targetStepModel) {
      if (targetStepModel.parentId) {
        this.g.setParent(targetStepModel.parentId, id9);
      }
    }
    this.g.setNode(id9, {
      mark: group,
      width: noteModel.width,
      height: noteModel.height,
      onLayout: () => {
        const targetNodeData = this.g.node(targetStepModel.id);
        let x2;
        if (note.placement === "left") {
          x2 = targetNodeData.x - targetNodeData.width / 2 - noteModel.width - conf4.noteMargin;
        } else {
          x2 = targetNodeData.x + targetNodeData.width / 2 + conf4.noteMargin;
        }
        const y2 = targetNodeData.y - targetNodeData.height / 2;
        safeAssign(textMark.attrs, {
          x: x2 + conf4.noteMargin,
          y: y2 + textDims.height / 2 + conf4.noteMargin,
          width: noteModel.width
        });
        safeAssign(rectAttrs, {
          x: x2,
          y: y2,
          width: noteModel.width,
          height: noteModel.height
        });
        const node2 = this.g.node(id9);
        node2.outerLeft = x2;
        node2.outerRight = x2 + noteModel.width;
      }
    });
    group.children.push(noteRect, textMark);
  }
};
function drawAction(parentMark, action, g) {
  const stepModel = model2.stepModelMap.get(action.id);
  const group = makeEmptyGroup();
  const { textMark, rectMark, actionInfo } = drawActionMarks({ message: action.message, conf: conf4 });
  const { rectWidth, rectHeight } = actionInfo;
  group.children.push(rectMark, textMark);
  g.setNode(action.id, {
    id: action.id,
    mark: group,
    width: rectWidth,
    height: rectHeight,
    onLayout(data) {
      positionGroupContents(group, { ...data, x: data.x - data.width / 2, y: data.y - data.height / 2 });
    }
  });
  parentMark.children.push(group);
  return {
    id: action.id,
    startMark: group,
    stepModel
  };
}
function drawActionMarks({ message, conf: conf6 }) {
  const fontConfig = getFontConfig3(conf6);
  const textDims = getTextDimensionsInPresicion(message, fontConfig);
  const actionInfo = getActionRectSize(message);
  const rectMark = makeMark("rect", {
    width: actionInfo.rectWidth,
    height: actionInfo.rectHeight,
    x: 0,
    y: 0,
    fill: conf6.actionBackground,
    stroke: conf6.actionBorderColor
  });
  const textMark = makeTextMark(conf6, message, textDims, {
    y: actionInfo.rectHeight / 2,
    x: actionInfo.rectWidth / 2,
    ...fontConfig,
    textBaseline: "middle",
    textAlign: "center"
  });
  return {
    rectMark,
    textMark,
    actionInfo
  };
}
function drawEdges(parent, g) {
  const edgeGroup = makeMark("group", {}, { children: [] });
  const bounds = makeBounds();
  g.edges().forEach((e) => {
    const edge = g.edge(e);
    if (!edge.points)
      return;
    updateBoundsByPoints(bounds, edge.points);
    if (edge.isDummyEdge)
      return;
    const [startPoint, ...restPoints] = edge.points;
    const lastPoint = restPoints[restPoints.length - 1];
    if (edge.isForkStartStraightLine) {
      edge.points.slice(0, edge.points.length - 2).forEach((p) => {
        safeAssign(p, {
          x: lastPoint.x
        });
      });
    } else if (edge.isForkEndStraightLine) {
      edge.points.slice(1).forEach((p) => {
        safeAssign(p, {
          x: startPoint.x
        });
      });
    }
    const shouldUseCurvePath = conf4.edgeType === "curved";
    const path4 = shouldUseCurvePath ? getPointsCurvePath(edge.points) : getPointsLinearPath(edge.points);
    const linePath = makeMark("path", {
      path: path4,
      stroke: conf4.edgeColor,
      lineJoin: "round"
    });
    const pointsForDirection = restPoints.slice(-2);
    const arrowRad = calcDirection.apply(null, pointsForDirection);
    const arrowMark = drawArrowTo(lastPoint, 8, arrowRad, {
      color: conf4.edgeColor
    });
    const labelPoint = edge.labelPoint || getPointAt(edge.points, 0.4, true);
    if (!labelPoint)
      return;
    const labelX = labelPoint.x;
    const labelY = labelPoint.y;
    let labelMark = null;
    let labelBgMark = null;
    if (edge.label) {
      const fontConfig = getFontConfig3(conf4);
      const labelDims = calcTextDims(edge.label, fontConfig);
      labelBgMark = makeLabelBg(labelDims, { x: labelX, y: labelY }, { fill: conf4.labelBackground }, theme2);
      labelMark = makeMark("text", {
        text: edge.label,
        id: [e.v, e.w].join("-"),
        textAlign: "center",
        textBaseline: "middle",
        x: labelX,
        y: labelY,
        fill: conf4.labelTextColor,
        ...fontConfig
      }, { class: "activity__edge-label" });
      const labelBounds = calcBound([labelBgMark]);
      tryExpandBounds(bounds, labelBounds);
    }
    edgeGroup.children.push(...compact([linePath, labelBgMark, labelMark, arrowMark]));
  });
  parent.children.push(edgeGroup);
  return { bounds };
}
function getFontConfig3(conf6) {
  return {
    fontSize: conf6.fontSize,
    fontFamily: conf6.fontFamily
  };
}
var artist_default4 = erArtist2;

// ../pintora-diagrams/lib/activity/parser/activityDiagram.js
var moo4 = __toESM(require_moo());
function id4(d) {
  return d[0];
}
var COLOR4 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE4 = /@param/;
var CONFIG_DIRECTIVE5 = /@config/;
var L_PAREN4 = /\(/;
var R_PAREN4 = /\)/;
function getTokenValue4(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement4(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue4(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE4 = /%%.*/;
var COMMON_TOKEN_RULES = {
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
};
var lexer4 = moo4.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: / +/, lineBreaks: false },
    QUOTED_WORD: QUOTED_WORD_REGEXP,
    COLOR: COLOR_REGEXP,
    SEMICOLON: /;/,
    COLON: /:/,
    ACTIVITY_DIAGRAM: /activityDiagram/,
    L_PAREN: L_PAREN_REGEXP,
    R_PAREN: R_PAREN_REGEXP,
    L_BRACKET: { match: /\{/ },
    R_BRACKET: { match: /\}/ },
    START_NOTE: textToCaseInsensitiveRegex("@note"),
    END_NOTE: textToCaseInsensitiveRegex("@end_note"),
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    ...configLexerMainState,
    VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
  },
  configStatement: {
    ...configLexerconfigStatementState,
    ...COMMON_TOKEN_RULES
  }
});
var yy4;
function setYY4(v) {
  yy4 = v;
}
function extractChildren(o) {
  return Array.isArray(o) ? o[0] : o;
}
var grammar4 = {
  Lexer: lexer4,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id4 },
    { "name": "color", "symbols": [COLOR4], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE4, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE4, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE5, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement4 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE5, L_PAREN4, "configOpenCloseStatement$ebnf$1", R_PAREN4], "postprocess": handleConfigOpenCloseStatement4 },
    { "name": "comment", "symbols": [COMMENT_LINE4], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"], "postprocess": (d) => d[1] },
    {
      "name": "start",
      "symbols": [lexer4.has("ACTIVITY_DIAGRAM") ? { type: "ACTIVITY_DIAGRAM" } : ACTIVITY_DIAGRAM, "document"],
      "postprocess": function(d) {
        return d[1];
      }
    },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "line"],
      "postprocess": (d) => {
        const r = d[0].concat(d[1]);
        return r;
      }
    },
    { "name": "line$ebnf$1", "symbols": [] },
    { "name": "line$ebnf$1", "symbols": ["line$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"], "postprocess": (d) => {
      return d[1];
    } },
    { "name": "line$ebnf$2", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": id4 },
    { "name": "line$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$2", lexer4.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement", "symbols": ["action"] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "start" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "stop" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "end" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "detach" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "kill" }] },
    {
      "name": "statement",
      "symbols": ["statement$subexpression$1", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const keyword = tv(d[0][0]);
        return {
          type: "keyword",
          label: keyword
        };
      }
    },
    { "name": "statement", "symbols": ["group"] },
    { "name": "statement", "symbols": ["conditionSentence"] },
    { "name": "statement", "symbols": ["repeatSentence"] },
    { "name": "statement", "symbols": ["whileSentence"] },
    { "name": "statement", "symbols": ["switchSentence"] },
    { "name": "statement", "symbols": ["forkSentence"] },
    { "name": "statement", "symbols": ["noteStatement"] },
    { "name": "statement", "symbols": ["arrowLabelStatement"] },
    { "name": "statement", "symbols": ["titleStatement"] },
    { "name": "statement", "symbols": ["paramStatement", "_", lexer4.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["configStatement", "_", lexer4.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["comment", "_", lexer4.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "conditionSentence$ebnf$1$subexpression$1", "symbols": ["_", "wordsInParens"] },
    { "name": "conditionSentence$ebnf$1", "symbols": ["conditionSentence$ebnf$1$subexpression$1"], "postprocess": id4 },
    { "name": "conditionSentence$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "conditionSentence$ebnf$2", "symbols": [] },
    { "name": "conditionSentence$ebnf$2", "symbols": ["conditionSentence$ebnf$2", "line"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "conditionSentence$ebnf$3", "symbols": ["elseClause"], "postprocess": id4 },
    { "name": "conditionSentence$ebnf$3", "symbols": [], "postprocess": () => null },
    {
      "name": "conditionSentence",
      "symbols": [{ "literal": "if" }, "wordsInParens", { "literal": "then" }, "conditionSentence$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "conditionSentence$ebnf$2", "conditionSentence$ebnf$3", "_", { "literal": "endif" }, "_", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const thenLabel = (d[3] ? d[3][1] : null) || "";
        const elseResult = d[6];
        return {
          type: "condition",
          message: d[1],
          then: { label: thenLabel, children: d[5].map((o) => Array.isArray(o) ? o[0] : o) },
          else: elseResult
        };
      }
    },
    { "name": "elseClause$ebnf$1", "symbols": [] },
    { "name": "elseClause$ebnf$1", "symbols": ["elseClause$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "elseClause$ebnf$2", "symbols": ["wordsInParens"], "postprocess": id4 },
    { "name": "elseClause$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "elseClause$ebnf$3", "symbols": [] },
    { "name": "elseClause$ebnf$3", "symbols": ["elseClause$ebnf$3", "line"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "elseClause",
      "symbols": ["elseClause$ebnf$1", { "literal": "else" }, "elseClause$ebnf$2", lexer4.has("NL") ? { type: "NL" } : NL, "elseClause$ebnf$3"],
      "postprocess": function(d) {
        return { label: d[2], children: d[4].map((o) => Array.isArray(o) ? o[0] : o) };
      }
    },
    { "name": "whileSentence$ebnf$1$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, { "literal": "is" }, lexer4.has("WS") ? { type: "WS" } : WS, "wordsInParens"] },
    { "name": "whileSentence$ebnf$1", "symbols": ["whileSentence$ebnf$1$subexpression$1"], "postprocess": id4 },
    { "name": "whileSentence$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "whileSentence$ebnf$2", "symbols": [] },
    { "name": "whileSentence$ebnf$2", "symbols": ["whileSentence$ebnf$2", "line"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "whileSentence$ebnf$3", "symbols": [] },
    { "name": "whileSentence$ebnf$3", "symbols": ["whileSentence$ebnf$3", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "whileSentence$ebnf$4$subexpression$1", "symbols": ["_", "wordsInParens"] },
    { "name": "whileSentence$ebnf$4", "symbols": ["whileSentence$ebnf$4$subexpression$1"], "postprocess": id4 },
    { "name": "whileSentence$ebnf$4", "symbols": [], "postprocess": () => null },
    { "name": "whileSentence$ebnf$5", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": id4 },
    { "name": "whileSentence$ebnf$5", "symbols": [], "postprocess": () => null },
    {
      "name": "whileSentence",
      "symbols": [{ "literal": "while" }, "wordsInParens", "whileSentence$ebnf$1", "_", lexer4.has("NL") ? { type: "NL" } : NL, "whileSentence$ebnf$2", "whileSentence$ebnf$3", { "literal": "endwhile" }, "whileSentence$ebnf$4", "whileSentence$ebnf$5", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const confirmLabel = d[2] ? d[2][3] : void 0;
        const denyLabel = d[8] ? d[8][1] : void 0;
        return {
          type: "while",
          message: d[1],
          confirmLabel,
          denyLabel,
          children: d[5].map((o) => Array.isArray(o) ? o[0] : o)
        };
      }
    },
    {
      "name": "repeatSentence",
      "symbols": [{ "literal": "repeat" }, lexer4.has("WS") ? { type: "WS" } : WS, "oneLineAction", "repeatBodyAndEnd"],
      "postprocess": function(d) {
        const firstAction = d[2].action;
        const bodyAndEnd = d[3];
        return {
          type: "repeat",
          firstAction,
          ...bodyAndEnd
        };
      }
    },
    { "name": "repeatSentence$ebnf$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": id4 },
    { "name": "repeatSentence$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "repeatSentence",
      "symbols": [{ "literal": "repeat" }, "repeatSentence$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "repeatBodyAndEnd"],
      "postprocess": function(d) {
        const bodyAndEnd = d[3];
        return {
          type: "repeat",
          ...bodyAndEnd
        };
      }
    },
    { "name": "repeatBodyAndEnd$ebnf$1", "symbols": [] },
    { "name": "repeatBodyAndEnd$ebnf$1", "symbols": ["repeatBodyAndEnd$ebnf$1", "line"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "repeatBodyAndEnd$ebnf$2", "symbols": [] },
    { "name": "repeatBodyAndEnd$ebnf$2", "symbols": ["repeatBodyAndEnd$ebnf$2", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "repeatBodyAndEnd$ebnf$3$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, { "literal": "is" }, lexer4.has("WS") ? { type: "WS" } : WS, "wordsInParens"] },
    { "name": "repeatBodyAndEnd$ebnf$3", "symbols": ["repeatBodyAndEnd$ebnf$3$subexpression$1"], "postprocess": id4 },
    { "name": "repeatBodyAndEnd$ebnf$3", "symbols": [], "postprocess": () => null },
    { "name": "repeatBodyAndEnd$ebnf$4$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, { "literal": "not" }, lexer4.has("WS") ? { type: "WS" } : WS, "wordsInParens"] },
    { "name": "repeatBodyAndEnd$ebnf$4", "symbols": ["repeatBodyAndEnd$ebnf$4$subexpression$1"], "postprocess": id4 },
    { "name": "repeatBodyAndEnd$ebnf$4", "symbols": [], "postprocess": () => null },
    { "name": "repeatBodyAndEnd$ebnf$5", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": id4 },
    { "name": "repeatBodyAndEnd$ebnf$5", "symbols": [], "postprocess": () => null },
    {
      "name": "repeatBodyAndEnd",
      "symbols": ["repeatBodyAndEnd$ebnf$1", "repeatBodyAndEnd$ebnf$2", { "literal": "repeatwhile" }, "wordsInParens", "repeatBodyAndEnd$ebnf$3", "repeatBodyAndEnd$ebnf$4", "repeatBodyAndEnd$ebnf$5", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const message = d[3];
        const confirmLabel = d[4] ? d[4][3] : void 0;
        const denyLabel = d[5] ? d[5][3] : void 0;
        return {
          message,
          confirmLabel,
          denyLabel,
          children: d[0].map((o) => Array.isArray(o) ? o[0] : o)
        };
      }
    },
    { "name": "switchSentence$ebnf$1", "symbols": [] },
    { "name": "switchSentence$ebnf$1", "symbols": ["switchSentence$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "switchSentence$ebnf$2", "symbols": [] },
    { "name": "switchSentence$ebnf$2$subexpression$1$ebnf$1", "symbols": [] },
    { "name": "switchSentence$ebnf$2$subexpression$1$ebnf$1", "symbols": ["switchSentence$ebnf$2$subexpression$1$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "switchSentence$ebnf$2$subexpression$1", "symbols": ["switchSentence$ebnf$2$subexpression$1$ebnf$1", "caseClause"] },
    { "name": "switchSentence$ebnf$2", "symbols": ["switchSentence$ebnf$2", "switchSentence$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "switchSentence$ebnf$3", "symbols": [] },
    { "name": "switchSentence$ebnf$3", "symbols": ["switchSentence$ebnf$3", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "switchSentence$ebnf$4", "symbols": [] },
    { "name": "switchSentence$ebnf$4", "symbols": ["switchSentence$ebnf$4", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "switchSentence",
      "symbols": [{ "literal": "switch" }, "wordsInParens", "switchSentence$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "switchSentence$ebnf$2", "switchSentence$ebnf$3", { "literal": "endswitch" }, "switchSentence$ebnf$4", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const message = d[1];
        const children = d[4].map((o) => o[1]);
        return { type: "switch", message, children };
      }
    },
    { "name": "caseClause$ebnf$1", "symbols": [] },
    { "name": "caseClause$ebnf$1", "symbols": ["caseClause$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "caseClause$ebnf$2", "symbols": [] },
    { "name": "caseClause$ebnf$2", "symbols": ["caseClause$ebnf$2", "line"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "caseClause",
      "symbols": [{ "literal": "case" }, "wordsInParens", "caseClause$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "caseClause$ebnf$2"],
      "postprocess": function(d) {
        const confirmLabel = d[1].trim();
        const children = d[4].map((o) => Array.isArray(o) ? o[0] : o);
        return { type: "case", confirmLabel, children };
      }
    },
    { "name": "forkSentence$ebnf$1", "symbols": [] },
    { "name": "forkSentence$ebnf$1", "symbols": ["forkSentence$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "forkSentence$ebnf$2$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, "statement"] },
    { "name": "forkSentence$ebnf$2", "symbols": ["forkSentence$ebnf$2$subexpression$1"] },
    { "name": "forkSentence$ebnf$2$subexpression$2", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, "statement"] },
    { "name": "forkSentence$ebnf$2", "symbols": ["forkSentence$ebnf$2", "forkSentence$ebnf$2$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "forkSentence$ebnf$3", "symbols": [] },
    { "name": "forkSentence$ebnf$3$subexpression$1", "symbols": ["_", "forkAgainClause"] },
    { "name": "forkSentence$ebnf$3", "symbols": ["forkSentence$ebnf$3", "forkSentence$ebnf$3$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "forkSentence$subexpression$1", "symbols": [{ "literal": "endfork" }] },
    { "name": "forkSentence$subexpression$1", "symbols": [{ "literal": "endmerge" }] },
    {
      "name": "forkSentence",
      "symbols": [{ "literal": "fork" }, "forkSentence$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "forkSentence$ebnf$2", "forkSentence$ebnf$3", "_", "forkSentence$subexpression$1", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const firstActions = d[3].map((a) => extractChildren(a[1]));
        const forkAgains = d[4].map((a) => a[1]);
        const branches = [{ type: "forkBranch", children: firstActions }, ...forkAgains];
        const endWord = tv(d[6][0]);
        const shouldMerge = endWord === "endmerge";
        return { type: "fork", shouldMerge, branches };
      }
    },
    { "name": "forkAgainClause$ebnf$1", "symbols": [] },
    { "name": "forkAgainClause$ebnf$1", "symbols": ["forkAgainClause$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "forkAgainClause$ebnf$2$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, "statement"] },
    { "name": "forkAgainClause$ebnf$2", "symbols": ["forkAgainClause$ebnf$2$subexpression$1"] },
    { "name": "forkAgainClause$ebnf$2$subexpression$2", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS, "statement"] },
    { "name": "forkAgainClause$ebnf$2", "symbols": ["forkAgainClause$ebnf$2", "forkAgainClause$ebnf$2$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "forkAgainClause",
      "symbols": [{ "literal": "forkagain" }, "forkAgainClause$ebnf$1", lexer4.has("NL") ? { type: "NL" } : NL, "forkAgainClause$ebnf$2"],
      "postprocess": function(d) {
        const statements = d[3].map((a) => extractChildren(a[1]));
        return { type: "forkBranch", children: statements };
      }
    },
    { "name": "wordsInParens", "symbols": [lexer4.has("L_PAREN") ? { type: "L_PAREN" } : L_PAREN4, "words", lexer4.has("R_PAREN") ? { type: "R_PAREN" } : R_PAREN4], "postprocess": (d) => d[1] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer4.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1$subexpression$1"] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer4.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$2", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": ["words$ebnf$1"],
      "postprocess": function(d) {
        return d[0].map((o) => tv(o[0])).join("");
      }
    },
    {
      "name": "action",
      "symbols": [lexer4.has("COLON") ? { type: "COLON" } : COLON, "multilineText", lexer4.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON, lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return { type: "addAction", action: { actionType: "normal", message: d[1] } };
      }
    },
    {
      "name": "oneLineAction",
      "symbols": [lexer4.has("COLON") ? { type: "COLON" } : COLON, "words", lexer4.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON, lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return { type: "addAction", action: { actionType: "normal", message: d[1] } };
      }
    },
    { "name": "multilineText$ebnf$1", "symbols": [] },
    { "name": "multilineText$ebnf$1$subexpression$1", "symbols": [lexer4.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "multilineText$ebnf$1$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS] },
    { "name": "multilineText$ebnf$1$subexpression$1", "symbols": [lexer4.has("NL") ? { type: "NL" } : NL] },
    { "name": "multilineText$ebnf$1", "symbols": ["multilineText$ebnf$1", "multilineText$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "multilineText",
      "symbols": ["multilineText$ebnf$1"],
      "postprocess": function(d) {
        const v = d[0].map((l) => {
          return l.map((o) => tv(o));
        }).join("");
        return v;
      }
    },
    { "name": "groupType", "symbols": [{ "literal": "group" }] },
    { "name": "groupType", "symbols": [{ "literal": "partition" }] },
    { "name": "group$ebnf$1$subexpression$1", "symbols": ["color", lexer4.has("WS") ? { type: "WS" } : WS] },
    { "name": "group$ebnf$1", "symbols": ["group$ebnf$1$subexpression$1"], "postprocess": id4 },
    { "name": "group$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "group$subexpression$1", "symbols": [lexer4.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD] },
    { "name": "group$subexpression$1", "symbols": [lexer4.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "group$ebnf$2$subexpression$1", "symbols": ["__", "statement"] },
    { "name": "group$ebnf$2", "symbols": ["group$ebnf$2$subexpression$1"] },
    { "name": "group$ebnf$2$subexpression$2", "symbols": ["__", "statement"] },
    { "name": "group$ebnf$2", "symbols": ["group$ebnf$2", "group$ebnf$2$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "group$ebnf$3", "symbols": [] },
    { "name": "group$ebnf$3", "symbols": ["group$ebnf$3", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "group$ebnf$4", "symbols": [] },
    { "name": "group$ebnf$4", "symbols": ["group$ebnf$4", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "group",
      "symbols": ["groupType", "__", "group$ebnf$1", "group$subexpression$1", "_", lexer4.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "group$ebnf$2", "group$ebnf$3", lexer4.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET, "group$ebnf$4", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const groupType = tv(d[0][0]);
        const background = d[2] ? d[2][0] : null;
        const titleToken = d[3][0];
        const title = titleToken.type === "QUOTED_WORD" ? getQuotedWord(titleToken).replace(/"(.*)"/, "$1") : tv(titleToken);
        const label = (title || groupType).trim();
        const name = (title || `${groupType}_${Date.now()}`).trim();
        const children = d[6].map((l) => l[1][0]).filter((o) => o);
        children.forEach((child) => child.parent = name);
        return { type: "group", name, groupType, label, background, children };
      }
    },
    { "name": "placement", "symbols": [{ "literal": "left" }], "postprocess": (d) => "left" },
    { "name": "placement", "symbols": [{ "literal": "right" }], "postprocess": (d) => "right" },
    { "name": "multilineNoteText$ebnf$1", "symbols": [] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer4.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer4.has("WS") ? { type: "WS" } : WS] },
    { "name": "multilineNoteText$ebnf$1$subexpression$1", "symbols": [lexer4.has("NL") ? { type: "NL" } : NL] },
    { "name": "multilineNoteText$ebnf$1", "symbols": ["multilineNoteText$ebnf$1", "multilineNoteText$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "multilineNoteText",
      "symbols": ["multilineNoteText$ebnf$1", lexer4.has("END_NOTE") ? { type: "END_NOTE" } : END_NOTE],
      "postprocess": function(d) {
        const v = d[0].map((l) => {
          return l.map((o) => tv(o));
        }).join("");
        let text = v;
        if (v[v.length - 1] === "\n") {
          text = v.slice(0, v.length - 1);
        }
        return text;
      }
    },
    { "name": "noteStatement$subexpression$1", "symbols": [{ "literal": "note" }] },
    { "name": "noteStatement$subexpression$1", "symbols": [lexer4.has("START_NOTE") ? { type: "START_NOTE" } : START_NOTE] },
    { "name": "noteStatement$ebnf$1", "symbols": [] },
    { "name": "noteStatement$ebnf$1", "symbols": ["noteStatement$ebnf$1", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "noteStatement",
      "symbols": ["noteStatement$subexpression$1", "noteStatement$ebnf$1", "placement", lexer4.has("COLON") ? { type: "COLON" } : COLON, "words", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const text = d[4].trim();
        return { type: "note", placement: d[2], text };
      }
    },
    { "name": "noteStatement$subexpression$2", "symbols": [{ "literal": "note" }] },
    { "name": "noteStatement$subexpression$2", "symbols": [lexer4.has("START_NOTE") ? { type: "START_NOTE" } : START_NOTE] },
    { "name": "noteStatement$ebnf$2", "symbols": [] },
    { "name": "noteStatement$ebnf$2", "symbols": ["noteStatement$ebnf$2", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "noteStatement$ebnf$3", "symbols": [] },
    { "name": "noteStatement$ebnf$3", "symbols": ["noteStatement$ebnf$3", lexer4.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "noteStatement",
      "symbols": ["noteStatement$subexpression$2", "noteStatement$ebnf$2", "placement", "noteStatement$ebnf$3", lexer4.has("NL") ? { type: "NL" } : NL, "multilineNoteText", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const text = d[5];
        return { type: "note", placement: d[2], text };
      }
    },
    {
      "name": "arrowLabelStatement",
      "symbols": [{ "literal": "->" }, "__", "words", lexer4.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON, "_", lexer4.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return { type: "arrowLabel", text: d[2] };
      }
    },
    { "name": "titleStatement", "symbols": [{ "literal": "title" }, lexer4.has("COLON") ? { type: "COLON" } : COLON, "words", lexer4.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => ({ type: "setTitle", text: d[2].trim() }) }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer4.has("WS") ? { type: "WS" } : WS] }
};
var activityDiagram_default = grammar4;

// ../pintora-diagrams/lib/activity/parser.js
setYY4(db4);
var parse4 = genParserWithRules(activityDiagram_default, {
  dedupeAmbigousResults: true,
  postProcess(results) {
    db4.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/activity/index.js
var activityDiagram = {
  pattern: /^\s*activityDiagram/,
  parser: {
    parse(text) {
      parse4(text);
      return db4.getDiagramIR();
    }
  },
  artist: artist_default4,
  configKey: "activity",
  clear() {
    db4.clear();
  }
};

// ../pintora-diagrams/lib/dot/db.js
var DOTDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.ACTION_HANDLERS = {
      overrideConfig(action) {
        this.addOverrideConfig(action);
      },
      addParam(action) {
        this.configParams.push(action);
      },
      addGraph(action) {
        function attrListToObject(list) {
          return list.reduce((acc, attr) => {
            acc[attr.id] = attr.eq;
            return acc;
          }, {});
        }
        function processGraph(graph) {
          const newGraph2 = { ...graph };
          const attrList = [];
          const childList = [];
          const attrsCollection = {};
          for (const child of newGraph2.children) {
            let newChild = child;
            switch (child.type) {
              case "attr_stmt": {
                const _child = child;
                const target = child.target || "graph";
                if ("attr_list" in _child) {
                  attrsCollection[target] = Object.assign(attrsCollection[target] || {}, attrListToObject(_child.attr_list));
                  newChild = null;
                }
                break;
              }
              case "node_stmt":
              case "edge_stmt": {
                const _child = child;
                if ("attr_list" in _child) {
                  child.attrs = attrListToObject(_child.attr_list);
                  delete _child.attr_list;
                }
                break;
              }
              case "subgraph": {
                newChild = processGraph(child);
                break;
              }
              case "attr": {
                attrList.push(child);
                newChild = null;
                break;
              }
            }
            if (newChild)
              childList.push(newChild);
          }
          newGraph2.children = childList;
          if (attrList.length) {
            attrsCollection.graph = Object.assign(attrsCollection.graph || {}, attrListToObject(attrList));
          }
          if (Object.keys(attrsCollection).length)
            newGraph2.attrs = attrsCollection;
          return newGraph2;
        }
        const newGraph = processGraph(action.graph);
        this.graph = newGraph;
      }
    };
  }
  getDiagramIR() {
    this.processAttrs();
    return {
      ...super.getBaseDiagramIR(),
      graph: this.graph
    };
  }
  processAttrs() {
  }
  apply(action) {
    if (!action)
      return;
    if (Array.isArray(action)) {
      action.forEach((a) => this.apply(a));
      return;
    }
    if (action.type in this.ACTION_HANDLERS) {
      this.ACTION_HANDLERS[action.type].call(this, action);
    }
  }
  clear() {
    super.clear();
    this.graph = void 0;
  }
};
var db5 = new DOTDb();
var db_default4 = db5;

// ../pintora-diagrams/lib/dot/artist/draw-node.js
var SHAPE_MAP = {
  ellipse: "ellipse",
  circle: "circle"
};
function drawNodeShape(context) {
  const { data, shape, textDims, markAttrs } = context;
  const flooredGeom = floorValues(TRANSFORM_GRAPH.graphNodeToRectStart(data));
  if (shape) {
    const mappedShape = SHAPE_MAP[shape];
    const symbolDef = symbolRegistry.get(mappedShape || shape);
    if (symbolDef) {
      const contentArea = {
        x: data.x,
        y: data.y,
        width: textDims.width,
        height: textDims.height
      };
      const sym = symbolRegistry.create(shape, {
        mode: "container",
        attrs: markAttrs,
        contentArea
      });
      return {
        containerNode: sym
      };
    }
  }
  const nodeRect = makeMark("rect", {
    ...flooredGeom,
    ...markAttrs
  });
  if (shape === "plaintext") {
    nodeRect.attrs.fill = "transparent";
    nodeRect.attrs.stroke = "transparent";
  }
  return {
    containerNode: nodeRect
  };
}

// ../pintora-diagrams/lib/dot/artist/style-context.js
var StyleContext = class _StyleContext {
  constructor() {
    this.values = {};
  }
  setParent(c) {
    this.parent = c;
  }
  /** Spawn a child context */
  spawn() {
    const child = new _StyleContext();
    child.setParent(this);
    return child;
  }
  getValue(key) {
    const result = this.resolve(key);
    if (result.resolved) {
      return result.value;
    }
    return void 0;
  }
  set(key, v) {
    this.values[key] = { v };
  }
  setValues(obj) {
    for (const [k, v] of Object.entries(obj)) {
      this.set(k, v);
    }
  }
  resolve(key) {
    let current = this;
    while (current) {
      if (current.values[key]) {
        return {
          resolved: true,
          value: current.values[key].v
        };
      }
      current = current.parent;
    }
    return {
      resolved: false,
      value: void 0
    };
  }
};

// ../pintora-diagrams/lib/dot/artist/const.js
var DEFAULT_LINE_WIDTH = 1;
var BOLD_LINE_WIDTH = 2;
var DASHED_LINE_DASH = [5, 5];
var DOTTED_LINE_DASH = [2, 4];

// ../pintora-diagrams/lib/dot/config.js
var defaultConfig5 = {
  diagramPadding: 15,
  layoutDirection: "TB",
  ranksep: 20,
  nodesep: 20,
  edgesep: 10,
  edgeType: "polyline",
  nodePadding: 8,
  nodeBorderRadius: 2,
  backgroundColor: PALETTE.white,
  labelTextColor: PALETTE.normalDark,
  nodeBorderColor: PALETTE.normalDark,
  edgeColor: PALETTE.normalDark,
  fontSize: 14,
  fontWeight: "normal",
  fontFamily: DEFAULT_FONT_FAMILY
};
var DOT_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig5)
};
var configKey5 = "dot";
var configurator5 = makeConfigurator({
  defaultConfig: defaultConfig5,
  configKey: configKey5,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(DOT_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    return {
      backgroundColor: t.canvasBackground,
      labelTextColor: t.textColor,
      nodeBorderColor: t.primaryLineColor,
      edgeColor: t.primaryLineColor
    };
  }
});
var getConf5 = configurator5.getConfig;

// ../pintora-diagrams/lib/dot/artist.js
var StyleContexts = class _StyleContexts {
  constructor() {
    this.node = new StyleContext();
    this.edge = new StyleContext();
    this.graph = new StyleContext();
  }
  spawn() {
    const childContexts = new _StyleContexts();
    childContexts.node.setParent(this.node);
    childContexts.edge.setParent(this.edge);
    childContexts.graph.setParent(this.graph);
    return childContexts;
  }
  update(input) {
    if (input.graph)
      this.graph.setValues(input.graph);
    if (input.node)
      this.node.setValues(input.node);
    if (input.edge)
      this.edge.setValues(input.edge);
  }
};
var artist = makeArtist({
  draw(ir, config2, opts) {
    const conf6 = getConf5(ir, config2);
    const rootMark = makeEmptyGroup();
    const dotDraw = new DOTDraw(ir, conf6, rootMark);
    const drawResult = dotDraw.draw();
    const gBounds = dotDraw.dagreWrapper.getGraphBounds();
    let { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds,
      padX: conf6.diagramPadding,
      padY: conf6.diagramPadding
    });
    if (drawResult) {
      if (drawResult.labelHeight) {
        height += drawResult.labelHeight;
      }
      if (drawResult.frameRect) {
        const frameAttrs = drawResult.frameRect.attrs;
        safeAssign(frameAttrs, {
          width: width2,
          height,
          x: -conf6.diagramPadding,
          y: -conf6.diagramPadding
        });
      }
    }
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
});
var DOTDraw = class {
  constructor(ir, conf6, rootMark) {
    this.ir = ir;
    this.conf = conf6;
    this.rootMark = rootMark;
    this.drawnNodeIds = /* @__PURE__ */ new Set();
    this.edgeNodeIds = /* @__PURE__ */ new Set();
    this.subgraphs = /* @__PURE__ */ new Map();
    if (isDev) {
      ;
      window.dotDraw = this;
    }
    this.g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: true
    }).setGraph({
      rankdir: conf6.layoutDirection,
      nodesep: conf6.nodesep,
      edgesep: conf6.edgesep,
      ranksep: conf6.ranksep,
      splines: getGraphSplinesOption(conf6.edgeType)
    });
    this.dagreWrapper = new DagreWrapper(this.g);
  }
  draw() {
    const irGraph = this.ir.graph;
    if (!irGraph)
      return;
    const dagreWrapper = this.dagreWrapper;
    const parentInfo = {
      id: irGraph.id,
      mark: this.rootMark,
      isRoot: true,
      styleContexts: new StyleContexts()
    };
    this.updateSubgraphMap();
    this.drawGraphAlike(irGraph, parentInfo);
    for (const edgeNodeId of this.edgeNodeIds) {
      if (!this.drawnNodeIds.has(edgeNodeId)) {
        this.drawNode(edgeNodeId, {}, parentInfo);
        this.g.setParent(edgeNodeId, parentInfo.id);
      }
    }
    dagreWrapper.doLayout();
    dagreWrapper.callNodeOnLayout();
    dagreWrapper.callEdgeOnLayout();
    return this.drawOutmostFrame(parentInfo);
  }
  updateSubgraphMap() {
    const irGraph = this.ir.graph;
    this.subgraphs = /* @__PURE__ */ new Map();
    const dfs2 = (stmt) => {
      if (stmt.type === "subgraph") {
        this.subgraphs.set(stmt.id, stmt);
        for (const child of stmt.children) {
          dfs2(child);
        }
      }
    };
    for (const child of irGraph.children) {
      dfs2(child);
    }
  }
  drawGraphAlike(irGraph, parentInfo) {
    var _a;
    if (irGraph.attrs) {
      parentInfo.styleContexts.update(irGraph.attrs);
    }
    const conf6 = this.conf;
    const graphContext = parentInfo.styleContexts.graph;
    const fontConfig = this.getFontConfig(graphContext);
    const graphAttrs2 = ((_a = irGraph.attrs) === null || _a === void 0 ? void 0 : _a.graph) || {};
    const graphLabel = graphAttrs2.label;
    if (parentInfo.isRoot) {
      this.g.setNode(irGraph.id, {});
    } else {
      let minwidth = 0;
      let paddingt = 0;
      if (graphLabel) {
        const dims = calculateTextDimensions(graphLabel, fontConfig);
        minwidth = dims.width + fontConfig.fontSize;
        paddingt = dims.height;
      }
      this.g.setNode(irGraph.id, {
        minwidth,
        paddingt,
        onLayout(data) {
          const rectGeometry = floorValues(TRANSFORM_GRAPH.graphNodeToRectStart(data));
          const graphStyle = graphAttrMapper(graphAttrs2, graphContext);
          const subGraphRect = makeMark("rect", {
            ...rectGeometry,
            stroke: conf6.nodeBorderColor,
            ...graphStyle
          });
          parentInfo.mark.children.unshift(subGraphRect);
          if (graphLabel) {
            const labelPoint = { x: data.x, y: data.y - data.height / 2 };
            const labelMark = makeTextAtPoint(graphLabel, labelPoint, {
              textBaseline: "hanging",
              ...fontConfig,
              fill: conf6.labelTextColor,
              ...graphLabelAttrMapper(graphAttrs2, graphContext)
            });
            parentInfo.mark.children.push(labelMark);
          }
        }
      });
    }
    irGraph.children.forEach((child) => {
      switch (child.type) {
        case "node_stmt": {
          this.drawNodeStmt(child, parentInfo);
          break;
        }
        case "edge_stmt": {
          this.drawEdgeStmt(child, parentInfo);
          break;
        }
        case "subgraph": {
          const childGroup = makeEmptyGroup();
          parentInfo.mark.children.push(childGroup);
          const newParentInfo = {
            id: child.id,
            mark: childGroup,
            styleContexts: parentInfo.styleContexts.spawn(),
            parentId: parentInfo.id
          };
          this.drawGraphAlike(child, newParentInfo);
          this.g.setParent(child.id, irGraph.id);
          break;
        }
      }
    });
  }
  drawNodeStmt(stmt, parentInfo) {
    const { nodeId } = stmt;
    this.g.setParent(nodeId.id, parentInfo.id);
    this.drawNode(nodeId.id, stmt.attrs, parentInfo);
    this.drawnNodeIds.add(nodeId.id);
  }
  drawNode(name, nodeAttrs = {}, parentInfo) {
    const subgraphWithName = this.subgraphs.get(name);
    const isSubgraph = Boolean(subgraphWithName);
    if (isSubgraph)
      return;
    const label = nodeAttrs.label || name;
    const nodeStyleContext = parentInfo.styleContexts.node;
    const fontConfig = this.getFontConfig(nodeStyleContext);
    const textDims = getTextDimensionsInPresicion(label, fontConfig);
    const width2 = textDims.width + this.conf.nodePadding * 2;
    const height = textDims.height + this.conf.nodePadding * 2;
    const layoutAttrs = nodeLayoutAttrMapper(nodeAttrs, nodeStyleContext);
    this.g.setNode(name, {
      width: width2,
      height,
      ...layoutAttrs,
      onLayout: (data) => {
        const shape = nodeAttrs.shape || nodeStyleContext.getValue("shape");
        const edgeStyle = nodeAttrs.style || nodeStyleContext.getValue("style");
        let lineDash = null;
        let lineWidth = DEFAULT_LINE_WIDTH;
        if (edgeStyle === "dashed") {
          lineDash = DASHED_LINE_DASH.slice();
        } else if (edgeStyle === "dotted") {
          lineDash = DOTTED_LINE_DASH.slice();
        } else if (edgeStyle === "bold") {
          lineWidth = BOLD_LINE_WIDTH;
        }
        const nodeShapeResult = drawNodeShape({
          data,
          shape,
          textDims,
          markAttrs: {
            stroke: this.conf.nodeBorderColor,
            radius: this.conf.nodeBorderRadius,
            lineDash,
            lineWidth,
            ...nodeAttrsToStyle(nodeAttrs, nodeStyleContext)
          }
        });
        const textMark = makeMark("text", {
          text: label,
          x: data.x,
          y: data.y,
          fill: this.conf.labelTextColor,
          ...fontConfig,
          ...nodeAttrsToLabelStyle(nodeAttrs, nodeStyleContext),
          textAlign: "center",
          textBaseline: "middle"
        });
        parentInfo.mark.children.push(nodeShapeResult.containerNode, textMark);
      }
    });
  }
  drawEdgeStmt(stmt, parentInfo) {
    const { edge_list, attrs = {} } = stmt;
    const tuples = zipTuple(edge_list.slice(0, edge_list.length - 1), edge_list.slice(1));
    const edgeGroup = makeEmptyGroup();
    const graphAttrs2 = graphAttrMapper({}, parentInfo.styleContexts.graph);
    parentInfo.mark.children.push(edgeGroup);
    const isDirected = this.ir.graph.type === "digraph";
    tuples.forEach(([v1, v2]) => {
      this.edgeNodeIds.add(v1.id);
      this.edgeNodeIds.add(v2.id);
      const conf6 = this.conf;
      this.g.setEdge(v1.id, v2.id, {
        onLayout: (edge) => {
          const edgeStyleContext = parentInfo.styleContexts.edge;
          const edgeStyle = attrs.style || edgeStyleContext.getValue("style");
          const isInvisible = edgeStyle === "invis";
          if (isInvisible)
            return;
          const shouldUseCurvePath = this.conf.edgeType === "curved";
          const path4 = shouldUseCurvePath ? getPointsCurvePath(edge.points) : getPointsLinearPath(edge.points);
          const pathAttrs = edgeAttrsToStyle(attrs, edgeStyleContext);
          let lineDash = null;
          let lineWidth = DEFAULT_LINE_WIDTH;
          if (edgeStyle === "dashed") {
            lineDash = DASHED_LINE_DASH.slice();
          } else if (edgeStyle === "dotted") {
            lineDash = DOTTED_LINE_DASH.slice();
          } else if (edgeStyle === "bold") {
            lineWidth = BOLD_LINE_WIDTH;
          }
          const pathMark = makeMark("path", {
            path: path4,
            stroke: conf6.edgeColor,
            lineDash,
            lineWidth,
            ...pathAttrs
          });
          edgeGroup.children.push(pathMark);
          if (isDirected) {
            const lastPoint = last(edge.points);
            const arrowDirection = calcDirection(edge.points[edge.points.length - 2], lastPoint);
            const arrowHeadType = attrs.arrowhead || edgeStyleContext.getValue("arrowhead") || "normal";
            const arrowMark = drawArrowTo(last(edge.points), 8, arrowDirection, {
              type: ARROW_TYPE_MAP[arrowHeadType] || "triangle",
              color: pathAttrs.stroke || conf6.edgeColor,
              bgColor: graphAttrs2.fill || this.conf.backgroundColor
            });
            edgeGroup.children.push(arrowMark);
          }
          const anchorPoint = edge.labelPoint || edge.points[1];
          if (attrs.label) {
            const textColor = attrs.fontcolor || this.conf.labelTextColor;
            const labelMark = makeMark("text", {
              text: attrs.label,
              id: [v1.id, v2.id].join("-"),
              textAlign: "center",
              textBaseline: "middle",
              ...anchorPoint,
              fill: textColor,
              ...this.getFontConfig(edgeStyleContext)
            }, { class: "activity__edge-label" });
            edgeGroup.children.push(labelMark);
          }
        }
      });
    });
  }
  /**
   * this should be call after all layout are done,
   *   so we can position label by current bounds
   */
  drawOutmostFrame(parentInfo) {
    var _a;
    const irGraph = this.ir.graph;
    if (!((_a = irGraph.attrs) === null || _a === void 0 ? void 0 : _a.graph))
      return;
    const graphAttrs2 = irGraph.attrs.graph;
    const conf6 = this.conf;
    const bounds = this.dagreWrapper.getGraphBounds();
    let frameRect;
    const graphContext = parentInfo.styleContexts.graph;
    if (graphAttrs2.bgcolor) {
      const rectGeometry = bounds;
      const graphStyle = graphAttrMapper(graphAttrs2, graphContext);
      frameRect = makeMark("rect", {
        ...pick(rectGeometry, ["width", "height"]),
        ...graphStyle,
        stroke: "transparent"
      }, { class: "dot__frame-bg" });
      parentInfo.mark.children.unshift(frameRect);
    }
    const label = graphAttrs2.label;
    let labelHeight = 0;
    if (label) {
      const fontConfig = this.getFontConfig(graphContext);
      const labelPoint = { x: bounds.left + bounds.width / 2, y: bounds.bottom };
      labelHeight = calculateTextDimensions(label, fontConfig).height;
      const labelMark = makeTextAtPoint(label, labelPoint, {
        textBaseline: "hanging",
        ...fontConfig,
        fill: conf6.labelTextColor,
        ...graphLabelAttrMapper(graphAttrs2, graphContext)
      });
      parentInfo.mark.children.push(labelMark);
    }
    return {
      labelHeight,
      frameRect
    };
  }
  getFontConfig(styleContext) {
    const fontsizeStr = styleContext === null || styleContext === void 0 ? void 0 : styleContext.getValue("fontsize");
    return {
      fontSize: fontsizeStr && parseFloat(fontsizeStr) || this.conf.fontSize,
      fontFamily: (styleContext === null || styleContext === void 0 ? void 0 : styleContext.getValue("fontname")) || this.conf.fontFamily,
      fontWeight: this.conf.fontWeight
    };
  }
};
function zipTuple(arr1, arr2) {
  const output = [];
  for (let i2 = 0; i2 < arr1.length; i2++) {
    if (i2 < arr2.length) {
      output.push([arr1[i2], arr2[i2]]);
    }
  }
  return output;
}
function makeAttrMapper(mapping) {
  return (input, styleContext) => {
    const attrs = {};
    for (const [nodeKey, attrKey] of Object.entries(mapping)) {
      const v = input[nodeKey] || (styleContext === null || styleContext === void 0 ? void 0 : styleContext.getValue(nodeKey));
      if (v) {
        attrs[attrKey] = v;
      }
    }
    return attrs;
  };
}
var NODE_ATTR_MAP = {
  color: "stroke",
  bgcolor: "fill"
};
var nodeAttrMapper = makeAttrMapper(NODE_ATTR_MAP);
function nodeAttrsToStyle(nodeAttrs, styleContext) {
  const attrs = nodeAttrMapper(nodeAttrs, styleContext);
  return attrs;
}
var NODE_LABEL_ATTR_MAP = {
  fontcolor: "fill"
};
var nodeLabelAttrMapper = makeAttrMapper(NODE_LABEL_ATTR_MAP);
function nodeAttrsToLabelStyle(nodeAttrs, styleContext) {
  const attrs = nodeLabelAttrMapper(nodeAttrs, styleContext);
  return attrs;
}
var nodeLayoutAttrMapper = makeAttrMapper({
  margint: "margint",
  marginb: "marginb",
  marginl: "marginl",
  marginr: "marginr"
});
var EDGE_ATTR_MAP = {
  color: "stroke"
};
var edgeAttrMapper = makeAttrMapper(EDGE_ATTR_MAP);
function edgeAttrsToStyle(edgeAttrs2, styleContext) {
  const attrs = edgeAttrMapper(edgeAttrs2, styleContext);
  return attrs;
}
var GRAPH_ATTR_MAP = {
  color: "stroke",
  bgcolor: "fill"
};
var graphAttrMapper = makeAttrMapper(GRAPH_ATTR_MAP);
var graphLabelAttrMapper = makeAttrMapper({
  ...NODE_LABEL_ATTR_MAP
});
var ARROW_TYPE_MAP = {
  normal: "triangle",
  box: "box",
  obox: "obox",
  dot: "dot",
  odot: "odot",
  open: "default",
  diamond: "diamond",
  ediamond: "ediamond"
};
var artist_default5 = artist;

// ../pintora-diagrams/lib/dot/parser/dotDiagram.js
var moo5 = __toESM(require_moo());
function id5(d) {
  return d[0];
}
var COLOR5 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE5 = /@param/;
var CONFIG_DIRECTIVE6 = /@config/;
var L_PAREN5 = /\(/;
var R_PAREN5 = /\)/;
function getTokenValue5(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement5(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue5(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE5 = /%%.*/;
var COMMON_TOKEN_RULES2 = {
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
};
var lexer5 = moo5.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: /[ \t]+/, lineBreaks: false },
    QUOTED_WORD: QUOTED_WORD_REGEXP,
    COLOR: COLOR_REGEXP,
    SEMICOLON: /;/,
    COLON: /:/,
    COMMA: /,/,
    DOT_DIAGRAM: /dotDiagram/,
    L_PAREN: L_PAREN_REGEXP,
    R_PAREN: R_PAREN_REGEXP,
    L_BRACKET: { match: /\{/ },
    R_BRACKET: { match: /\}/ },
    L_SQ_BRACKET: { match: /\[/ },
    R_SQ_BRACKET: { match: /\]/ },
    EQ: { match: /=/ },
    SUBGRAPH: { match: /subgraph/ },
    START_NOTE: textToCaseInsensitiveRegex("@note"),
    END_NOTE: textToCaseInsensitiveRegex("@end_note"),
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    DOT_SLASH_COMMENT: /\/\/.*/,
    DOT_BLOCK_COMMENT_START: { match: /\/\*/, push: "blockComment" },
    ...configLexerMainState,
    VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
  },
  configStatement: {
    ...configLexerconfigStatementState,
    ...COMMON_TOKEN_RULES2
  },
  blockComment: {
    DOT_BLOCK_COMMENT_END: { match: /\*\//, pop: 1 },
    ANY_COMMENT_TEXT: { match: /(?:\s\w\d\n\r)+(?!\*\/)/, fallback: true }
  }
});
function rNull() {
  return null;
}
var grammar5 = {
  Lexer: lexer5,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id5 },
    { "name": "color", "symbols": [COLOR5], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE5, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE5, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE6, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement5 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE6, L_PAREN5, "configOpenCloseStatement$ebnf$1", R_PAREN5], "postprocess": handleConfigOpenCloseStatement5 },
    { "name": "comment", "symbols": [COMMENT_LINE5], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"], "postprocess": (d) => d[1] },
    {
      "name": "start",
      "symbols": [lexer5.has("DOT_DIAGRAM") ? { type: "DOT_DIAGRAM" } : DOT_DIAGRAM, "document"],
      "postprocess": function(d) {
        return d[1];
      }
    },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "statementWrap"],
      "postprocess": (d) => {
        let r = d[0];
        if (d[1]) {
          r = d[0].concat(d[1]);
        }
        return r;
      }
    },
    { "name": "statementWrap$ebnf$1", "symbols": [] },
    { "name": "statementWrap$ebnf$1", "symbols": ["statementWrap$ebnf$1", lexer5.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "statementWrap", "symbols": ["statementWrap$ebnf$1", "statement"], "postprocess": (d) => {
      return d[1];
    } },
    { "name": "statementWrap$ebnf$2", "symbols": [lexer5.has("WS") ? { type: "WS" } : WS], "postprocess": id5 },
    { "name": "statementWrap$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "statementWrap", "symbols": ["statementWrap$ebnf$2", "dotCommentSegment", lexer5.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statementWrap$ebnf$3", "symbols": [lexer5.has("WS") ? { type: "WS" } : WS], "postprocess": id5 },
    { "name": "statementWrap$ebnf$3", "symbols": [], "postprocess": () => null },
    { "name": "statementWrap", "symbols": ["statementWrap$ebnf$3", lexer5.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "graph" }] },
    { "name": "statement$subexpression$1", "symbols": [{ "literal": "digraph" }] },
    { "name": "statement$ebnf$1", "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": id5 },
    { "name": "statement$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "statement$ebnf$2", "symbols": [lexer5.has("NL") ? { type: "NL" } : NL], "postprocess": id5 },
    { "name": "statement$ebnf$2", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["statement$subexpression$1", "statement$ebnf$1", lexer5.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "statement$ebnf$2", "stmtList", lexer5.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET],
      "postprocess": function(d) {
        const children = d[4];
        const id9 = d[1] ? tv(d[1]) : "";
        const action = {
          type: "addGraph",
          graph: {
            type: tv(d[0][0]),
            id: id9,
            children
          }
        };
        return action;
      }
    },
    { "name": "statement", "symbols": ["paramStatement", lexer5.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["configOpenCloseStatement", lexer5.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["comment", lexer5.has("NL") ? { type: "NL" } : NL] },
    { "name": "dotCommentSegment", "symbols": [lexer5.has("DOT_SLASH_COMMENT") ? { type: "DOT_SLASH_COMMENT" } : DOT_SLASH_COMMENT], "postprocess": rNull },
    { "name": "dotCommentSegment$ebnf$1", "symbols": [] },
    { "name": "dotCommentSegment$ebnf$1", "symbols": ["dotCommentSegment$ebnf$1", lexer5.has("ANY_COMMENT_TEXT") ? { type: "ANY_COMMENT_TEXT" } : ANY_COMMENT_TEXT], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "dotCommentSegment", "symbols": [lexer5.has("DOT_BLOCK_COMMENT_START") ? { type: "DOT_BLOCK_COMMENT_START" } : DOT_BLOCK_COMMENT_START, "dotCommentSegment$ebnf$1", lexer5.has("DOT_BLOCK_COMMENT_END") ? { type: "DOT_BLOCK_COMMENT_END" } : DOT_BLOCK_COMMENT_END], "postprocess": rNull },
    { "name": "stmtList$subexpression$1", "symbols": [lexer5.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON] },
    { "name": "stmtList$subexpression$1", "symbols": [lexer5.has("NL") ? { type: "NL" } : NL] },
    { "name": "stmtList$ebnf$1", "symbols": ["stmtList"], "postprocess": id5 },
    { "name": "stmtList$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "stmtList",
      "symbols": ["dotStmt", "stmtList$subexpression$1", "_", "stmtList$ebnf$1"],
      "postprocess": function(d) {
        const stmtList = d[3] || [];
        const stmt = d[0][0];
        if (!stmt)
          return stmtList;
        return [stmt, ...stmtList];
      }
    },
    { "name": "dotStmt", "symbols": ["attrStmt"] },
    { "name": "dotStmt", "symbols": ["nodeStmt"] },
    { "name": "dotStmt", "symbols": ["edgeStmt"] },
    { "name": "dotStmt", "symbols": ["singleAttrStmt"] },
    { "name": "dotStmt", "symbols": ["subgraph"] },
    { "name": "dotStmt", "symbols": ["dotCommentSegment"], "postprocess": null },
    { "name": "dotStmt", "symbols": ["comment"], "postprocess": null },
    { "name": "attrStmt$subexpression$1", "symbols": [{ "literal": "graph" }] },
    { "name": "attrStmt$subexpression$1", "symbols": [{ "literal": "node" }] },
    { "name": "attrStmt$subexpression$1", "symbols": [{ "literal": "edge" }] },
    {
      "name": "attrStmt",
      "symbols": ["attrStmt$subexpression$1", "__", "attrList"],
      "postprocess": function(d) {
        const target = tv(d[0][0]);
        const attr_list = d[2];
        return {
          type: "attr_stmt",
          target,
          attr_list
        };
      }
    },
    { "name": "singleAttrStmt$subexpression$1", "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "singleAttrStmt$subexpression$1", "symbols": [lexer5.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD] },
    { "name": "singleAttrStmt$ebnf$1$subexpression$1", "symbols": [lexer5.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON] },
    { "name": "singleAttrStmt$ebnf$1$subexpression$1", "symbols": [lexer5.has("COMMA") ? { type: "COMMA" } : COMMA] },
    { "name": "singleAttrStmt$ebnf$1", "symbols": ["singleAttrStmt$ebnf$1$subexpression$1"], "postprocess": id5 },
    { "name": "singleAttrStmt$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "singleAttrStmt",
      "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer5.has("EQ") ? { type: "EQ" } : EQ, "singleAttrStmt$subexpression$1", "singleAttrStmt$ebnf$1"],
      "postprocess": function(d) {
        const id9 = tv(d[0]);
        const eqValToken = d[2][0];
        const eq4 = eqValToken.type === "QUOTED_WORD" ? getQuotedWord(eqValToken) : tv(eqValToken);
        const attr = {
          type: "attr",
          id: id9,
          eq: eq4
        };
        return attr;
      }
    },
    { "name": "nodeStmt$ebnf$1", "symbols": ["attrList"], "postprocess": id5 },
    { "name": "nodeStmt$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "nodeStmt",
      "symbols": ["nodeId", "nodeStmt$ebnf$1"],
      "postprocess": function(d) {
        const nodeStmt = {
          type: "node_stmt",
          nodeId: d[0]
        };
        if (d[1]) {
          nodeStmt.attr_list = d[1];
        }
        return nodeStmt;
      }
    },
    {
      "name": "nodeStmt",
      "symbols": ["nodeId", lexer5.has("L_SQ_BRACKET") ? { type: "L_SQ_BRACKET" } : L_SQ_BRACKET, lexer5.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD, lexer5.has("R_SQ_BRACKET") ? { type: "R_SQ_BRACKET" } : R_SQ_BRACKET],
      "postprocess": function(d) {
        const nodeId = d[0];
        const label = getQuotedWord(d[2]);
        return {
          type: "node_stmt",
          nodeId: d[0],
          attrs: {
            label
          }
        };
      }
    },
    {
      "name": "nodeStmt",
      "symbols": ["nodeId"],
      "postprocess": function(d) {
        const nodeId = d[0];
        return {
          type: "node_stmt",
          nodeId: d[0]
        };
      }
    },
    { "name": "edgeStmt$ebnf$1", "symbols": ["attrList"], "postprocess": id5 },
    { "name": "edgeStmt$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "edgeStmt",
      "symbols": ["nodeId", "edgeRHS", "edgeStmt$ebnf$1"],
      "postprocess": function(d) {
        const startNode = d[0];
        const edge_list = [startNode, ...d[1]];
        const edgeStmt = {
          type: "edge_stmt",
          edge_list
        };
        if (d[2]) {
          edgeStmt.attr_list = d[2];
        }
        return edgeStmt;
      }
    },
    { "name": "edgeRHS$ebnf$1", "symbols": [lexer5.has("WS") ? { type: "WS" } : WS], "postprocess": id5 },
    { "name": "edgeRHS$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "edgeRHS$ebnf$2", "symbols": ["edgeRHS"], "postprocess": id5 },
    { "name": "edgeRHS$ebnf$2", "symbols": [], "postprocess": () => null },
    {
      "name": "edgeRHS",
      "symbols": ["edgeop", "edgeRHS$ebnf$1", "nodeId", "edgeRHS$ebnf$2"],
      "postprocess": function(d) {
        const edgeList = d[3] || [];
        const edge = d[2];
        return [edge, ...edgeList];
      }
    },
    { "name": "edgeop", "symbols": [{ "literal": "->" }] },
    { "name": "edgeop", "symbols": [{ "literal": "--" }] },
    { "name": "attrList$ebnf$1", "symbols": ["attrList"], "postprocess": id5 },
    { "name": "attrList$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "attrList",
      "symbols": [lexer5.has("L_SQ_BRACKET") ? { type: "L_SQ_BRACKET" } : L_SQ_BRACKET, "attrItems", lexer5.has("R_SQ_BRACKET") ? { type: "R_SQ_BRACKET" } : R_SQ_BRACKET, "attrList$ebnf$1"],
      "postprocess": function(d) {
        const attrList = d[3] ? d[3][0] : [];
        const attrItems = d[1];
        return d[1];
      }
    },
    { "name": "attrItems$subexpression$1", "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "attrItems$subexpression$1", "symbols": [lexer5.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD] },
    { "name": "attrItems$ebnf$1$subexpression$1", "symbols": [lexer5.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON] },
    { "name": "attrItems$ebnf$1$subexpression$1", "symbols": [lexer5.has("COMMA") ? { type: "COMMA" } : COMMA] },
    { "name": "attrItems$ebnf$1", "symbols": ["attrItems$ebnf$1$subexpression$1"], "postprocess": id5 },
    { "name": "attrItems$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "attrItems$ebnf$2", "symbols": ["attrItems"], "postprocess": id5 },
    { "name": "attrItems$ebnf$2", "symbols": [], "postprocess": () => null },
    {
      "name": "attrItems",
      "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer5.has("EQ") ? { type: "EQ" } : EQ, "attrItems$subexpression$1", "attrItems$ebnf$1", "attrItems$ebnf$2"],
      "postprocess": function(d) {
        const attrItems = d[4] ? d[4] : [];
        const id9 = tv(d[0]);
        const eqValToken = d[2][0];
        const eq4 = eqValToken.type === "QUOTED_WORD" ? getQuotedWord(eqValToken) : tv(eqValToken);
        const attr = {
          type: "attr",
          id: id9,
          eq: eq4
        };
        return [attr, ...attrItems];
      }
    },
    {
      "name": "nodeId",
      "symbols": [lexer5.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD],
      "postprocess": function(d) {
        return {
          type: "node_id",
          id: getQuotedWord(d[0]).trim()
        };
      }
    },
    {
      "name": "nodeId",
      "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT],
      "postprocess": function(d) {
        return {
          type: "node_id",
          id: tv(d[0]).trim()
        };
      }
    },
    { "name": "subgraph$ebnf$1", "symbols": [lexer5.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": id5 },
    { "name": "subgraph$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "subgraph",
      "symbols": [lexer5.has("SUBGRAPH") ? { type: "SUBGRAPH" } : SUBGRAPH, "subgraph$ebnf$1", lexer5.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "_", "stmtList", "_", lexer5.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET],
      "postprocess": function(d) {
        const children = d[4];
        const subgraph = {
          type: "subgraph",
          children
        };
        if (d[1]) {
          subgraph.id = tv(d[1]).trim();
        }
        return subgraph;
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer5.has("WS") ? { type: "WS" } : WS] }
};
var dotDiagram_default = grammar5;

// ../pintora-diagrams/lib/dot/parser.js
var parse5 = genParserWithRules(dotDiagram_default, {
  dedupeAmbigousResults: true,
  postProcess(results) {
    db_default4.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/dot/index.js
var dotDiagram = {
  pattern: /^\s*dotDiagram/,
  parser: {
    parse(text) {
      parse5(text);
      return db_default4.getDiagramIR();
    }
  },
  artist: artist_default5,
  configKey: "dot",
  clear() {
    db_default4.clear();
  }
};

// ../pintora-diagrams/lib/mindmap/db.js
var MMTree = class _MMTree {
  constructor() {
    this.nodes = /* @__PURE__ */ new Map();
  }
  static fromRootItem(item) {
    const tree = new _MMTree();
    tree.root = tree.addItemToNode({ ...item, parent: null });
    tree.current = tree.root;
    return tree;
  }
  add(item) {
    let cur = this.current;
    while (cur && Math.abs(cur.depth) >= Math.abs(item.depth)) {
      if (cur.id === this.root.id)
        break;
      if (cur.parent) {
        cur = this.nodes.get(cur.parent);
        continue;
      }
      break;
    }
    if (!cur) {
      cur = this.root;
    }
    if (cur === this.root || Math.abs(cur.depth) < Math.abs(item.depth)) {
      const newNode = this.addItemToNode(item);
      this.addChild(cur, newNode);
      this.current = newNode;
    }
  }
  getNode(id9) {
    return this.nodes.get(id9);
  }
  addChild(parent, child) {
    parent.children.push(child.id);
    child.parent = parent.id;
  }
  addItemToNode(item) {
    if (!item.children)
      item.children = [];
    this.nodes.set(item.id, item);
    return item;
  }
  serialize() {
    const data = {
      root: this.root.id,
      nodes: {
        [this.root.id]: this.root
      }
    };
    const visitor = (c) => {
      data.nodes[c.id] = c;
    };
    this.walkTree(this.root, visitor);
    return data;
  }
  walkTree(node2, visitor) {
    visitor(node2);
    node2.children.forEach((child) => {
      const childNode = this.nodes.get(child);
      if (childNode) {
        this.walkTree(childNode, visitor);
      }
    });
  }
};
var MindmapDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.items = [];
    this.trees = [];
    this.idCounter = makeIdCounter();
    this.treeMap = /* @__PURE__ */ new WeakMap();
  }
  makeId() {
    return this.idCounter.next();
  }
  getDiagramIR() {
    return {
      ...this.getBaseDiagramIR(),
      trees: this.trees.map((tree) => {
        const data = tree.serialize();
        this.treeMap.set(data, tree);
        return data;
      })
    };
  }
  addItem(item) {
    if (!this.currentTree || item.depth === 1) {
      this.currentTree = MMTree.fromRootItem(item);
      this.trees.push(this.currentTree);
    } else {
      this.currentTree.add(item);
    }
  }
  apply(part) {
    if (!part)
      return;
    if (Array.isArray(part)) {
      return part.map((c) => this.apply(c));
    }
    switch (part.type) {
      case "addItem": {
        const { type, ...data } = part;
        this.addItem({ ...data, id: this.makeId(), isReverse: Boolean(part.isReverse), children: [] });
        break;
      }
      case "addParam": {
        this.configParams.push(part);
        break;
      }
      case "setTitle": {
        this.title = part.text;
        break;
      }
      case "overrideConfig": {
        this.addOverrideConfig(part);
        break;
      }
    }
  }
  getTreeByData(data) {
    return this.treeMap.get(data);
  }
  clear() {
    super.clear();
    this.idCounter.reset();
    this.trees = [];
    this.items = [];
    this.currentTree = null;
  }
};
var db6 = new MindmapDb();
var db_default5 = db6;

// ../pintora-diagrams/lib/mindmap/config.js
function getColorsByPrimary(c, isDark = false) {
  const primaryColor = (0, import_tinycolor2.default)(c);
  const hslColor = primaryColor.toHsl();
  let primaryLight1;
  if (isDark) {
    primaryLight1 = primaryColor.clone().brighten(15);
  } else {
    primaryLight1 = primaryColor.clone().brighten(15);
  }
  const primaryLight2 = (0, import_tinycolor2.default)({ h: hslColor.h, s: 20, l: 90 });
  return {
    nodeBgColor: primaryLight2.toHexString(),
    l1NodeBgColor: c,
    l2NodeBgColor: primaryLight1.toHexString()
  };
}
var DEFAULT_COLORS = getColorsByPrimary(PALETTE.orange);
var defaultConfig6 = {
  diagramPadding: 15,
  layoutDirection: "LR",
  useMaxWidth: false,
  borderRadius: 4,
  nodeBgColor: DEFAULT_COLORS.nodeBgColor,
  nodePadding: 10,
  nodeFontWeight: "normal",
  textColor: PALETTE.normalDark,
  edgeColor: PALETTE.normalDark,
  fontFamily: DEFAULT_FONT_FAMILY,
  maxFontSize: 18,
  minFontSize: 12,
  levelDistance: 40,
  l1NodeBgColor: DEFAULT_COLORS.l1NodeBgColor,
  l1NodeTextColor: PALETTE.normalDark,
  l2NodeBgColor: DEFAULT_COLORS.l2NodeBgColor,
  l2NodeTextColor: PALETTE.normalDark
};
var MINDMAP_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig6),
  useMaxWidth: { valueType: "boolean" },
  diagramPadding: { valueType: "size" },
  layoutDirection: { valueType: "layoutDirection" },
  borderRadius: { valueType: "size" },
  nodeBgColor: { valueType: "color" },
  nodePadding: { valueType: "size" },
  textColor: { valueType: "color" },
  edgeColor: { valueType: "color" },
  maxFontSize: { valueType: "size" },
  minFontSize: { valueType: "size" },
  fontFamily: { valueType: "string" },
  levelDistance: { valueType: "size" },
  l1NodeBgColor: { valueType: "color" },
  l1NodeTextColor: { valueType: "color" },
  l2NodeBgColor: { valueType: "color" },
  l2NodeTextColor: { valueType: "color" }
};
var configKey6 = "mindmap";
var configurator6 = makeConfigurator({
  defaultConfig: defaultConfig6,
  configKey: configKey6,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(MINDMAP_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    const { nodeBgColor, l1NodeBgColor, l2NodeBgColor } = getColorsByPrimary(t.primaryColor, t.isDark);
    const nodeBgColorInstance = (0, import_tinycolor2.default)(nodeBgColor);
    const bgIsLight = nodeBgColorInstance.isLight();
    const textColorIsLight = (0, import_tinycolor2.default)(t.textColor).isLight();
    const normalNodeTextColor = bgIsLight !== textColorIsLight ? t.textColor : t.canvasBackground;
    return {
      nodeBgColor,
      textColor: normalNodeTextColor,
      edgeColor: t.primaryLineColor,
      l1NodeBgColor,
      l1NodeTextColor: t.textColor,
      l2NodeBgColor,
      l2NodeTextColor: t.textColor
    };
  }
});
var getConf6 = configurator6.getConfig;

// ../pintora-diagrams/lib/mindmap/artist.js
var conf5;
var mmDraw;
var mmArtist = {
  draw(ir, config2, opts) {
    conf5 = Object.assign(getConf6(ir), config2 || {});
    mmDraw = new MMDraw(ir);
    if (isDev) {
      ;
      window.mmDraw = mmDraw;
    }
    const rootMark = {
      type: "group",
      attrs: {},
      children: []
    };
    mmDraw.drawTo(rootMark);
    const bounds = mmDraw.dagreWrapper.getGraphBounds();
    const { title } = ir;
    let titleSize = void 0;
    let titleMark = void 0;
    if (title) {
      const titleFont = { fontSize: conf5.maxFontSize, fontFamily: conf5.fontFamily };
      const titleResult = makeTitleMark(title, titleFont, { fill: conf5.textColor });
      titleSize = titleResult.titleSize;
      titleMark = titleResult.mark;
      titleMark.class = "mindmap__title";
      rootMark.children.push(titleMark);
      titleSize.height += conf5.maxFontSize;
    }
    const { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds: bounds,
      padX: conf5.diagramPadding,
      padY: conf5.diagramPadding,
      useMaxWidth: conf5.useMaxWidth,
      containerSize: opts === null || opts === void 0 ? void 0 : opts.containerSize,
      titleSize,
      titleMark
    });
    return {
      width: width2,
      height,
      mark: rootMark
    };
  }
};
var MMDraw = class {
  constructor(ir) {
    this.ir = ir;
    this.trees = ir.trees.map((data) => {
      return db_default5.getTreeByData(data);
    });
    this.g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: true
    }).setGraph({
      rankdir: conf5.layoutDirection,
      nodesep: 30,
      edgesep: 30,
      ranksep: conf5.levelDistance
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    this.dagreWrapper = new DagreWrapper(this.g);
  }
  drawTo(rootMark) {
    this.trees.map((tree) => this.drawTree(rootMark, tree));
    this.dagreWrapper.doLayout();
    this.dagreWrapper.callNodeOnLayout();
    this.drawEdgesTo(rootMark);
  }
  drawTree(rootMark, tree) {
    tree.walkTree(tree.root, (node2) => {
      this.drawNode(rootMark, tree, node2);
    });
  }
  getNodeStyleOfLevel(level) {
    const bgColor = conf5[`l${level}NodeBgColor`] || conf5.nodeBgColor;
    const textColor = conf5[`l${level}NodeTextColor`] || conf5.textColor;
    return { bgColor, textColor };
  }
  drawNode(rootMark, tree, node2) {
    const fontSize2 = Math.max(conf5.minFontSize, conf5.maxFontSize - (node2.depth - 1) * 2);
    const fontConfig = getFontConfig4(conf5, { fontSize: fontSize2, fontWeight: conf5.nodeFontWeight });
    const labelDim = calculateTextDimensions(node2.label, fontConfig);
    const group = makeEmptyGroup();
    group.class = "mindmap__node";
    const padding = Math.ceil(fontSize2 * 0.75);
    const rectWidth = labelDim.width + padding * 2;
    const rectHeight = labelDim.height + padding * 2;
    const nodeStyle = this.getNodeStyleOfLevel(node2.depth);
    const bgMark = makeMark("rect", {
      x: -rectWidth / 2,
      y: -rectHeight / 2,
      width: rectWidth,
      height: rectHeight,
      fill: nodeStyle.bgColor,
      radius: conf5.borderRadius
    });
    const textMark = makeMark("text", {
      text: node2.label,
      fill: nodeStyle.textColor,
      textBaseline: "middle",
      textAlign: "center",
      ...fontConfig
    });
    group.children.push(bgMark, textMark);
    this.g.setNode(node2.id, {
      width: rectWidth,
      height: rectHeight,
      onLayout(data) {
        positionGroupContents(group, data);
      }
    });
    node2.children.forEach((childId) => {
      const childNode = tree.getNode(childId);
      if (childNode.isReverse) {
        this.g.setEdge(childId, node2.id, { label: `${childNode.label}-${node2.label}`, isReverse: true });
      } else {
        this.g.setEdge(node2.id, childId, { label: `${node2.label}-${node2.label}` });
      }
    });
    rootMark.children.push(group);
  }
  drawEdgesTo(rootMark) {
    const edgeGroup = makeEmptyGroup();
    const g = this.g;
    this.g.edges().forEach((e) => {
      const edge = g.edge(e);
      if (!edge.points)
        return;
      const isVertical = isGraphVertical(g);
      const fromNode = g.node(e.v);
      const toNode = g.node(e.w);
      let fromOutPoint;
      let toInPoint;
      const { isReverse } = edge;
      if (isVertical) {
        fromOutPoint = getPositionOfRect(TRANSFORM_GRAPH.graphNodeToRectStart(isReverse ? toNode : fromNode), PositionH.CENTER | (isReverse ? PositionV.TOP : PositionV.BOTTOM));
        toInPoint = getPositionOfRect(TRANSFORM_GRAPH.graphNodeToRectStart(isReverse ? fromNode : toNode), PositionH.CENTER | (isReverse ? PositionV.BOTTOM : PositionV.TOP));
      } else {
        fromOutPoint = getPositionOfRect(TRANSFORM_GRAPH.graphNodeToRectStart(isReverse ? toNode : fromNode), (isReverse ? PositionH.LEFT : PositionH.RIGHT) | PositionV.CENTER);
        toInPoint = getPositionOfRect(TRANSFORM_GRAPH.graphNodeToRectStart(isReverse ? fromNode : toNode), (isReverse ? PositionH.RIGHT : PositionH.LEFT) | PositionV.CENTER);
      }
      const nextLevelIds = isReverse ? g.predecessors(e.w) : g.successors(e.v);
      const nextLevelBounds = nextLevelIds.reduce((acc, id9) => {
        const nodeData = TRANSFORM_GRAPH.graphNodeToRectStart(g.node(id9));
        if (nodeData.x < acc.left)
          acc.left = nodeData.x;
        const right = nodeData.x + nodeData.width;
        if (right > acc.right)
          acc.right = right;
        acc.top = Math.min(nodeData.y, acc.top);
        acc.bottom = Math.max(nodeData.y + nodeData.height, acc.bottom);
        return acc;
      }, makeBounds());
      let newPoints;
      if (isVertical) {
        const middleY = isReverse ? (fromOutPoint.y + nextLevelBounds.bottom) / 2 : (fromOutPoint.y + nextLevelBounds.top) / 2;
        newPoints = [fromOutPoint, { x: fromOutPoint.x, y: middleY }, { x: toInPoint.x, y: middleY }, toInPoint];
      } else {
        const middleX = isReverse ? (fromOutPoint.x + nextLevelBounds.right) / 2 : (fromOutPoint.x + nextLevelBounds.left) / 2;
        newPoints = [fromOutPoint, { x: middleX, y: fromOutPoint.y }, { x: middleX, y: toInPoint.y }, toInPoint];
      }
      const path4 = getPointsLinearPath(newPoints);
      const linePath = makeMark("path", {
        path: path4,
        stroke: conf5.edgeColor,
        lineJoin: "round"
      });
      edgeGroup.children.push(linePath);
    });
    rootMark.children.push(edgeGroup);
  }
};
function getFontConfig4(conf6, f) {
  return {
    fontFamily: conf6.fontFamily,
    ...f
  };
}
var artist_default6 = mmArtist;

// ../pintora-diagrams/lib/mindmap/parser/mindmap.js
var moo6 = __toESM(require_moo());
function id6(d) {
  return d[0];
}
var COLOR6 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE6 = /@param/;
var CONFIG_DIRECTIVE7 = /@config/;
var L_PAREN6 = /\(/;
var R_PAREN6 = /\)/;
function getTokenValue6(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement6(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue6(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE6 = /%%.*/;
var COMMON_TOKEN_RULES3 = {
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
};
var lexer6 = moo6.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: / +/, lineBreaks: false },
    ASTERISKS: /\*+/,
    PLUS: /\++/,
    MINUS: /\-+/,
    SEMICOLON: /;/,
    COLON: /:/,
    PARAM_DIRECTIVE: PARAM_DIRECTIVE6,
    ...configLexerMainState,
    L_PAREN: L_PAREN_REGEXP,
    R_PAREN: R_PAREN_REGEXP,
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    ...COMMON_TOKEN_RULES3
  },
  configStatement: {
    ...configLexerconfigStatementState,
    ...COMMON_TOKEN_RULES3
  }
});
var yy5;
function setYY5(v) {
  yy5 = v;
}
var grammar6 = {
  Lexer: lexer6,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id6 },
    { "name": "color", "symbols": [COLOR6], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE6, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE6, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE7, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement6 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE7, L_PAREN6, "configOpenCloseStatement$ebnf$1", R_PAREN6], "postprocess": handleConfigOpenCloseStatement6 },
    { "name": "comment", "symbols": [COMMENT_LINE6], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"] },
    { "name": "start", "symbols": [{ "literal": "mindmap" }, "document"] },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "line"],
      "postprocess": (d) => {
        const r = d[0].concat(d[1]);
        return r;
      }
    },
    { "name": "line$ebnf$1", "symbols": [] },
    { "name": "line$ebnf$1", "symbols": ["line$ebnf$1", lexer6.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"] },
    { "name": "line$ebnf$2", "symbols": [] },
    { "name": "line$ebnf$2", "symbols": ["line$ebnf$2", lexer6.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "line", "symbols": ["line$ebnf$2", lexer6.has("NL") ? { type: "NL" } : NL] },
    {
      "name": "statement",
      "symbols": ["levelNotation", lexer6.has("WS") ? { type: "WS" } : WS, "words", lexer6.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const label = d[2];
        const notation = d[0];
        return { type: "addItem", label, depth: d[0].depth, isReverse: notation.isReverse };
      }
    },
    { "name": "statement$ebnf$1", "symbols": [lexer6.has("WS") ? { type: "WS" } : WS], "postprocess": id6 },
    { "name": "statement$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["levelNotation", lexer6.has("WS") ? { type: "WS" } : WS, lexer6.has("COLON") ? { type: "COLON" } : COLON, "multilineText", lexer6.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON, "statement$ebnf$1", lexer6.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const label = d[3];
        const notation = d[0];
        return { type: "addItem", label, depth: notation.depth, isReverse: notation.isReverse };
      }
    },
    { "name": "statement", "symbols": ["paramStatement", "_", lexer6.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["configOpenCloseStatement", "_", lexer6.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": [{ "literal": "title" }, lexer6.has("COLON") ? { type: "COLON" } : COLON, "words", lexer6.has("NL") ? { type: "NL" } : NL], "postprocess": (d) => ({ type: "setTitle", text: d[2].trim() }) },
    { "name": "statement", "symbols": ["comment", "_", lexer6.has("NL") ? { type: "NL" } : NL] },
    { "name": "levelNotation$subexpression$1", "symbols": [lexer6.has("ASTERISKS") ? { type: "ASTERISKS" } : ASTERISKS] },
    { "name": "levelNotation$subexpression$1", "symbols": [lexer6.has("PLUS") ? { type: "PLUS" } : PLUS] },
    {
      "name": "levelNotation",
      "symbols": ["levelNotation$subexpression$1"],
      "postprocess": function(d) {
        const text = tv(d[0][0]);
        return {
          depth: text.length,
          text
        };
      }
    },
    {
      "name": "levelNotation",
      "symbols": [lexer6.has("MINUS") ? { type: "MINUS" } : MINUS],
      "postprocess": function(d) {
        const text = tv(d[0]);
        return {
          depth: text.length,
          text,
          isReverse: true
        };
      }
    },
    { "name": "textSegment", "symbols": [lexer6.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "textSegment", "symbols": [lexer6.has("ASTERISKS") ? { type: "ASTERISKS" } : ASTERISKS] },
    { "name": "textSegment", "symbols": [lexer6.has("PLUS") ? { type: "PLUS" } : PLUS] },
    { "name": "textSegment", "symbols": [lexer6.has("MINUS") ? { type: "MINUS" } : MINUS] },
    {
      "name": "textSegment",
      "symbols": [lexer6.has("WS") ? { type: "WS" } : WS],
      "postprocess": function(d) {
        const c = d[0];
        return typeof c === "string" ? c : tv(c);
      }
    },
    { "name": "words$ebnf$1", "symbols": ["textSegment"] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "textSegment"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": ["words$ebnf$1"],
      "postprocess": function(d) {
        const v = d[0].map((o) => o[0]).join("");
        return v;
      }
    },
    { "name": "multilineText$ebnf$1", "symbols": [] },
    { "name": "multilineText$ebnf$1$subexpression$1", "symbols": ["textSegment"] },
    { "name": "multilineText$ebnf$1$subexpression$1", "symbols": [lexer6.has("NL") ? { type: "NL" } : NL] },
    { "name": "multilineText$ebnf$1", "symbols": ["multilineText$ebnf$1", "multilineText$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "multilineText",
      "symbols": ["multilineText$ebnf$1"],
      "postprocess": function(d) {
        const v = d[0].map((l) => {
          return l.map((o) => typeof o === "string" ? o : tv(o));
        }).join("");
        return v;
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [] }
};
var mindmap_default = grammar6;

// ../pintora-diagrams/lib/mindmap/parser.js
setYY5(db_default5);
var parse6 = genParserWithRules(mindmap_default, {
  postProcess(results) {
    db_default5.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/mindmap/index.js
var mindmap = {
  pattern: /^\s*mindmap/,
  parser: {
    parse(text) {
      parse6(text);
      return db_default5.getDiagramIR();
    }
  },
  artist: artist_default6,
  configKey: configKey6,
  clear() {
    db_default5.clear();
  }
};

// ../pintora-diagrams/lib/util/time.js
var import_dayjs = __toESM(require_dayjs_min());

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start, stop, step) {
    var range2 = [], previous;
    start = interval2.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range2;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count) {
    interval2.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start, end) {
  return end - start;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/day.js
var day = newInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var day_default = day;
var days = day.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/week.js
function weekday(i2) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i2) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcWeek.js
function utcWeekday(i2) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i2) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// ../../node_modules/.pnpm/d3-array@3.1.1/node_modules/d3-array/src/ascending.js
function ascending(a, b10) {
  return a == null || b10 == null ? NaN : a < b10 ? -1 : a > b10 ? 1 : a >= b10 ? 0 : NaN;
}

// ../../node_modules/.pnpm/d3-array@3.1.1/node_modules/d3-array/src/bisector.js
function bisector(f) {
  let delta = f;
  let compare1 = f;
  let compare2 = f;
  if (f.length !== 2) {
    delta = (d, x2) => f(d) - x2;
    compare1 = ascending;
    compare2 = (d, x2) => ascending(f(d), x2);
  }
  function left(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x2, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x2, lo = 0, hi = a.length) {
    const i2 = left(a, x2, lo, hi - 1);
    return i2 > lo && delta(a[i2 - 1], x2) > -delta(a[i2], x2) ? i2 - 1 : i2;
  }
  return { left, center, right };
}

// ../../node_modules/.pnpm/d3-array@3.1.1/node_modules/d3-array/src/number.js
function number(x2) {
  return x2 === null ? NaN : +x2;
}

// ../../node_modules/.pnpm/d3-array@3.1.1/node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// ../../node_modules/.pnpm/d3-array@3.1.1/node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start ? -step1 : step1;
}

// ../../node_modules/.pnpm/d3-time@3.0.0/node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks2(start, stop, count) {
    const reverse = stop < start;
    if (reverse)
      [start, stop] = [stop, start];
    const interval2 = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks3 = interval2 ? interval2.range(start, +stop + 1) : [];
    return reverse ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i2 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length)
      return year2.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i2 === 0)
      return millisecond_default.every(Math.max(tickStep(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// ../pintora-diagrams/lib/gantt/db.js
var AFTER_TASK_REGEXP = /^after\s+([\d\w- ]+)/;
var DEFAULT_TIME_FORMAT = "YYYY-MM-DD";
var GanttDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.tasks = {};
    this.attrs = this.makeDefaultAttrs();
    this.taskCounter = makeIdCounter();
    this.tags = this.makeDefaultTags();
    this.markDates = [];
    this.lastOrder = 0;
    this.ACTION_HANDLERS = {
      addAttr(action) {
        let value = action.value;
        if (["excludes", "includes"].includes(action.key)) {
          value = action.value.toLowerCase().split(/[\s,]+/);
        }
        this.attrs[action.key] = value;
      },
      addTask(action) {
        this.addTask(action);
      },
      addSection(action) {
        this.currentSection = action.label;
      },
      markDate(action) {
        this.processMarkDate(action.value);
      },
      overrideConfig(action) {
        this.addOverrideConfig(action);
      },
      addParam(action) {
        this.configParams.push(action);
      }
    };
  }
  getDiagramIR() {
    return {
      ...super.getBaseDiagramIR(),
      tasks: this.tasks,
      attrs: this.attrs,
      markDates: this.markDates
    };
  }
  apply(action) {
    if (!action)
      return;
    if (Array.isArray(action)) {
      action.forEach((a) => this.apply(a));
      return;
    }
    if (action.type in this.ACTION_HANDLERS) {
      this.ACTION_HANDLERS[action.type].call(this, action);
    }
  }
  makeTaskId(idStr) {
    if (typeof idStr === "undefined") {
      const taskCount = this.taskCounter.next();
      return "task" + taskCount;
    }
    return idStr;
  }
  addTask(action) {
    const { label, extraValue } = action;
    const task = this.parseTaskData(label.trim(), extraValue.trim(), {});
    this.lastTaskId = task.id;
    this.tasks[task.id] = task;
  }
  // parse extra value to task attributes
  parseTaskData(label, dataStr, opts) {
    const prevTask = opts.prevTask || this.tasks[this.lastTaskId];
    const segs = dataStr.trim().split(",").map((str3) => str3.trim());
    const task = {
      label,
      id: this.makeTaskId(),
      startTime: null,
      endTime: null,
      renderEndTime: null,
      order: this.lastOrder++,
      section: this.currentSection
    };
    if (segs[0]) {
      const v = segs[0].toUpperCase();
      const maybeTaskSegs = v.split(" ");
      let isTagsMatched = false;
      maybeTaskSegs.forEach((str3) => {
        if (this.tags[str3]) {
          isTagsMatched = true;
          if (!task.tags)
            task.tags = [];
          task.tags.push(str3);
        }
      });
      if (isTagsMatched)
        segs.shift();
    }
    const segsLen = segs.length;
    let endTimeData = "";
    if (segsLen === 1) {
      const [end] = segs;
      task.startTime = prevTask === null || prevTask === void 0 ? void 0 : prevTask.endTime;
      endTimeData = end;
    } else if (segsLen === 2) {
      const [start, end] = segs;
      const { date: date2, prevTaskId } = this.getStartOfTask(start);
      task.startTime = date2;
      task.prevTaskId = prevTaskId;
      endTimeData = end;
    } else if (segsLen === 3) {
      const [id9, start, end] = segs;
      task.id = this.makeTaskId(id9);
      const { date: date2, prevTaskId } = this.getStartOfTask(start);
      task.startTime = date2;
      task.prevTaskId = prevTaskId;
      endTimeData = end;
    }
    if (endTimeData) {
      task.endTime = this.getEndDate(task.startTime, endTimeData, false);
      task.isManualEndTime = isDateStrValid(endTimeData, this.attrs.dateFormat).isValid;
      checkTaskDates(task, this.attrs.dateFormat, this.attrs.excludes, this.attrs.includes);
    }
    return task;
  }
  findTaskById(id9) {
    return this.tasks[id9];
  }
  getStartOfTask(str3) {
    str3 = str3.trim();
    let prevTaskId = "";
    const afterStatement = AFTER_TASK_REGEXP.exec(str3.trim());
    if (afterStatement !== null) {
      let latestEndingTask = null;
      afterStatement[1].split(" ").forEach((id9) => {
        const task = this.findTaskById(id9);
        if (typeof task !== "undefined") {
          prevTaskId = task.id;
          if (!latestEndingTask) {
            latestEndingTask = task;
          } else {
            if (task.endTime > latestEndingTask.endTime) {
              latestEndingTask = task;
            }
          }
        }
      });
      if (!latestEndingTask) {
        const dt = /* @__PURE__ */ new Date();
        dt.setHours(0, 0, 0, 0);
        return { date: dt, prevTaskId };
      } else {
        return { date: latestEndingTask.endTime, prevTaskId };
      }
    }
    const dateFormat = this.attrs.dateFormat;
    const mDate = (0, import_dayjs.default)(str3, dateFormat, true);
    if (mDate.isValid()) {
      return { date: mDate.toDate(), prevTaskId };
    } else {
      logger.debug(`Invalid date: ${str3}, dateFormat: ${dateFormat}`);
    }
    return { date: /* @__PURE__ */ new Date(), prevTaskId };
  }
  getEndDate(prevTime, str3, inclusive) {
    inclusive = inclusive || false;
    str3 = str3.trim();
    const mDate = (0, import_dayjs.default)(str3, this.attrs.dateFormat.trim(), true);
    if (mDate.isValid()) {
      if (inclusive) {
        mDate.add(1, "d");
      }
      return mDate.toDate();
    }
    return durationToDate(/^([\d]+)([wdhms])/.exec(str3.trim()), (0, import_dayjs.default)(prevTime));
  }
  processMarkDate(str3) {
    const trimmedStr = str3.trim();
    let date2;
    if (trimmedStr === "today") {
      date2 = /* @__PURE__ */ new Date();
    } else {
      const { dayObject, isValid } = isDateStrValid(str3, this.attrs.dateFormat);
      if (isValid) {
        date2 = dayObject.toDate();
      }
    }
    if (date2) {
      this.markDates.push(date2);
    }
  }
  makeDefaultAttrs() {
    return {
      title: "",
      dateFormat: DEFAULT_TIME_FORMAT,
      axisFormat: "",
      axisInterval: null,
      excludes: [],
      includes: []
    };
  }
  makeDefaultTags() {
    return createDictByKeys(["ACTIVE", "DONE", "CRIT", "MILESTONE"]);
  }
  clear() {
    super.clear();
    this.tasks = {};
    this.attrs = this.makeDefaultAttrs();
    this.tags = this.makeDefaultTags();
    this.lastOrder = 0;
    this.currentSection = void 0;
    this.markDates = [];
  }
};
var db7 = new GanttDb();
function isDateStrValid(str3, timeFormat2) {
  const dayObject = (0, import_dayjs.default)(str3, timeFormat2 || DEFAULT_TIME_FORMAT, true);
  return { dayObject, isValid: dayObject.isValid() };
}
function checkTaskDates(task, dateFormat, excludes, includes) {
  if (!excludes.length || task.isManualEndTime)
    return;
  const startTime = (0, import_dayjs.default)(task.startTime, dateFormat, true);
  startTime.add(1, "d");
  const endTime = (0, import_dayjs.default)(task.endTime, dateFormat, true);
  const renderEndTime = fixTaskDates(startTime, endTime, dateFormat, excludes, includes);
  task.endTime = endTime.toDate();
  task.renderEndTime = renderEndTime;
}
var fixTaskDates = function(startTime, endTime, dateFormat, excludes, includes) {
  let invalid = false;
  let renderEndTime = null;
  while (startTime <= endTime) {
    if (!invalid) {
      renderEndTime = endTime.toDate();
    }
    invalid = isInvalidDate(startTime, dateFormat, excludes, includes);
    if (invalid) {
      endTime = endTime.add(1, "d");
    }
    startTime = startTime.add(1, "d");
  }
  return renderEndTime;
};
var isInvalidDate = function(date2, dateFormat, excludes, includes) {
  if (includes.length && includes.indexOf(date2.format(dateFormat)) >= 0) {
    return false;
  }
  if (date2.day() >= 6 && excludes.indexOf("weekends") >= 0) {
    return true;
  }
  if (excludes.length && excludes.indexOf(date2.format("dddd").toLowerCase()) >= 0) {
    return true;
  }
  return excludes.indexOf(date2.format(dateFormat.trim())) >= 0;
};
var durationToDate = function(durationStatement, relativeTime) {
  let resultDate = relativeTime;
  if (durationStatement !== null) {
    const [_3, numStr, unit2] = durationStatement;
    const num = parseFloat(numStr);
    switch (unit2) {
      case "s":
        resultDate = relativeTime.add(num, "second");
        break;
      case "m":
        resultDate = relativeTime.add(num, "minute");
        break;
      case "h":
        resultDate = relativeTime.add(num, "hour");
        break;
      case "d":
        resultDate = relativeTime.add(num, "day");
        break;
      case "w":
        resultDate = relativeTime.add(num, "week");
        break;
    }
  }
  return resultDate.toDate();
};
function createDictByKeys(keys3, defaultValue = true) {
  return keys3.reduce((acc, current) => {
    acc[current] = defaultValue;
    return acc;
  }, {});
}
function getAxisTimeInterval(opts) {
  const { axisFormat, axisInterval } = opts;
  let timeInterval = day_default.every(1);
  const RANGE_CONFIGS = [
    {
      pattern: /y/i,
      rangeMaker: year_default
    },
    {
      pattern: /M/,
      rangeMaker: month_default
    },
    {
      pattern: /d/i,
      rangeMaker: day_default
    },
    {
      pattern: /w/i,
      rangeMaker: sunday
    },
    {
      pattern: /h/i,
      rangeMaker: hour_default
    },
    {
      pattern: /m/,
      rangeMaker: minute_default
    },
    {
      pattern: /s/,
      rangeMaker: second_default
    }
  ];
  let intervalFromIR;
  if (axisInterval) {
    const match = /(\d+)(\w)/.exec(axisInterval.trim());
    if (match) {
      const count = parseInt(match[1]);
      const format = match[2];
      if (!isNaN(count)) {
        for (const rangeConfig of RANGE_CONFIGS) {
          if (rangeConfig.pattern.test(format)) {
            intervalFromIR = rangeConfig.rangeMaker.every(count);
          }
        }
      }
    }
  }
  if (intervalFromIR) {
    timeInterval = intervalFromIR;
  } else {
    for (const rangeConfig of RANGE_CONFIGS) {
      if (rangeConfig.pattern.test(axisFormat)) {
        timeInterval = rangeConfig.rangeMaker.every(1);
      }
    }
  }
  return timeInterval;
}
var db_default6 = db7;

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// ../../node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// ../../node_modules/.pnpm/d3-color@1.4.1/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r, g, b10, a) {
  if (a <= 0)
    r = g = b10 = NaN;
  return new Rgb(r, g, b10, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b10, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b10, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b10, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b10;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b10 = o.b / 255, min4 = Math.min(r, g, b10), max4 = Math.max(r, g, b10), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h = (g - b10) / s + (g < b10) * 6;
    else if (g === max4)
      h = (b10 - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default2(values4) {
  var n2 = values4.length - 1;
  return function(t) {
    var i2 = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values4[i2], v2 = values4[i2 + 1], v0 = i2 > 0 ? values4[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values4[i2 + 2] : 2 * v2 - v1;
    return basis((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values4) {
  var n2 = values4.length;
  return function(t) {
    var i2 = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values4[(i2 + n2 - 1) % n2], v1 = values4[i2 % n2], v2 = values4[(i2 + 1) % n2], v3 = values4[(i2 + 2) % n2];
    return basis((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x2) => () => x2;

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b10, y2) {
  return a = Math.pow(a, y2), b10 = Math.pow(b10, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b10, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b10) {
    return b10 - a ? exponential(a, b10, y2) : constant_default2(isNaN(a) ? b10 : a);
  };
}
function nogamma(a, b10) {
  var d = b10 - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b10 : a);
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b10 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b10(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r = new Array(n2), g = new Array(n2), b10 = new Array(n2), i2, color2;
    for (i2 = 0; i2 < n2; ++i2) {
      color2 = rgb(colors[i2]);
      r[i2] = color2.r || 0;
      g[i2] = color2.g || 0;
      b10[i2] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b10 = spline(b10);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b10(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b10) {
  if (!b10)
    b10 = [];
  var n2 = a ? Math.min(b10.length, a.length) : 0, c = b10.slice(), i2;
  return function(t) {
    for (i2 = 0; i2 < n2; ++i2)
      c[i2] = a[i2] * (1 - t) + b10[i2] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/array.js
function genericArray(a, b10) {
  var nb = b10 ? b10.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2)
    x2[i2] = value_default(a[i2], b10[i2]);
  for (; i2 < nb; ++i2)
    c[i2] = b10[i2];
  return function(t) {
    for (i2 = 0; i2 < na; ++i2)
      c[i2] = x2[i2](t);
    return c;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/date.js
function date_default(a, b10) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b10 = +b10, function(t) {
    return d.setTime(a * (1 - t) + b10 * t), d;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js
function number_default(a, b10) {
  return a = +a, b10 = +b10, function(t) {
    return a * (1 - t) + b10 * t;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/object.js
function object_default(a, b10) {
  var i2 = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b10 === null || typeof b10 !== "object")
    b10 = {};
  for (k in b10) {
    if (k in a) {
      i2[k] = value_default(a[k], b10[k]);
    } else {
      c[k] = b10[k];
    }
  }
  return function(t) {
    for (k in i2)
      c[k] = i2[k](t);
    return c;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b10) {
  return function() {
    return b10;
  };
}
function one(b10) {
  return function(t) {
    return b10(t) + "";
  };
}
function string_default(a, b10) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s = [], q = [];
  a = a + "", b10 = b10 + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b10))) {
    if ((bs = bm.index) > bi) {
      bs = b10.slice(bi, bs);
      if (s[i2])
        s[i2] += bs;
      else
        s[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i2])
        s[i2] += bm;
      else
        s[++i2] = bm;
    } else {
      s[++i2] = null;
      q.push({ i: i2, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b10.length) {
    bs = b10.slice(bi);
    if (s[i2])
      s[i2] += bs;
    else
      s[++i2] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b10) : (b10 = q.length, function(t) {
    for (var i3 = 0, o; i3 < b10; ++i3)
      s[(o = q[i3]).i] = o.x(t);
    return s.join("");
  });
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js
function value_default(a, b10) {
  var t = typeof b10, c;
  return b10 == null || t === "boolean" ? constant_default2(b10) : (t === "number" ? number_default : t === "string" ? (c = color(b10)) ? (b10 = c, rgb_default) : string_default : b10 instanceof color ? rgb_default : b10 instanceof Date ? date_default : isNumberArray(b10) ? numberArray_default : Array.isArray(b10) ? genericArray : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object_default : number_default)(a, b10);
}

// ../../node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/round.js
function round_default(a, b10) {
  return a = +a, b10 = +b10, function(t) {
    return Math.round(a * (1 - t) + b10 * t);
  };
}

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/constant.js
function constants(x2) {
  return function() {
    return x2;
  };
}

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/number.js
function number2(x2) {
  return +x2;
}

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity4(x2) {
  return x2;
}
function normalize3(a, b10) {
  return (b10 -= a = +a) ? function(x2) {
    return (x2 - a) / b10;
  } : constants(isNaN(b10) ? NaN : 0.5);
}
function clamper(a, b10) {
  var t;
  if (a > b10)
    t = a, a = b10, b10 = t;
  return function(x2) {
    return Math.max(a, Math.min(b10, x2));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize3(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize3(d0, d1), r0 = interpolate(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i2 = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i2 < j) {
    d[i2] = normalize3(domain[i2], domain[i2 + 1]);
    r[i2] = interpolate(range2[i2], range2[i2 + 1]);
  }
  return function(x2) {
    var i3 = bisect_default(domain, x2, 1, j) - 1;
    return r[i3](d[i3](x2));
  };
}
function copy3(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform7, untransform, unknown, clamp2 = identity4, piecewise, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range2.length);
    if (clamp2 !== identity4)
      clamp2 = clamper(domain[0], domain[n2 - 1]);
    piecewise = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale3;
  }
  function scale3(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise(domain.map(transform7), range2, interpolate)))(transform7(clamp2(x2)));
  }
  scale3.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform7), number_default)))(y2)));
  };
  scale3.domain = function(_3) {
    return arguments.length ? (domain = Array.from(_3, number2), rescale()) : domain.slice();
  };
  scale3.range = function(_3) {
    return arguments.length ? (range2 = Array.from(_3), rescale()) : range2.slice();
  };
  scale3.rangeRound = function(_3) {
    return range2 = Array.from(_3), interpolate = round_default, rescale();
  };
  scale3.clamp = function(_3) {
    return arguments.length ? (clamp2 = _3 ? true : identity4, rescale()) : clamp2 !== identity4;
  };
  scale3.interpolate = function(_3) {
    return arguments.length ? (interpolate = _3, rescale()) : interpolate;
  };
  scale3.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale3) : unknown;
  };
  return function(t, u) {
    transform7 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity4, identity4);
}

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}

// ../../node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i2 = -1, j = 0, n2 = specifier.length, c, pad2, format;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i2 < n2) {
        if (specifier.charCodeAt(i2) === 37) {
          string.push(specifier.slice(j, i2));
          if ((pad2 = pads[c = specifier.charAt(++i2)]) != null)
            c = specifier.charAt(++i2);
          else
            pad2 = c === "e" ? " " : "0";
          if (format = formats2[c])
            c = format(date2, pad2);
          string.push(c);
          j = i2 + 1;
        }
      }
      string.push(specifier.slice(j, i2));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i2 = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i2 != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i2 = 0, n2 = specifier.length, m = string.length, c, parse9;
    while (i2 < n2) {
      if (j >= m)
        return -1;
      c = specifier.charCodeAt(i2++);
      if (c === 37) {
        c = specifier.charAt(i2++);
        parse9 = parses[c in pads ? specifier.charAt(i2++) : c];
        if (!parse9 || (j = parse9(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i2) {
    var n2 = periodRe.exec(string.slice(i2));
    return n2 ? (d.p = periodLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortWeekday(d, string, i2) {
    var n2 = shortWeekdayRe.exec(string.slice(i2));
    return n2 ? (d.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseWeekday(d, string, i2) {
    var n2 = weekdayRe.exec(string.slice(i2));
    return n2 ? (d.w = weekdayLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseShortMonth(d, string, i2) {
    var n2 = shortMonthRe.exec(string.slice(i2));
    return n2 ? (d.m = shortMonthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseMonth(d, string, i2) {
    var n2 = monthRe.exec(string.slice(i2));
    return n2 ? (d.m = monthLookup.get(n2[0].toLowerCase()), i2 + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i2) {
    return parseSpecifier(d, locale_dateTime, string, i2);
  }
  function parseLocaleDate(d, string, i2) {
    return parseSpecifier(d, locale_date, string, i2);
  }
  function parseLocaleTime(d, string, i2) {
    return parseSpecifier(d, locale_time, string, i2);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width2) {
  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length3 = string.length;
  return sign + (length3 < width2 ? new Array(width2 - length3 + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 1));
  return n2 ? (d.w = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 1));
  return n2 ? (d.u = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.U = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberISO(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.V = +n2[0], i2 + n2[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.W = +n2[0], i2 + n2[0].length) : -1;
}
function parseFullYear(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 4));
  return n2 ? (d.y = +n2[0], i2 + n2[0].length) : -1;
}
function parseYear(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i2 + n2[0].length) : -1;
}
function parseZone(d, string, i2) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i2, i2 + 6));
  return n2 ? (d.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i2 + n2[0].length) : -1;
}
function parseQuarter(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 1));
  return n2 ? (d.q = n2[0] * 3 - 3, i2 + n2[0].length) : -1;
}
function parseMonthNumber(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.m = n2[0] - 1, i2 + n2[0].length) : -1;
}
function parseDayOfMonth(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseDayOfYear(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 3));
  return n2 ? (d.m = 0, d.d = +n2[0], i2 + n2[0].length) : -1;
}
function parseHour24(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.H = +n2[0], i2 + n2[0].length) : -1;
}
function parseMinutes(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.M = +n2[0], i2 + n2[0].length) : -1;
}
function parseSeconds(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 2));
  return n2 ? (d.S = +n2[0], i2 + n2[0].length) : -1;
}
function parseMilliseconds(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 3));
  return n2 ? (d.L = +n2[0], i2 + n2[0].length) : -1;
}
function parseMicroseconds(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2, i2 + 6));
  return n2 ? (d.L = Math.floor(n2[0] / 1e3), i2 + n2[0].length) : -1;
}
function parseLiteralPercent(d, string, i2) {
  var n2 = percentRe.exec(string.slice(i2, i2 + 1));
  return n2 ? i2 + n2[0].length : -1;
}
function parseUnixTimestamp(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2));
  return n2 ? (d.Q = +n2[0], i2 + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i2) {
  var n2 = numberRe.exec(string.slice(i2));
  return n2 ? (d.s = +n2[0], i2 + n2[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// ../../node_modules/.pnpm/d3-time-format@4.1.0/node_modules/d3-time-format/src/defaultLocale.js
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}

// ../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format) {
  var scale3 = continuous(), invert3 = scale3.invert, domain = scale3.domain;
  var formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear2 = format("%Y");
  function tickFormat(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale3.invert = function(y2) {
    return new Date(invert3(y2));
  };
  scale3.domain = function(_3) {
    return arguments.length ? domain(Array.from(_3, number3)) : domain().map(date);
  };
  scale3.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale3.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };
  scale3.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale3;
  };
  scale3.copy = function() {
    return copy3(scale3, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format));
  };
  return scale3;
}
function time2() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// ../pintora-diagrams/lib/gantt/artist.js
var import_dayjs2 = __toESM(require_dayjs_min());

// ../pintora-diagrams/lib/gantt/config.js
var defaultConfig7 = {
  barHeight: 20,
  barGap: 2,
  topPadding: 30,
  sidePadding: 20,
  gridLineStartPadding: 20,
  numberSectionStyles: 4,
  axisFormat: "YY-MM-DD",
  axisLabelFontSize: 10,
  gridLineWidth: 2,
  gridLineColor: PALETTE.normalDark,
  axisLabelColor: PALETTE.normalDark,
  markLineColor: PALETTE.pink,
  barBackground: PALETTE.orange,
  barBorderColor: PALETTE.normalDark,
  barBorderRadius: 2,
  sectionBackgrounds: ["#fff0da", void 0],
  sectionLabelColor: PALETTE.normalDark,
  fontColor: PALETTE.normalDark,
  fontSize: 14,
  fontFamily: DEFAULT_FONT_FAMILY
};
var GANTT_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig7),
  axisFormat: { valueType: "string" }
};
var configKey7 = "gantt";
var configurator7 = makeConfigurator({
  defaultConfig: defaultConfig7,
  configKey: configKey7,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(GANTT_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t, conf6) {
    const canvasBgInstance = (0, import_tinycolor2.default)(t.canvasBackground || "white");
    const isBgLight = canvasBgInstance.isLight();
    let fontColorOverBackground;
    let gridLineColor;
    if (isBgLight) {
      fontColorOverBackground = PALETTE.normalDark;
      gridLineColor = (0, import_tinycolor2.default)(fontColorOverBackground).lighten(20).toHexString();
    } else {
      fontColorOverBackground = PALETTE.white;
      gridLineColor = (0, import_tinycolor2.default)(fontColorOverBackground).darken(20).toHexString();
    }
    const primaryCorlorInstance = (0, import_tinycolor2.default)(t.primaryColor);
    const sectionBackgrounds = [primaryCorlorInstance.brighten(20).desaturate(10).toHexString(), void 0];
    (0, import_tinycolor2.default)(fontColorOverBackground);
    return {
      barBackground: t.primaryColor,
      barBorderColor: conf6.fontColor,
      fontColor: t.textColor,
      axisLabelColor: fontColorOverBackground,
      sectionLabelColor: fontColorOverBackground,
      sectionBackgrounds,
      gridLineColor
    };
  }
});
var getConf7 = configurator7.getConfig;

// ../pintora-diagrams/lib/gantt/artist.js
var artist2 = makeArtist({
  draw(ir, config2, opts) {
    var _a;
    const conf6 = getConf7(ir, config2);
    const rootMark = makeEmptyGroup();
    let w = 1e3;
    if ((_a = opts.containerSize) === null || _a === void 0 ? void 0 : _a.width) {
      w = opts.containerSize.width;
    }
    const ganttDraw = new GanttDraw(ir, conf6, rootMark, w);
    ganttDraw.makeGant();
    const size4 = ganttDraw.getPageSize();
    const { width: width2, height } = size4;
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
});
var GANTT_LAYER_CONFIG = {
  sectionBackground: 1,
  excludesBackground: 2,
  gridLine: 5,
  bar: 10,
  markLine: 15,
  title: 15
};
var GanttDraw = class {
  constructor(ir, conf6, rootMark, w) {
    this.ir = ir;
    this.conf = conf6;
    this.rootMark = rootMark;
    this.sectionLabelWidth = 0;
    this.layerManager = new LayerManager();
    if (isDev) {
      ;
      window.ganttDraw = this;
    }
    const taskArray = Object.values(ir.tasks);
    this.taskArray = taskArray;
    this.startDate = new Date(min(taskArray, function(d) {
      return Number(d.startTime);
    }));
    this.endDate = new Date(max(taskArray, function(d) {
      return Number(d.renderEndTime || d.endTime);
    }));
    this.fontConfig = {
      fontSize: conf6.fontSize,
      fontFamily: conf6.fontFamily
    };
    const categories = taskArray.map((task) => task.section);
    this.categories = categories;
    const sectionLabelWidths = categories.reduce((acc, section) => {
      if (!acc[section]) {
        acc[section] = section ? calculateTextDimensions(section, this.fontConfig).width : 0;
      }
      return acc;
    }, {});
    const sectionLabelMaxWidth = Object.values(sectionLabelWidths).reduce((acc, current) => {
      return Math.max(acc, current);
    }, 0);
    this.sectionLabelWidth = Math.round(sectionLabelMaxWidth ? sectionLabelMaxWidth + 5 : 0);
    const makeTimeScaleAndTicks = (width2) => {
      const axisFormat = this.ir.attrs.axisFormat || this.conf.axisFormat;
      const sampleLabelWidth = calculateTextDimensions((0, import_dayjs2.default)().format(axisFormat), {
        fontSize: conf6.axisLabelFontSize
      }).width;
      const timeInterval = getAxisTimeInterval({ axisFormat, axisInterval: this.ir.attrs.axisInterval });
      const timeScale2 = time2().domain([this.startDate, this.endDate]).rangeRound([0, width2 - conf6.sidePadding * 2 - this.sectionLabelWidth - sampleLabelWidth / 4]);
      const ticks3 = timeScale2.ticks(timeInterval).map((date2) => {
        const day2 = (0, import_dayjs2.default)(date2);
        const label = day2.format(axisFormat);
        const labelWidth = calculateTextDimensions(label, { fontSize: conf6.axisLabelFontSize }).width;
        return {
          date: date2,
          label,
          labelWidth
        };
      });
      return { timeScale: timeScale2, ticks: ticks3 };
    };
    const { ticks: tempTicks } = makeTimeScaleAndTicks(w);
    const axisLabelGap = conf6.axisLabelFontSize / 2;
    const minWidth = tempTicks.reduce((acc, tick) => acc + tick.labelWidth + axisLabelGap, 0) + conf6.sidePadding * 2 + sectionLabelMaxWidth;
    this.titleTextDims = ir.attrs.title ? calculateTextDimensions(ir.attrs.title, this.fontConfig) : { width: 0, height: 0 };
    const h = taskArray.length * (conf6.barHeight + conf6.barGap) + 2 * conf6.topPadding + conf6.gridLineStartPadding + conf6.axisLabelFontSize + this.titleTextDims.height;
    this.height = h;
    this.width = Math.max(w, minWidth);
    const { timeScale, ticks: ticks2 } = makeTimeScaleAndTicks(this.width);
    this.timeScale = timeScale;
    this.ticks = ticks2;
    for (const [name, zIndex] of Object.entries(GANTT_LAYER_CONFIG)) {
      this.layerManager.addLayer(name, zIndex);
    }
  }
  getPageSize() {
    return { width: this.width, height: this.height };
  }
  makeGant() {
    const { taskArray } = this;
    const { conf: conf6 } = this;
    const barHeight = conf6.barHeight;
    const gap = barHeight + conf6.barGap;
    this.drawTitle();
    const { sectionsHeight } = this.drawSections(taskArray, gap);
    this.drawExcludeDays({ sectionsHeight });
    this.drawGrid({ sectionsHeight });
    this.drawMarkDates({ sectionsHeight });
    this.rootMark.children = this.layerManager.sortLayerMarks();
  }
  getScaledTimeX(v) {
    return Math.round(this.timeScale(v));
  }
  // diagram title
  drawTitle() {
    const title = this.ir.attrs.title;
    if (title) {
      const titleWidth = this.titleTextDims.width;
      const titleMark = makeMark("text", {
        text: title,
        x: (this.width - titleWidth) / 2,
        y: this.conf.topPadding,
        fill: this.conf.fontColor,
        textBaseline: "middle",
        ...this.fontConfig,
        fontWeight: "bold"
      });
      this.layerManager.addMark("title", titleMark);
    }
  }
  /**
   * draw axis labels and grids
   */
  drawGrid(opts) {
    const gridGroup = makeEmptyGroup();
    gridGroup.class = "gantt__grid";
    this.layerManager.addMark("gridLine", gridGroup);
    const { axisLabelColor, gridLineColor, axisLabelFontSize, topPadding, sidePadding, gridLineStartPadding } = this.conf;
    const axisLabelTopMargin = 10;
    const titleHeight = this.titleTextDims.height || 0;
    const yStart = topPadding + titleHeight;
    const yAxisHeight = opts.sectionsHeight + gridLineStartPadding;
    this.ticks.forEach((o) => {
      const { date: tickDate, label } = o;
      const x1 = this.getScaledTimeX(tickDate) + sidePadding + this.sectionLabelWidth;
      const lineEndY = yStart + yAxisHeight;
      const line = makeMark("line", {
        x1,
        x2: x1,
        y1: yStart,
        y2: lineEndY,
        stroke: gridLineColor
      });
      const textMark = makeMark("text", {
        text: label,
        fill: axisLabelColor,
        textAlign: "center",
        textBaseline: "top",
        x: x1,
        y: lineEndY + axisLabelTopMargin,
        fontSize: axisLabelFontSize
      });
      gridGroup.children.push(line, textMark);
    });
  }
  drawSections(taskArray, sectionUnitHeight) {
    const { conf: conf6 } = this;
    const w = this.width;
    const sectionBackgrounGroup = makeEmptyGroup();
    const { gridLineStartPadding, gridLineWidth, sectionBackgrounds, sidePadding, topPadding, barHeight, barGap } = conf6;
    const yStart = gridLineStartPadding + topPadding + (this.titleTextDims.height || 0);
    this.layerManager.addMark("sectionBackground", sectionBackgrounGroup);
    const sectionsMap = /* @__PURE__ */ new Map();
    const taskXOffset = this.sectionLabelWidth + sidePadding;
    taskArray.forEach((task, i2) => {
      const sectionGroup = makeEmptyGroup();
      this.layerManager.addMark("bar", sectionGroup);
      if (!sectionsMap.get(task.section)) {
        const sectionBackground = sectionBackgrounds[sectionsMap.size % sectionBackgrounds.length] || "transparent";
        const sectionY = task.order * sectionUnitHeight + yStart;
        const sectionRect = makeMark("rect", {
          x: 0,
          y: sectionY,
          width: w,
          height: sectionUnitHeight,
          fill: sectionBackground
        }, { class: "gantt__section" });
        sectionBackgrounGroup.children.push(sectionRect);
        let labelMark;
        if (task.section) {
          labelMark = makeMark("text", {
            text: task.section,
            x: sidePadding,
            y: sectionY + sectionUnitHeight / 2,
            ...this.fontConfig,
            fill: conf6.sectionLabelColor,
            textAlign: "left",
            textBaseline: "middle"
          });
          sectionBackgrounGroup.children.push(labelMark);
        }
        sectionsMap.set(task.section, { backgroundRect: sectionRect, taskCount: 0, labelMark });
      }
      sectionsMap.get(task.section).taskCount += 1;
      const taskX = taskXOffset + this.getScaledTimeX(task.startTime);
      const barStartX = taskXOffset + this.getScaledTimeX(task.startTime);
      let barEndX = taskXOffset + this.getScaledTimeX(task.renderEndTime || task.endTime);
      let barWidth = barEndX - barStartX;
      const baseAttrs = {
        radius: conf6.barBorderRadius,
        x: taskX,
        y: task.order * sectionUnitHeight + yStart + barGap / 2,
        width: barWidth,
        height: barHeight,
        fill: conf6.barBackground,
        stroke: conf6.barBorderColor
      };
      const taskRect = makeMark("rect", { ...baseAttrs });
      const appearanceInfo = getTaskAppearanceInfo({
        baseAttrs,
        task,
        taskMark: taskRect,
        originTaskMark: taskRect,
        conf: this.conf
      });
      let taskMark;
      if (appearanceInfo) {
        taskMark = appearanceInfo.taskMark;
        barWidth = appearanceInfo.width;
        barEndX = barStartX + barWidth;
      } else {
        taskMark = taskRect;
      }
      let textX;
      const taskMarkOffset = (appearanceInfo === null || appearanceInfo === void 0 ? void 0 : appearanceInfo.taskMarkOffset) || { x: 0, y: 0 };
      const textWidth = calculateTextDimensions(task.label, this.fontConfig).width;
      if (textWidth > barWidth) {
        const distanceToRightEdge = w - barEndX - taskMarkOffset.x;
        if (textWidth < distanceToRightEdge) {
          textX = barEndX + textWidth / 2 + gridLineWidth + taskMarkOffset.x;
        } else {
          textX = barStartX - textWidth / 2 + taskMarkOffset.x;
        }
      } else {
        textX = barStartX + barWidth / 2 + taskMarkOffset.x;
      }
      const textY = i2 * sectionUnitHeight + conf6.barHeight / 2 + yStart;
      const textMark = makeMark("text", {
        text: task.label,
        x: textX + gridLineWidth / 2,
        y: textY,
        textAlign: "center",
        textBaseline: "middle",
        ...this.fontConfig,
        fill: conf6.fontColor
      });
      sectionGroup.children.push(taskMark, textMark);
    });
    for (const { taskCount, labelMark, backgroundRect } of sectionsMap.values()) {
      if (taskCount > 1) {
        if (labelMark)
          labelMark.attrs.y += (taskCount - 1) * sectionUnitHeight / 2;
        backgroundRect.attrs.height += (taskCount - 1) * sectionUnitHeight;
      }
    }
    const sectionsHeight = Array.from(sectionsMap.values()).reduce((acc, o) => {
      return acc + o.taskCount * sectionUnitHeight;
    }, 0);
    return { sectionsHeight };
  }
  drawExcludeDays(opts) {
    const { conf: conf6 } = this;
    const excludesBackgrounGroup = makeEmptyGroup();
    const { gridLineStartPadding, gridLineColor, sidePadding, topPadding } = conf6;
    const yStart = topPadding + (this.titleTextDims.height || 0);
    this.layerManager.addMark("excludesBackground", excludesBackgrounGroup);
    const minTime = this.startDate;
    const maxTime = this.endDate;
    const { excludes, includes, dateFormat } = this.ir.attrs;
    if (!minTime || !maxTime)
      return;
    const taskXOffset = this.sectionLabelWidth + sidePadding;
    const height = opts.sectionsHeight + gridLineStartPadding;
    const excludeRanges = [];
    let range2 = null;
    let d = (0, import_dayjs2.default)(minTime);
    while (d.toDate() <= maxTime) {
      if (isInvalidDate(d, dateFormat, excludes, includes)) {
        if (!range2) {
          range2 = {
            start: d.toDate(),
            end: d.toDate()
          };
        }
      } else {
        if (range2) {
          range2.end = d.toDate();
          excludeRanges.push(range2);
          range2 = null;
        }
      }
      d = d.add(1, "d");
    }
    excludeRanges.forEach((range3) => {
      const x2 = taskXOffset + this.getScaledTimeX(range3.start);
      const endX = taskXOffset + this.getScaledTimeX(range3.end);
      const rect = makeMark("rect", {
        x: x2,
        width: endX - x2,
        y: yStart,
        height,
        fill: gridLineColor,
        fillOpacity: 0.2
      });
      excludesBackgrounGroup.children.push(rect);
    });
  }
  drawMarkDates(opts) {
    const { topPadding, sidePadding, gridLineStartPadding, markLineColor } = this.conf;
    const titleHeight = this.titleTextDims.height || 0;
    const yStart = topPadding + titleHeight;
    const yEnd = yStart + opts.sectionsHeight + gridLineStartPadding;
    const markLineGroup = makeEmptyGroup();
    this.layerManager.addMark("markLine", markLineGroup);
    this.ir.markDates.forEach((date2) => {
      const x2 = this.getScaledTimeX(date2) + sidePadding + this.sectionLabelWidth;
      const lineMark = makeMark("line", {
        x1: x2,
        x2,
        y1: yStart,
        y2: yEnd,
        lineWidth: 2,
        stroke: markLineColor
      });
      markLineGroup.children.push(lineMark);
    });
  }
};
var TASK_TAGS_INFO_MAP = {
  MILESTONE: {
    decorate(opts) {
      const { taskMark, conf: conf6 } = opts;
      const curAttrs = taskMark.attrs;
      const axisWidth = Math.min(20, conf6.barHeight);
      const diamondSide = axisWidth / 2;
      const centerX = curAttrs.x;
      const centerY = curAttrs.y + curAttrs.height / 2;
      const diamondMark = drawDiamondTo({ x: centerX, y: centerY }, diamondSide, curAttrs);
      return {
        taskMark: diamondMark,
        width: axisWidth,
        taskMarkOffset: { x: -axisWidth, y: 0 }
      };
    }
  },
  DONE: {
    decorate(opts) {
      const { taskMark } = opts;
      safeAssign(taskMark.attrs, {
        fillOpacity: 0.6
      });
      return {
        taskMark
      };
    }
  },
  CRIT: {
    decorate(opts) {
      const { taskMark } = opts;
      safeAssign(taskMark.attrs, {
        stroke: "red"
      });
      return {
        taskMark
      };
    }
  }
};
function getTaskAppearanceInfo(opts) {
  const task = opts.task;
  if (!task.tags)
    return;
  const info = {
    taskMark: opts.taskMark,
    width: opts.taskMark.attrs.width,
    taskMarkOffset: { x: 0, y: 0 }
  };
  let currentTaskMark = opts.taskMark;
  task.tags.forEach((tag2) => {
    const decorator = TASK_TAGS_INFO_MAP[tag2];
    if (decorator) {
      if (decorator.decorate) {
        Object.assign(info, decorator.decorate({
          ...opts,
          taskMark: currentTaskMark
        }));
        if (info.taskMark)
          currentTaskMark = info.taskMark;
      }
    }
  });
  info.taskMark = currentTaskMark;
  return info;
}
var artist_default7 = artist2;

// ../pintora-diagrams/lib/gantt/parser/gantt.js
var moo7 = __toESM(require_moo());
function id7(d) {
  return d[0];
}
function nth2(n2) {
  return function(d) {
    return d[n2];
  };
}
var COLOR7 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE7 = /@param/;
var CONFIG_DIRECTIVE8 = /@config/;
var L_PAREN7 = /\(/;
var R_PAREN7 = /\)/;
function getTokenValue7(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement7(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue7(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE7 = /%%.*/;
var ATTR_KEYWORDS = ["title", "dateFormat", "axisFormat", "axisInterval"];
var OTHER_KEYWORDS = ["section", "markDate", "excludes", "includes"];
var keywordRules = [...ATTR_KEYWORDS, ...OTHER_KEYWORDS].reduce((acc, text) => {
  const pattern = new RegExp(`${text}`);
  acc[text.toUpperCase()] = {
    match: pattern,
    push: "attr"
  };
  return acc;
}, {});
var commonTextRules2 = {
  QUOTED_WORD: QUOTED_WORD_REGEXP
};
var lexer7 = moo7.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: / +/, lineBreaks: false },
    ...commonTextRules2,
    ...keywordRules,
    COLON: /:/,
    LEFT_BRACE: /\{/,
    RIGHT_BRACE: /\}/,
    PARAM_DIRECTIVE: /@param/,
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    CONFIG_DIRECTIVE: CONFIG_DIRECTIVE8,
    VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
  },
  attr: {
    ...commonTextRules2,
    VALID_TEXT: { match: /[^\n]+/, pop: 1 }
  }
});
var grammar7 = {
  Lexer: lexer7,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id7 },
    { "name": "color", "symbols": [COLOR7], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE7, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE7, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE8, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement7 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE8, L_PAREN7, "configOpenCloseStatement$ebnf$1", R_PAREN7], "postprocess": handleConfigOpenCloseStatement7 },
    { "name": "comment", "symbols": [COMMENT_LINE7], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"] },
    { "name": "start", "symbols": [{ "literal": "gantt" }, "document"] },
    { "name": "document", "symbols": [] },
    { "name": "document", "symbols": ["document", "line"], "postprocess": (d) => {
      let r = d[0];
      if (d[1]) {
        r = d[0].concat(d[1]);
      }
      return r;
    } },
    { "name": "line$ebnf$1", "symbols": [lexer7.has("WS") ? { type: "WS" } : WS], "postprocess": id7 },
    { "name": "line$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$1", "statement"], "postprocess": nth2(1) },
    { "name": "line$ebnf$2", "symbols": [lexer7.has("WS") ? { type: "WS" } : WS], "postprocess": id7 },
    { "name": "line$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "line", "symbols": ["line$ebnf$2", lexer7.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement$ebnf$1", "symbols": [lexer7.has("WS") ? { type: "WS" } : WS], "postprocess": id7 },
    { "name": "statement$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "statement",
      "symbols": ["attrKey", "statement$ebnf$1", "words", lexer7.has("NL") ? { type: "NL" } : NL],
      "postprocess": (d) => {
        const value = d[2].trim();
        return { type: "addAttr", key: d[0], value };
      }
    },
    {
      "name": "statement",
      "symbols": [lexer7.has("SECTION") ? { type: "SECTION" } : SECTION, "words", lexer7.has("NL") ? { type: "NL" } : NL],
      "postprocess": (d) => {
        return { type: "addSection", label: d[1].trim() };
      }
    },
    {
      "name": "statement",
      "symbols": [lexer7.has("MARKDATE") ? { type: "MARKDATE" } : MARKDATE, "words", lexer7.has("NL") ? { type: "NL" } : NL],
      "postprocess": (d) => {
        return { type: "markDate", value: d[1].trim() };
      }
    },
    {
      "name": "statement",
      "symbols": ["words", lexer7.has("COLON") ? { type: "COLON" } : COLON, "words", lexer7.has("NL") ? { type: "NL" } : NL],
      "postprocess": (d) => {
        return { type: "addTask", label: d[0], extraValue: d[2] };
      }
    },
    { "name": "statement", "symbols": ["paramStatement", lexer7.has("NL") ? { type: "NL" } : NL], "postprocess": nth2(0) },
    { "name": "statement", "symbols": ["configOpenCloseStatement", lexer7.has("NL") ? { type: "NL" } : NL], "postprocess": nth2(0) },
    { "name": "statement", "symbols": ["comment", lexer7.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("TITLE") ? { type: "TITLE" } : TITLE] },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("DATEFORMAT") ? { type: "DATEFORMAT" } : DATEFORMAT] },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("AXISFORMAT") ? { type: "AXISFORMAT" } : AXISFORMAT] },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("AXISINTERVAL") ? { type: "AXISINTERVAL" } : AXISINTERVAL] },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("EXCLUDES") ? { type: "EXCLUDES" } : EXCLUDES] },
    { "name": "attrKey$subexpression$1", "symbols": [lexer7.has("INCLUDES") ? { type: "INCLUDES" } : INCLUDES] },
    { "name": "attrKey", "symbols": ["attrKey$subexpression$1"], "postprocess": (d) => {
      return tv(d[0][0]);
    } },
    { "name": "words$ebnf$1", "symbols": [] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer7.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer7.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": [lexer7.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, "words$ebnf$1"],
      "postprocess": function(d) {
        return tv(d[0]) + d[1].map((o) => tv(o[0])).join("");
      }
    },
    {
      "name": "words",
      "symbols": [lexer7.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD],
      "postprocess": function(d) {
        const vWithQuotes = tv(d[0]);
        return vWithQuotes.slice(1, vWithQuotes.length - 1);
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer7.has("WS") ? { type: "WS" } : WS] }
};
var gantt_default = grammar7;

// ../pintora-diagrams/lib/gantt/parser.js
var parse7 = genParserWithRules(gantt_default, {
  dedupeAmbigousResults: true,
  postProcess(results) {
    db_default6.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/gantt/index.js
var gantt = {
  pattern: /^\s*gantt/,
  parser: {
    parse(text) {
      parse7(text);
      return db_default6.getDiagramIR();
    }
  },
  artist: artist_default7,
  configKey: configKey7,
  clear() {
    db_default6.clear();
  }
};

// ../pintora-diagrams/lib/class/db.js
var Relation;
(function(Relation2) {
  Relation2["INHERITANCE"] = "INHERITANCE";
  Relation2["COMPOSITION"] = "COMPOSITION";
  Relation2["AGGREGATION"] = "AGGREGATION";
  Relation2["ASSOCIATION"] = "ASSOCIATION";
  Relation2["LINK"] = "LINK";
})(Relation || (Relation = {}));
var NAMESPACE_SEP = ".";
var FIELD_SEP = ":";
var ClassDb = class extends BaseDb {
  constructor() {
    super(...arguments);
    this.classes = {};
    this.relations = [];
    this.ACTION_HANDLERS = {
      addClass(action) {
        let classObj = this.classes[action.name];
        const { type, ...restData } = action;
        const data = this.parseClassAction(restData);
        if (!classObj) {
          classObj = data;
        } else {
          Object.assign(classObj, data);
        }
        this.classes[action.name] = classObj;
      },
      addClassMember(action) {
        const member = this.parseMemberLabel(action.member.raw);
        let classObj = this.classes[action.className];
        if (!classObj) {
          classObj = this.parseClassAction({ name: action.className, members: [] });
          this.classes[action.className] = classObj;
        }
        classObj.members.push(member);
      },
      addRelation(action) {
        let leftClass = this.classes[action.left];
        if (!leftClass) {
          leftClass = this.parseClassAction({ name: action.left, members: [] });
          this.classes[action.left] = leftClass;
        }
        let rightClass = this.classes[action.right];
        if (!rightClass) {
          rightClass = this.parseClassAction({ name: action.right, members: [] });
          this.classes[action.right] = rightClass;
        }
        const { relationRaw, ...other } = action;
        const relation = { ...other, relation: relationRaw.type };
        if (relationRaw.dashed) {
          relation.dashed = relationRaw.dashed;
        }
        this.relations.push(relation);
      },
      addAnnotation(action) {
        let classObj = this.classes[action.className];
        if (!classObj) {
          classObj = this.parseClassAction({ name: action.className, members: [] });
          this.classes[action.className] = classObj;
        }
        classObj.annotation = action.annotation;
      },
      overrideConfig(action) {
        this.addOverrideConfig(action);
      },
      addParam(action) {
        this.configParams.push(action);
      }
    };
  }
  parseClassAction(payload) {
    const fullName = payload.name;
    let name = payload.name;
    let namespace = "";
    let annotation = "";
    const members = [];
    if (payload.name.includes(NAMESPACE_SEP)) {
      const segs = payload.name.split(NAMESPACE_SEP);
      name = segs[segs.length - 1];
      namespace = segs.slice(0, segs.length - 1).join(NAMESPACE_SEP);
    }
    if (payload.members) {
      for (const m of payload.members) {
        if ("annotation" in m) {
          annotation = m.annotation;
        } else {
          const parsedMember = this.parseMemberLabel(m.raw);
          parsedMember.modifier = m.modifier;
          members.push(parsedMember);
        }
      }
    }
    const label = payload.label || name;
    return {
      ...payload,
      name,
      namespace,
      fullName,
      members,
      annotation,
      label
    };
  }
  parseMemberLabel(raw) {
    let name;
    let typeName = "";
    let temp = raw;
    const firstChar = temp[0];
    let access = "public";
    const isPrivate = firstChar === "-";
    const isProtected = firstChar === "#";
    const isPublic = firstChar === "+";
    if (isPrivate)
      access = "private";
    else if (isProtected)
      access = "protected";
    if (isPrivate || isProtected || isPublic)
      temp = temp.slice(1);
    if (temp.includes(FIELD_SEP)) {
      const pos = temp.indexOf(FIELD_SEP);
      name = temp.slice(0, pos);
      typeName = temp.slice(pos + 1, temp.length).trim();
    } else {
      const spacePos = temp.indexOf(" ");
      if (spacePos === -1) {
        name = temp.trim();
      } else {
        typeName = temp.slice(0, spacePos);
        name = temp.slice(spacePos + 1, temp.length).trim();
      }
    }
    const isMethod = /\(.*\)/.test(name);
    const member = {
      name,
      typeName,
      access,
      raw,
      isMethod
    };
    return member;
  }
  getDiagramIR() {
    return {
      ...super.getBaseDiagramIR(),
      classes: this.classes,
      relations: this.relations
    };
  }
  apply(action) {
    if (!action)
      return;
    if (Array.isArray(action)) {
      action.forEach((a) => this.apply(a));
      return;
    }
    if (action.type in this.ACTION_HANDLERS) {
      this.ACTION_HANDLERS[action.type].call(this, action);
    }
  }
  clear() {
    super.clear();
    this.classes = {};
    this.relations = [];
  }
};
var db8 = new ClassDb();
var db_default7 = db8;

// ../pintora-diagrams/lib/class/config.js
var defaultConfig8 = {
  diagramPadding: 15,
  layoutDirection: "TB",
  ranksep: 20,
  nodesep: 20,
  edgesep: 10,
  edgeType: "polyline",
  entityBackground: PALETTE.orange,
  entityBorderColor: PALETTE.normalDark,
  entityBodyBackground: PALETTE.white,
  entityTextColor: PALETTE.normalDark,
  labelBackground: PALETTE.white,
  relationLineColor: PALETTE.normalDark,
  relationTextColor: PALETTE.normalDark,
  entityRadius: 2,
  fontSize: 14,
  fontWeight: "normal",
  fontFamily: DEFAULT_FONT_FAMILY
};
var CLASS_PARAM_DIRECTIVE_RULES = {
  ...getParamRulesFromConfig(defaultConfig8)
};
var configKey8 = "class";
var configurator8 = makeConfigurator({
  defaultConfig: defaultConfig8,
  configKey: configKey8,
  getConfigFromParamDirectives(configParams) {
    return interpreteConfigs(CLASS_PARAM_DIRECTIVE_RULES, configParams);
  },
  getConfigFromTheme(t) {
    const primaryCorlorInstance = (0, import_tinycolor2.default)(t.primaryColor);
    const canvasBgInstance = (0, import_tinycolor2.default)(t.canvasBackground || PALETTE.white);
    const isBgLight = canvasBgInstance.isLight();
    let relationLineColor;
    if (isBgLight) {
      relationLineColor = PALETTE.normalDark;
    } else {
      relationLineColor = PALETTE.white;
    }
    const entityBodyBackground = primaryCorlorInstance.brighten(60).toHexString();
    return {
      entityBackground: t.primaryColor,
      entityBodyBackground,
      relationLineColor
    };
  }
});
var getConf8 = configurator8.getConfig;

// ../pintora-diagrams/lib/class/artist.js
var artist3 = makeArtist({
  draw(ir, config2, opts) {
    const rootMark = makeEmptyGroup();
    const conf6 = getConf8(ir, config2);
    const draw = new ClassDiagramDraw(ir, conf6);
    if (isDev) {
      ;
      window.classDraw = draw;
    }
    const { gBounds } = draw.drawTo(rootMark);
    const { width: width2, height } = adjustRootMarkBounds({
      rootMark,
      gBounds,
      padX: conf6.diagramPadding,
      padY: conf6.diagramPadding
    });
    return {
      mark: rootMark,
      width: width2,
      height
    };
  }
});
var ClassDiagramDraw = class {
  constructor(ir, conf6) {
    this.ir = ir;
    this.conf = conf6;
    this.relationGroupMark = makeEmptyGroup();
    this.elementBounds = makeBounds();
    const g = createLayoutGraph({
      multigraph: true,
      directed: true,
      compound: true
    }).setGraph({
      nodesep: 20,
      edgesep: conf6.edgesep,
      ranksep: conf6.ranksep,
      splines: getGraphSplinesOption(conf6.edgeType),
      avoid_label_on_border: true
    });
    this.dagreWrapper = new DagreWrapper(g);
  }
  drawTo(rootMark) {
    this.rootMark = rootMark;
    for (const classObj of Object.values(this.ir.classes)) {
      this.drawClass(classObj);
    }
    rootMark.children.push(this.relationGroupMark);
    for (const relation of this.ir.relations) {
      this.drawRelation(relation);
    }
    this.dagreWrapper.doLayout();
    this.dagreWrapper.callNodeOnLayout();
    this.dagreWrapper.callEdgeOnLayout();
    return {
      /** graph bounds */
      gBounds: tryExpandBounds(this.dagreWrapper.getGraphBounds(), this.elementBounds)
    };
  }
  /**
   * Draw one class
   */
  drawClass(classObj) {
    const markBuilder = new EntityMarkBuilder(this.dagreWrapper.g, this.conf);
    markBuilder.addHeader(classObj.fullName, classObj.annotation);
    this.markBuilder = markBuilder;
    const fields = classObj.members.filter((m) => !m.isMethod);
    const methods = classObj.members.filter((m) => m.isMethod);
    for (const memberList of [fields, methods]) {
      const { index: index2 } = markBuilder.getCurrentSection();
      const nextSectionIndex = index2 + 1;
      if (memberList.length) {
        for (const member of memberList) {
          markBuilder.addRow(nextSectionIndex, member.raw);
        }
      } else {
        markBuilder.addRow(nextSectionIndex, "");
      }
    }
    this.rootMark.children.push(markBuilder.group);
    const g = this.dagreWrapper.g;
    const entitySize = markBuilder.getSize();
    g.setNode(classObj.fullName, {
      ...entitySize,
      onLayout(data) {
        markBuilder.onLayout(data);
      }
    });
  }
  drawRelation(r) {
    const g = this.dagreWrapper.g;
    const { conf: conf6, relationGroupMark } = this;
    let labelDims;
    const fontConfig = {
      fontSize: conf6.fontSize,
      fontFamily: conf6.fontFamily
    };
    let minlen = 1;
    if (r.label) {
      labelDims = calculateTextDimensions(r.label, fontConfig);
      minlen = Math.ceil(labelDims.height / conf6.ranksep) + 1;
      const startNode = g.node(r.left);
      const extraPad = (labelDims.width - startNode.width) / 2;
      if (extraPad > 0) {
        startNode.marginr = extraPad;
        startNode.marginl = extraPad;
      }
    }
    const leftLabelDims = r.labelLeft ? calculateTextDimensions(r.labelLeft, fontConfig) : null;
    const rightLabelDims = r.labelRight ? calculateTextDimensions(r.labelRight, fontConfig) : null;
    let leftLabelMark;
    let rightLabelMark;
    if (r.labelLeft) {
      minlen += Math.ceil(leftLabelDims.height / conf6.ranksep);
      leftLabelMark = makeMark("text", {
        text: r.labelLeft,
        fill: conf6.relationLineColor,
        class: "class__label",
        ...fontConfig
      });
      relationGroupMark.children.push(leftLabelMark);
    }
    if (r.labelRight) {
      minlen += Math.ceil(rightLabelDims.height / conf6.ranksep);
      rightLabelMark = makeMark("text", {
        text: r.labelRight,
        fill: conf6.relationLineColor,
        class: "class__label",
        ...fontConfig
      });
      relationGroupMark.children.push(rightLabelMark);
    }
    g.setEdge(r.left, r.right, {
      label: r.relation,
      minlen,
      onLayout: (data) => {
        const newPath = conf6.edgeType === "curved" ? getPointsCurvePath(data.points) : getPointsLinearPath(data.points);
        const lineMark = makeMark("path", {
          path: newPath,
          stroke: conf6.relationLineColor,
          lineCap: "round",
          lineDash: r.dashed ? [2, 2] : null
        }, { class: "class__rel-line" });
        relationGroupMark.children.push(lineMark);
        if (r.label) {
          const anchorPoint = (minlen === 1 ? data.labelPoint : null) || getMedianPoint(data.points).point;
          const relText = makeMark("text", {
            text: r.label,
            fill: conf6.relationTextColor,
            textAlign: "center",
            textBaseline: "middle",
            ...anchorPoint,
            ...fontConfig
          }, { class: "class__rel-text" });
          const relTextBg = makeLabelBg(labelDims, anchorPoint, {
            fill: conf6.labelBackground
          });
          const labelBounds = calcBound([relTextBg]);
          tryExpandBounds(this.elementBounds, labelBounds);
          relationGroupMark.children.push(relTextBg, relText);
        }
        const lastPoint = data.points[data.points.length - 1];
        const pointsForDirection = data.points.slice(-2);
        const arrowRad = calcDirection.apply(null, pointsForDirection);
        const arrowHeadType = RELATION_TO_ARROW_TYPE[r.relation];
        if (arrowHeadType) {
          const arrowMark = drawArrowTo(lastPoint, 8, arrowRad, {
            color: conf6.relationLineColor,
            type: arrowHeadType
          });
          relationGroupMark.children.push(arrowMark);
        }
        const LABEL_X_OFFSET = 5;
        if (leftLabelMark) {
          const startIntersectionPoint = data.points[2];
          safeAssign(leftLabelMark.attrs, movePointPosition(startIntersectionPoint, { x: LABEL_X_OFFSET, y: 0 }));
        }
        if (rightLabelMark) {
          safeAssign(rightLabelMark.attrs, movePointPosition(lastPoint, { x: LABEL_X_OFFSET, y: 0 }));
        }
      }
    });
  }
};
var RELATION_TO_ARROW_TYPE = {
  [Relation.INHERITANCE]: "etriangle",
  [Relation.ASSOCIATION]: "default",
  [Relation.COMPOSITION]: "diamond",
  [Relation.AGGREGATION]: "ediamond"
};
var EntityMarkBuilder = class {
  constructor(g, conf6) {
    this.g = g;
    this.conf = conf6;
    this.group = makeEmptyGroup();
    this.rowPadding = 5;
    this.curY = 0;
    this.curHeight = 0;
    this.sections = [];
  }
  addHeader(label, annotation) {
    let row;
    if (annotation) {
      row = this.addRow(0, [`<<${annotation}>>`, label]);
    } else {
      row = this.addRow(0, label);
    }
    row.isHeader = true;
    last(row.labelMarks).attrs.fontWeight = "bold";
    return row;
  }
  addRow(sectionIndex, labels) {
    if (!this.sections[sectionIndex]) {
      this.sections[sectionIndex] = {
        rows: []
      };
    }
    const section = this.sections[sectionIndex];
    if (typeof labels === "string") {
      labels = [labels];
    }
    const { rowPadding } = this;
    const labelMarks = [];
    const labelDims = { width: 0, height: 0 };
    let labelYOffset = 0;
    for (const label of labels) {
      const fontConfig = this.getFontConfig();
      const dims = calculateTextDimensions(label, fontConfig);
      const labelMark = makeMark("text", {
        text: label,
        fill: this.conf.entityTextColor,
        x: 0,
        y: this.curY + labelYOffset + rowPadding,
        textAlign: "center",
        textBaseline: "hanging",
        ...dims,
        ...this.getFontConfig()
      });
      const labelYDiff = dims.height + Math.floor(fontConfig.fontSize / 4);
      labelYOffset += labelYDiff;
      labelMarks.push(labelMark);
      labelDims.width = Math.max(labelDims.width, dims.width);
      labelDims.height += labelYDiff;
    }
    const yOffsetStart = this.curY;
    const yDiff = labelDims.height + rowPadding * 2;
    this.curY += yDiff;
    this.curHeight += yDiff;
    const row = { labels, labelMarks, labelDims, yOffsetStart, yOffsetEnd: this.curY };
    section.rows.push(row);
    this.group.children.push(...labelMarks);
    return row;
  }
  getCurrentSection() {
    const currentIndex = this.sections.length - 1;
    return {
      index: currentIndex,
      section: this.sections[currentIndex]
    };
  }
  getSize() {
    let maxWidth = 0;
    for (const section of this.sections) {
      for (const row of section.rows) {
        const { labelDims } = row;
        maxWidth = Math.max(labelDims.width, maxWidth);
      }
    }
    return {
      width: maxWidth + this.rowPadding * 2,
      height: this.curHeight
    };
  }
  onLayout(data) {
    const rectSize = this.getSize();
    const bgRect = makeMark("rect", {
      ...rectSize,
      x: -rectSize.width / 2,
      y: -rectSize.height / 2,
      fill: this.conf.entityBackground,
      radius: this.conf.entityRadius,
      stroke: this.conf.entityBorderColor
    });
    const halfClassHeight = rectSize.height / 2;
    const sectionBgMarks = [];
    const { rowPadding } = this;
    const lastSection = last(this.sections);
    let bodySectionYStart = void 0;
    let bodySectionYEnd = void 0;
    this.sections.forEach((section, sectionIndex) => {
      if (!section.rows.length) {
        return;
      }
      for (const row of section.rows) {
        for (const labelMark of row.labelMarks) {
          if (!row.isHeader) {
            labelMark.attrs.x += (labelMark.attrs.width - rectSize.width) / 2 + rowPadding;
          }
          labelMark.attrs.y += -halfClassHeight + rowPadding;
        }
      }
      const firstRow = section.rows[0];
      const lastRow = last(section.rows);
      if (sectionIndex === 1) {
        bodySectionYStart = firstRow.yOffsetStart - halfClassHeight + rowPadding;
      }
      if (sectionIndex > 0) {
        const lineY = firstRow.yOffsetStart - halfClassHeight + rowPadding;
        const sepLine = makeMark("line", {
          x1: -rectSize.width / 2,
          x2: rectSize.width / 2,
          y1: lineY,
          y2: lineY,
          stroke: this.conf.entityBorderColor
        }, { class: "class-entity__sep-line" });
        this.group.children.push(sepLine);
      }
      if (section === lastSection) {
        bodySectionYEnd = lastRow.yOffsetEnd - halfClassHeight;
      }
    });
    if (typeof bodySectionYStart !== "undefined" && typeof bodySectionYEnd !== "undefined") {
      const lineY = bodySectionYStart;
      const sectionBg = makeMark("rect", {
        width: rectSize.width,
        height: bodySectionYEnd - bodySectionYStart,
        x: -rectSize.width / 2,
        y: lineY,
        fill: this.conf.entityBodyBackground,
        stroke: this.conf.entityBorderColor,
        class: "class__section-bg"
        // opacity: 0.4, // for layout debug
      });
      this.group.children.unshift(sectionBg);
    }
    this.group.children.unshift(bgRect, ...sectionBgMarks);
    positionGroupContents(this.group, data);
  }
  getFontConfig() {
    return {
      fontFamily: this.conf.fontFamily,
      fontSize: this.conf.fontSize
    };
  }
};
var artist_default8 = artist3;

// ../pintora-diagrams/lib/class/parser/classDiagram.js
var moo8 = __toESM(require_moo());
function id8(d) {
  return d[0];
}
var COLOR8 = /#[a-zA-Z0-9]+/;
var PARAM_DIRECTIVE8 = /@param/;
var CONFIG_DIRECTIVE9 = /@config/;
var L_PAREN8 = /\(/;
var R_PAREN8 = /\)/;
function getTokenValue8(token) {
  if (token && "value" in token)
    return token.value;
  return token;
}
function handleConfigOpenCloseStatement8(d) {
  const text = d[2].map((v) => {
    if (v.type)
      return getTokenValue8(v);
    return v;
  }).join("");
  try {
    const v = JSON.parse(text);
    return { type: "overrideConfig", value: v };
  } catch (error) {
    return { type: "overrideConfig", error };
  }
}
var COMMENT_LINE8 = /%%.*/;
var COMMON_TOKEN_RULES4 = {
  VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
};
var lexer8 = moo8.states({
  main: {
    NL: MOO_NEWLINE,
    WS: { match: /[ \t]+/, lineBreaks: false },
    QUOTED_WORD: QUOTED_WORD_REGEXP,
    COLOR: COLOR_REGEXP,
    SEMICOLON: /;/,
    COLON: /:/,
    COMMA: /,/,
    CLASS_DIAGRAM: /classDiagram/,
    L_PAREN: L_PAREN_REGEXP,
    R_PAREN: R_PAREN_REGEXP,
    L_BRACKET: { match: /\{/ },
    R_BRACKET: { match: /\}/ },
    L_SQ_BRACKET: { match: /\[/ },
    R_SQ_BRACKET: { match: /\]/ },
    TEXT_WITH_ANGLE_BRACKETS: { match: /\<\<(?:.*)\>\>/ },
    EQ: { match: /=/ },
    // RELATION_INHERITANCE: { match: /\<\|\-\-/ },
    SUBGRAPH: { match: /subgraph/ },
    START_NOTE: textToCaseInsensitiveRegex("@note"),
    END_NOTE: textToCaseInsensitiveRegex("@end_note"),
    COMMENT_LINE: COMMENT_LINE_REGEXP,
    ...configLexerMainState,
    VALID_TEXT: { match: VALID_TEXT_REGEXP, fallback: true }
  },
  configStatement: {
    ...configLexerconfigStatementState,
    ...COMMON_TOKEN_RULES4
  }
});
var nth0 = makeNth(0);
var nth1 = makeNth(1);
var grammar8 = {
  Lexer: lexer8,
  ParserRules: [
    { "name": "_$ebnf$1", "symbols": [] },
    { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "__$ebnf$1", "symbols": ["wschar"] },
    { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": function(d) {
      return null;
    } },
    { "name": "wschar", "symbols": [/[ \t\n\v\f\r]/], "postprocess": id8 },
    { "name": "color", "symbols": [COLOR8], "postprocess": (d) => tv(d[0]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE8, "__", "paramPart"],
      "postprocess": function(d) {
        return d[2];
      }
    },
    { "name": "paramStatement$ebnf$1", "symbols": [] },
    { "name": "paramStatement$ebnf$1$subexpression$1", "symbols": [/[\n]/, "_", "paramPart"] },
    { "name": "paramStatement$ebnf$1", "symbols": ["paramStatement$ebnf$1", "paramStatement$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "paramStatement",
      "symbols": [PARAM_DIRECTIVE8, "__", { "literal": "{" }, "_", "paramStatement$ebnf$1", /[\n]/, "_", { "literal": "}" }],
      "postprocess": function(d) {
        const params = [];
        d[4].forEach((seg) => {
          params.push(seg[2]);
        });
        return params;
      }
    },
    { "name": "paramPart$ebnf$1", "symbols": [/[a-zA-Z0-9]/] },
    { "name": "paramPart$ebnf$1", "symbols": ["paramPart$ebnf$1", /[a-zA-Z0-9]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart$ebnf$2", "symbols": [/[^ \n]/] },
    { "name": "paramPart$ebnf$2", "symbols": ["paramPart$ebnf$2", /[^ \n]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "paramPart", "symbols": ["paramPart$ebnf$1", "__", "paramPart$ebnf$2"], "postprocess": function(d) {
      const key = d[0].map((v) => tv(v)).join("");
      let value = d[2];
      if (typeof value !== "string")
        value = value.map((v) => tv(v)).join("");
      return { type: "addParam", key, value };
    } },
    { "name": "configStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configStatement$ebnf$1", "symbols": ["configStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configStatement", "symbols": [CONFIG_DIRECTIVE9, { "literal": "(" }, "configStatement$ebnf$1", { "literal": ")" }], "postprocess": handleConfigOpenCloseStatement8 },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": [/[^\)]/] },
    { "name": "configOpenCloseStatement$ebnf$1", "symbols": ["configOpenCloseStatement$ebnf$1", /[^\)]/], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "configOpenCloseStatement", "symbols": [CONFIG_DIRECTIVE9, L_PAREN8, "configOpenCloseStatement$ebnf$1", R_PAREN8], "postprocess": handleConfigOpenCloseStatement8 },
    { "name": "comment", "symbols": [COMMENT_LINE8], "postprocess": (d) => null },
    { "name": "start", "symbols": ["__", "start"], "postprocess": nth1 },
    {
      "name": "start",
      "symbols": [lexer8.has("CLASS_DIAGRAM") ? { type: "CLASS_DIAGRAM" } : CLASS_DIAGRAM, "document"],
      "postprocess": function(d) {
        return d[1];
      }
    },
    { "name": "document", "symbols": [] },
    {
      "name": "document",
      "symbols": ["document", "statementWrap"],
      "postprocess": (d) => {
        let r = d[0];
        if (d[1]) {
          r = d[0].concat(d[1]);
        }
        return r;
      }
    },
    { "name": "statementWrap$ebnf$1", "symbols": [] },
    { "name": "statementWrap$ebnf$1", "symbols": ["statementWrap$ebnf$1", lexer8.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "statementWrap", "symbols": ["statementWrap$ebnf$1", "statement"], "postprocess": (d) => {
      return d[1];
    } },
    { "name": "statementWrap$ebnf$2", "symbols": [lexer8.has("WS") ? { type: "WS" } : WS], "postprocess": id8 },
    { "name": "statementWrap$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "statementWrap", "symbols": ["statementWrap$ebnf$2", lexer8.has("NL") ? { type: "NL" } : NL], "postprocess": null },
    { "name": "statement", "symbols": ["classStatement"] },
    { "name": "statement", "symbols": ["memberLabelStatement"] },
    { "name": "statement", "symbols": ["relationStatement"] },
    { "name": "statement", "symbols": ["classAnnotationStatement"] },
    { "name": "statement", "symbols": ["paramStatement", lexer8.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["configOpenCloseStatement", lexer8.has("NL") ? { type: "NL" } : NL] },
    { "name": "statement", "symbols": ["comment", lexer8.has("NL") ? { type: "NL" } : NL] },
    { "name": "classStatement$ebnf$1", "symbols": [lexer8.has("NL") ? { type: "NL" } : NL], "postprocess": id8 },
    { "name": "classStatement$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "classStatement$ebnf$2", "symbols": ["classMembers"], "postprocess": id8 },
    { "name": "classStatement$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "classStatement$ebnf$3", "symbols": [lexer8.has("NL") ? { type: "NL" } : NL], "postprocess": id8 },
    { "name": "classStatement$ebnf$3", "symbols": [], "postprocess": () => null },
    {
      "name": "classStatement",
      "symbols": [{ "literal": "class" }, lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer8.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "classStatement$ebnf$1", "classStatement$ebnf$2", "classStatement$ebnf$3", lexer8.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET, lexer8.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const members = d[4];
        return {
          type: "addClass",
          name: tv(d[1]),
          members
        };
      }
    },
    {
      "name": "classStatement",
      "symbols": [{ "literal": "class" }, "textInQuote", { "literal": "as" }, lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer8.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return {
          type: "addClass",
          name: tv(d[3]),
          label: d[1],
          members: []
        };
      }
    },
    {
      "name": "classStatement",
      "symbols": [{ "literal": "class" }, lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer8.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        return {
          type: "addClass",
          name: tv(d[1]),
          members: []
        };
      }
    },
    { "name": "classMembers", "symbols": ["classMember"] },
    { "name": "classMembers", "symbols": ["annotation"] },
    { "name": "classMembers$subexpression$1", "symbols": ["annotation"] },
    { "name": "classMembers$subexpression$1", "symbols": ["classMember"] },
    {
      "name": "classMembers",
      "symbols": ["classMembers", lexer8.has("NL") ? { type: "NL" } : NL, "classMembers$subexpression$1"],
      "postprocess": function(d) {
        return [...d[0], ...d[2]];
      }
    },
    { "name": "classMember$ebnf$1", "symbols": ["modifier"], "postprocess": id8 },
    { "name": "classMember$ebnf$1", "symbols": [], "postprocess": () => null },
    {
      "name": "classMember",
      "symbols": ["classMember$ebnf$1", "memberLabel"],
      "postprocess": function(d) {
        const modifier = d[0] ? d[0] : null;
        return {
          raw: d[1],
          modifier
        };
      }
    },
    { "name": "words$ebnf$1", "symbols": [] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "words$ebnf$1$subexpression$1", "symbols": [lexer8.has("WS") ? { type: "WS" } : WS] },
    { "name": "words$ebnf$1", "symbols": ["words$ebnf$1", "words$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "words",
      "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, "words$ebnf$1"],
      "postprocess": function(d) {
        return tv(d[0]) + d[1].map((o) => tv(o[0])).join("");
      }
    },
    { "name": "memberLabel$ebnf$1", "symbols": [] },
    { "name": "memberLabel$ebnf$1$subexpression$1", "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT] },
    { "name": "memberLabel$ebnf$1$subexpression$1", "symbols": [lexer8.has("L_PAREN") ? { type: "L_PAREN" } : L_PAREN8] },
    { "name": "memberLabel$ebnf$1$subexpression$1", "symbols": [lexer8.has("R_PAREN") ? { type: "R_PAREN" } : R_PAREN8] },
    { "name": "memberLabel$ebnf$1$subexpression$1", "symbols": [lexer8.has("COLON") ? { type: "COLON" } : COLON] },
    { "name": "memberLabel$ebnf$1$subexpression$1", "symbols": [lexer8.has("WS") ? { type: "WS" } : WS] },
    { "name": "memberLabel$ebnf$1", "symbols": ["memberLabel$ebnf$1", "memberLabel$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
    {
      "name": "memberLabel",
      "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, "memberLabel$ebnf$1"],
      "postprocess": function(d) {
        return tv(d[0]) + d[1].map((o) => tv(o[0])).join("");
      }
    },
    { "name": "modifier$subexpression$1", "symbols": [{ "literal": "static" }] },
    { "name": "modifier$subexpression$1", "symbols": [{ "literal": "abstract" }] },
    {
      "name": "modifier",
      "symbols": [lexer8.has("L_BRACKET") ? { type: "L_BRACKET" } : L_BRACKET, "modifier$subexpression$1", lexer8.has("R_BRACKET") ? { type: "R_BRACKET" } : R_BRACKET],
      "postprocess": function(d) {
        return tv(d[1][0]);
      }
    },
    {
      "name": "memberLabelStatement",
      "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT, lexer8.has("COLON") ? { type: "COLON" } : COLON, "classMember", lexer8.has("NL") ? { type: "NL" } : NL],
      "postprocess": function(d) {
        const className = tv(d[0]);
        return {
          type: "addClassMember",
          className,
          member: d[2]
        };
      }
    },
    { "name": "relationStatement$ebnf$1", "symbols": ["textInQuote"], "postprocess": id8 },
    { "name": "relationStatement$ebnf$1", "symbols": [], "postprocess": () => null },
    { "name": "relationStatement$ebnf$2", "symbols": ["textInQuote"], "postprocess": id8 },
    { "name": "relationStatement$ebnf$2", "symbols": [], "postprocess": () => null },
    { "name": "relationStatement$ebnf$3$subexpression$1$ebnf$1", "symbols": [] },
    { "name": "relationStatement$ebnf$3$subexpression$1$ebnf$1", "symbols": ["relationStatement$ebnf$3$subexpression$1$ebnf$1", lexer8.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "relationStatement$ebnf$3$subexpression$1$ebnf$2", "symbols": [] },
    { "name": "relationStatement$ebnf$3$subexpression$1$ebnf$2", "symbols": ["relationStatement$ebnf$3$subexpression$1$ebnf$2", lexer8.has("WS") ? { type: "WS" } : WS], "postprocess": (d) => d[0].concat([d[1]]) },
    { "name": "relationStatement$ebnf$3$subexpression$1", "symbols": ["relationStatement$ebnf$3$subexpression$1$ebnf$1", lexer8.has("COLON") ? { type: "COLON" } : COLON, "relationStatement$ebnf$3$subexpression$1$ebnf$2", "words"] },
    { "name": "relationStatement$ebnf$3", "symbols": ["relationStatement$ebnf$3$subexpression$1"], "postprocess": id8 },
    { "name": "relationStatement$ebnf$3", "symbols": [], "postprocess": () => null },
    {
      "name": "relationStatement",
      "symbols": ["classInRelation", "relationStatement$ebnf$1", "relation", "relationStatement$ebnf$2", "classInRelation", "relationStatement$ebnf$3"],
      "postprocess": function(d) {
        let relationRaw = { type: d[2], dashed: false };
        let labelLeft = d[1];
        let labelRight = d[3];
        if (d[2].type) {
          relationRaw = d[2];
        }
        let label = "";
        if (d[5]) {
          label = d[5][3];
        }
        return {
          type: "addRelation",
          left: d[0].name,
          right: d[4].name,
          relationRaw: d[2],
          labelLeft,
          labelRight,
          label,
          dashed: Boolean(relationRaw.dashed)
        };
      }
    },
    { "name": "classInRelation", "symbols": [lexer8.has("VALID_TEXT") ? { type: "VALID_TEXT" } : VALID_TEXT], "postprocess": (d) => ({ name: tv(d[0]) }) },
    { "name": "relation", "symbols": [{ "literal": "<|--" }], "postprocess": (d) => {
      return { type: Relation.INHERITANCE };
    } },
    { "name": "relation", "symbols": [{ "literal": "<|.." }], "postprocess": (d) => {
      return { type: Relation.INHERITANCE, dashed: true };
    } },
    { "name": "relation", "symbols": [{ "literal": "*--" }], "postprocess": (d) => {
      return { type: Relation.COMPOSITION };
    } },
    { "name": "relation", "symbols": [{ "literal": "*.." }], "postprocess": (d) => {
      return { type: Relation.COMPOSITION, dashed: true };
    } },
    { "name": "relation", "symbols": [{ "literal": "o--" }], "postprocess": (d) => {
      return { type: Relation.AGGREGATION };
    } },
    { "name": "relation", "symbols": [{ "literal": "o.." }], "postprocess": (d) => {
      return { type: Relation.AGGREGATION, dashed: true };
    } },
    { "name": "relation", "symbols": [{ "literal": "-->" }], "postprocess": (d) => {
      return { type: Relation.ASSOCIATION };
    } },
    { "name": "relation", "symbols": [{ "literal": "..>" }], "postprocess": (d) => {
      return { type: Relation.ASSOCIATION, dashed: true };
    } },
    { "name": "relation", "symbols": [{ "literal": "<--" }], "postprocess": (d) => {
      return { type: Relation.ASSOCIATION };
    } },
    { "name": "relation", "symbols": [{ "literal": "<.." }], "postprocess": (d) => {
      return { type: Relation.ASSOCIATION };
    } },
    { "name": "relation", "symbols": [{ "literal": "--" }], "postprocess": (d) => {
      return { type: Relation.LINK };
    } },
    { "name": "relation", "symbols": [{ "literal": ".." }], "postprocess": (d) => {
      return { type: Relation.LINK, dashed: true };
    } },
    {
      "name": "classAnnotationStatement",
      "symbols": ["annotation", "classInRelation"],
      "postprocess": function(d) {
        return {
          type: "addAnnotation",
          annotation: d[0].annotation,
          className: d[1].name
        };
      }
    },
    {
      "name": "annotation",
      "symbols": [lexer8.has("TEXT_WITH_ANGLE_BRACKETS") ? { type: "TEXT_WITH_ANGLE_BRACKETS" } : TEXT_WITH_ANGLE_BRACKETS],
      "postprocess": function(d) {
        const v = tv(d[0]);
        return {
          type: "annotation",
          annotation: v.replace(/\<\<(.*)\>\>/, "$1").trim()
        };
      }
    },
    {
      "name": "textInQuote",
      "symbols": [lexer8.has("QUOTED_WORD") ? { type: "QUOTED_WORD" } : QUOTED_WORD],
      "postprocess": function(d) {
        return getQuotedWord(d[0]);
      }
    }
  ],
  ParserStart: "start",
  ParserOptions: { skipUnmatchSymbols: [lexer8.has("WS") ? { type: "WS" } : WS] }
};
var classDiagram_default = grammar8;

// ../pintora-diagrams/lib/class/parser.js
var parse8 = genParserWithRules(classDiagram_default, {
  dedupeAmbigousResults: true,
  postProcess(results) {
    db_default7.apply(results);
    return results;
  }
});

// ../pintora-diagrams/lib/class/index.js
var classDiagram = {
  pattern: /^\s*classDiagram/,
  parser: {
    parse(text) {
      parse8(text);
      return db_default7.getDiagramIR();
    }
  },
  artist: artist_default8,
  configKey: "class",
  clear() {
    db_default7.clear();
  }
};

// ../pintora-diagrams/lib/util/symbols/database.js
var HEADER_ELLIPSE_RY = 12;
symbolRegistry.register("database", {
  type: "factory",
  modes: ["container", "icon"],
  symbolMargin: {
    top: HEADER_ELLIPSE_RY * 2
  },
  factory(contentArea, { mode }) {
    if (mode === "container") {
      return makeDatabaseContainer(contentArea);
    }
    return makeDatabaseIcon(contentArea);
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeDatabaseIcon({ width: width2, height, x: x2, y: y2 }) {
  const rx = width2 / 2;
  const ry = HEADER_ELLIPSE_RY;
  const halfHeight = height / 2;
  const ellipseY = y2 - halfHeight + ry;
  const lineBottomY = y2 + halfHeight - ry;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        path: [
          ["M", x2 - rx, ellipseY],
          ["L", x2 - rx, lineBottomY],
          ["A", rx, ry, 0, 1, 0, x2 + rx, lineBottomY],
          ["L", x2 + rx, ellipseY]
          // right top
        ],
        stroke: PALETTE.normalDark
      }),
      makeMark("ellipse", {
        x: x2,
        y: ellipseY,
        cx: x2,
        cy: y2,
        rx,
        ry,
        stroke: PALETTE.normalDark
      })
    ]
  });
  return makeMark("symbol", {}, {
    mark
  });
}
function makeDatabaseContainer({ width: width2, height, x: x2, y: y2 }) {
  const rx = width2 / 2;
  const ry = 12;
  const halfHeight = height / 2;
  const ellipseY = y2 - halfHeight - ry;
  const lineBottomY = y2 + halfHeight;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        path: [
          ["M", x2 - rx, ellipseY],
          ["L", x2 - rx, lineBottomY],
          ["A", rx, ry, 0, 1, 0, x2 + rx, lineBottomY],
          ["L", x2 + rx, ellipseY]
          // right top
        ],
        stroke: PALETTE.normalDark
      }),
      makeMark("ellipse", {
        x: x2,
        y: ellipseY,
        cx: x2,
        cy: y2,
        rx,
        ry,
        stroke: PALETTE.normalDark
      })
    ]
  });
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: -rx,
      right: rx,
      top: -(halfHeight + 2 * ry),
      bottom: halfHeight + ry,
      width: width2,
      height: height + ry * 3
    }
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/package.js
var HEADER_HEIGHT = 12;
symbolRegistry.register("package", {
  type: "factory",
  symbolMargin: {
    top: HEADER_HEIGHT
  },
  factory({ width: width2, height, x: x2, y: y2 }) {
    const halfHeight = height / 2;
    const halfWidth = width2 / 2;
    const leftX = x2 - width2 / 2;
    const topY = y2 - halfHeight;
    const HEADER_HEIGHT2 = 12;
    const mark = makeMark("group", {}, {
      children: [
        makeMark("path", {
          path: [
            ["M", leftX, topY],
            ["L", leftX, topY - HEADER_HEIGHT2],
            ["L", leftX + width2 / 2, topY - HEADER_HEIGHT2],
            ["L", leftX + width2 / 2 + 4, topY]
            // right bottom of label
          ]
        }),
        makeMark("rect", {
          x: leftX,
          y: topY,
          width: width2,
          height
        })
      ]
    });
    const sym = makeMark("symbol", {}, {
      mark,
      symbolBounds: {
        left: -halfWidth,
        right: halfWidth,
        top: -HEADER_HEIGHT2 - halfHeight,
        bottom: halfHeight,
        width: width2,
        height: height + HEADER_HEIGHT2
      }
    });
    return sym;
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
symbolRegistry.register("folder", symbolRegistry.get("package"));

// ../pintora-diagrams/lib/util/symbols/node.js
var PROJECT_X = 12;
var PROJECT_Y = 12;
symbolRegistry.register("node", {
  type: "factory",
  modes: ["container", "icon"],
  symbolMargin: {
    top: PROJECT_Y,
    right: PROJECT_X
  },
  factory(contentArea, { mode }) {
    if (mode === "icon") {
      const height = contentArea.height - PROJECT_Y;
      const newArea = {
        x: contentArea.x,
        y: contentArea.y + PROJECT_Y / 2,
        width: clamp(contentArea.width - PROJECT_X, contentArea.width * 0.6, height),
        height
      };
      return makeNode(newArea);
    }
    return makeNode(contentArea);
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeNode(contentArea) {
  const { width: width2, height, x: x2, y: y2 } = contentArea;
  const halfHeight = height / 2;
  const halfWidth = width2 / 2;
  const leftX = x2 - width2 / 2;
  const topY = y2 - halfHeight;
  const projectX = PROJECT_X;
  const projectY = PROJECT_Y;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        lineJoin: "round",
        path: [
          ["M", leftX, topY],
          ["L", leftX + projectX, topY - projectY],
          ["L", leftX + projectX + width2, topY - projectY],
          ["L", leftX + width2, topY],
          ["M", leftX + projectX + width2, topY - projectY],
          ["L", leftX + projectX + width2, topY - projectY + height],
          ["L", leftX + width2, topY + height],
          ["L", leftX + width2, topY]
        ]
      }),
      makeMark("rect", {
        x: leftX,
        y: topY,
        width: width2,
        height
      })
    ]
  });
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: -halfWidth,
      right: halfWidth,
      top: -projectY - halfHeight,
      bottom: halfHeight,
      width: width2 + projectY,
      height: height + projectY
    }
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/cloud.js
symbolRegistry.register("cloud", {
  type: "factory",
  // only valid in container mode
  symbolMargin: {
    top: 20
  },
  factory(contentArea, { mode }) {
    if (mode === "container") {
      return makeCloudContainer(contentArea);
    }
    return makeCloudIcon(contentArea);
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeCloudIcon({ width: width2, height, x: x2, y: y2 }) {
  const leftX = x2 - width2 / 2;
  const topY = y2 - height / 2;
  const CLOUD_ICON_HEIGHT = 24;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        lineJoin: "round",
        lineWidth: 3,
        path: [
          `M ${leftX} ${topY - CLOUD_ICON_HEIGHT}`,
          "m 23.2 12.1 c -0.8 -4.1 -4.4 -7.3 -8.8 -7.3 c -3.5 0 -6.5 2 -8 4.9 c -3.6 0.4 -6.4 3.4 -6.4 7.1 c 0 4 3.2 7.2 7.2 7.2 h 15.6 c 3.3 0 6 -2.7 6 -6 c 0 -3.2 -2.5 -5.8 -5.6 -5.9 z"
        ].join(" ")
      })
    ]
  });
  return makeMark("symbol", {}, {
    mark
  });
}
function makeCloudContainer({ width: width2, height, x: x2, y: y2 }) {
  const halfWidth = width2 / 2;
  const ry = height / 2;
  const rx = halfWidth + ry / Math.sqrt(3);
  const leftX = x2 - width2 / 2;
  const topY = y2 - height / 2;
  const CLOUD_ICON_HEIGHT = 24;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        lineJoin: "round",
        lineWidth: 3,
        path: [
          `M ${leftX} ${topY - CLOUD_ICON_HEIGHT + 4}`,
          "m 23.2 12.1 c -0.8 -4.1 -4.4 -7.3 -8.8 -7.3 c -3.5 0 -6.5 2 -8 4.9 c -3.6 0.4 -6.4 3.4 -6.4 7.1 c 0 4 3.2 7.2 7.2 7.2 h 15.6 c 3.3 0 6 -2.7 6 -6 c 0 -3.2 -2.5 -5.8 -5.6 -5.9 z"
        ].join(" ")
      }),
      makeMark("rect", {
        x: leftX,
        y: topY,
        width: width2,
        height
      })
    ]
  });
  const outerWidth = rx;
  const outerHeight = height;
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: -outerWidth / 2,
      right: outerWidth / 2,
      top: -outerHeight / 2,
      bottom: outerHeight / 2,
      width: outerWidth,
      height: outerHeight
    }
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/actor.js
symbolRegistry.register("actor", {
  type: "factory",
  modes: ["icon"],
  factory(contentArea) {
    return makeIcon(contentArea);
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
      if (child.type === "path") {
        child.attrs.fill = null;
      }
      child.attrs.lineWidth = Math.max(attrs.lineWidth || 0, 1.5);
    });
  }
});
function makeIcon({ width: width2, height, x: x2, y: y2 }) {
  const radius = Math.min(width2, height) / 5;
  const topY = y2 - height / 2;
  const leftX = x2 - radius * 1.5;
  const rightX = x2 + radius * 1.5;
  const bodyHeight = radius * 1;
  const legHeight = radius * 2;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("circle", {
        r: radius,
        x: x2,
        y: topY + radius,
        width: width2,
        height
      }),
      makeMark("path", {
        path: [
          ["M", leftX, y2 + radius / 3],
          ["L", rightX, y2 + radius / 3],
          ["M", x2, y2 - radius / 2],
          ["L", x2, y2 + bodyHeight],
          ["l", -radius, legHeight],
          ["l", radius, -legHeight],
          ["l", radius, legHeight]
        ]
      })
    ]
  });
  const sym = makeMark("symbol", {}, {
    mark
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/ellipse.js
symbolRegistry.register("ellipse", {
  type: "factory",
  factory(contentArea, { mode }) {
    if (mode === "container") {
      return makeEllipseContainer(contentArea);
    }
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeEllipseContainer({ width: width2, height, x: x2, y: y2 }) {
  const halfWidth = width2 / 2;
  const padX = 10;
  const padY = 8;
  const rx = halfWidth + padX;
  const ry = height / 2 + padY;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("ellipse", {
        rx,
        ry,
        x: x2,
        y: y2,
        cx: x2,
        cy: y2
      })
    ]
  });
  const leftX = x2 - padX;
  const rightX = x2 + padX;
  const outerWidth = width2 + 2 * padX;
  const outerHeight = height + 2 * padY;
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: leftX,
      right: rightX,
      top: y2 - ry,
      bottom: y2 + ry,
      width: outerWidth,
      height: outerHeight
    }
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/circle.js
symbolRegistry.register("circle", {
  type: "factory",
  factory(contentArea, { mode }) {
    if (mode === "container") {
      return makeContainer(contentArea);
    }
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeContainer({ width: width2, height, x: x2, y: y2 }) {
  const halfWidth = width2 / 2;
  const pad2 = 10;
  const r = halfWidth + pad2;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("circle", {
        r,
        x: x2,
        y: y2
      })
    ]
  });
  const leftX = x2 - pad2;
  const rightX = x2 + pad2;
  const outerWidth = width2 + 2 * pad2;
  const outerHeight = height + 2 * pad2;
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: leftX,
      right: rightX,
      top: y2 - r,
      bottom: y2 + r,
      width: outerWidth,
      height: outerHeight
    }
  });
  return sym;
}

// ../pintora-diagrams/lib/util/symbols/diamond.js
symbolRegistry.register("diamond", {
  type: "factory",
  factory(contentArea, { mode }) {
    if (mode === "container") {
      return makeContainer2(contentArea);
    }
    return makeIcon2(contentArea);
  },
  styleMark(mark, def, attrs) {
    mark.children.forEach((child) => {
      safeAssign(child.attrs, attrs);
    });
  }
});
function makeContainer2({ width: width2, height, x: x2, y: y2 }) {
  const padY = 6;
  const ry = height + padY;
  const rx = ry * width2 / height / 2;
  const padX = rx - width2 / 2;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        path: [["M", x2, y2], ["M", x2 - rx, y2], ["L", x2, y2 + ry], ["L", x2 + rx, y2], ["L", x2, y2 - ry], ["Z"]]
      })
    ]
  });
  const leftX = x2 - padX;
  const rightX = x2 + padX;
  const outerWidth = rx * 2;
  const outerHeight = ry * 2;
  const sym = makeMark("symbol", {}, {
    mark,
    symbolBounds: {
      left: leftX,
      right: rightX,
      top: y2 - ry,
      bottom: y2 + ry,
      width: outerWidth,
      height: outerHeight
    }
  });
  return sym;
}
function makeIcon2({ width: width2, height, x: x2, y: y2 }) {
  const ry = height / 2;
  const rx = width2 / 2;
  const mark = makeMark("group", {}, {
    children: [
      makeMark("path", {
        path: [["M", x2, y2], ["m", -rx, 0], ["l", rx, ry], ["l", rx, -ry], ["l", -rx, -ry], ["Z"]]
      })
    ]
  });
  const sym = makeMark("symbol", {}, {
    mark
  });
  return sym;
}

// ../pintora-diagrams/lib/index.js
var DIAGRAMS = {
  erDiagram,
  sequenceDiagram,
  componentDiagram,
  activityDiagram,
  mindmap,
  gantt,
  dotDiagram,
  classDiagram
};

// ../pintora-renderer/lib/util.js
var Stack3 = class {
  constructor() {
    this.list = [];
  }
  top() {
    return this.list[this.list.length - 1];
  }
  push(v) {
    this.list.push(v);
  }
  pop() {
    return this.list.pop();
  }
  clear() {
    this.list = [];
  }
};
var noop3 = () => void 0;

// ../pintora-renderer/lib/event.js
var GraphicEvent = class {
  constructor(gEvent) {
    this.type = gEvent.type;
    this.gEvent = gEvent;
  }
  get originEvent() {
    return this.gEvent.originalEvent;
  }
  get x() {
    return this.gEvent.x;
  }
  get y() {
    return this.gEvent.y;
  }
  get clientX() {
    return this.gEvent.clientX;
  }
  get clientY() {
    return this.gEvent.clientY;
  }
};

// ../pintora-renderer/lib/renderers/base.js
function traverseScene(mark, visitors, actions) {
  const visitor = visitors[mark.type] || visitors.default;
  let visitorEnter;
  let visitorExit;
  if (visitor) {
    if (typeof visitor === "function") {
      visitorEnter = visitor;
    } else {
      visitorEnter = visitor.enter;
      visitorExit = visitor.exit;
    }
  }
  if (visitorEnter) {
    visitorEnter(mark, actions);
  }
  if (mark.type === "group" && mark.children) {
    mark.children.forEach((child) => {
      traverseScene(child, visitors, actions);
    });
  } else if (mark.type === "symbol") {
    traverseScene(mark.mark, visitors, actions);
  }
  if (visitorExit) {
    visitorExit(mark, actions);
  }
}
var BaseRenderer = class {
  constructor(ir) {
    this.ir = ir;
    this.container = null;
    this.shapeToMarkMap = /* @__PURE__ */ new WeakMap();
  }
  setContainer(c) {
    if (this.gcvs) {
      this.gcvs.destroy();
    }
    this.container = c;
    const canvasCls = this.getCanvasClass();
    const gcvs = new canvasCls({
      container: c,
      width: this.ir.width,
      height: this.ir.height
    });
    this.gcvs = gcvs;
    return this;
  }
  getRootElement() {
    if (!this.gcvs)
      return;
    return this.gcvs.cfg.el;
  }
  addBgShape() {
    var _a;
    if (this.ir.bgColor) {
      (_a = this.gcvs) === null || _a === void 0 ? void 0 : _a.addShape("rect", {
        attrs: {
          width: this.ir.width,
          height: this.ir.height,
          fill: this.ir.bgColor
        }
      });
    }
  }
  renderGCanvas() {
    const gcvs = this.gcvs;
    if (!gcvs)
      return;
    gcvs.clear();
    const self2 = this;
    this.addBgShape();
    const groupStack = new Stack3();
    const actions = {
      addToCurrentGroup(mark) {
        const group = groupStack.top();
        const container = group || gcvs;
        const shapeAttrs = self2.preProcessMarkAttrs(mark);
        const shape = container.addShape(mark.type, {
          attrs: shapeAttrs
        });
        self2.onShapeAdd(shape, mark);
        return shape;
      },
      applyMarkPostProcess(mark, shape) {
        if (mark.matrix) {
          shape.setMatrix(mark.matrix);
        }
      }
    };
    traverseScene(this.ir.mark, {
      group: {
        enter(mark) {
          const prevGroup = groupStack.top();
          const container = prevGroup || gcvs;
          const group = container.addGroup();
          groupStack.push(group);
          self2.onShapeAdd(group, mark);
          actions.applyMarkPostProcess(mark, group);
        },
        exit() {
          groupStack.pop();
        }
      },
      symbol: {
        enter() {
        }
      },
      default(mark) {
        const shape = actions.addToCurrentGroup(mark);
        actions.applyMarkPostProcess(mark, shape);
      }
    }, actions);
  }
  on(name, handler) {
    if (!this.gcvs)
      return noop3;
    const gcvs = this.gcvs;
    const fn = (gEvent) => {
      const mark = this.shapeToMarkMap.get(gEvent.shape);
      const markPath = gEvent.propagationPath.reduce((acc, shape) => {
        const m = this.shapeToMarkMap.get(shape);
        if (m) {
          acc.push(m);
        }
        return acc;
      }, []);
      const event = new GraphicEvent(gEvent);
      event.mark = mark;
      event.markPath = markPath;
      handler(event);
    };
    gcvs.on(name, fn);
    return () => {
      gcvs.off(name, fn);
    };
  }
  preProcessMarkAttrs(mark) {
    return mark.attrs;
  }
  onShapeAdd(shape, mark) {
    this.shapeToMarkMap.set(shape, mark);
  }
  render() {
    this.renderGCanvas();
  }
};

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default2,
  Circle: () => circle_default2,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default3,
  Image: () => image_default,
  Line: () => line_default4,
  Marker: () => marker_default,
  Path: () => path_default3,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default2
});

// ../../node_modules/.pnpm/tslib@2.3.1/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b10) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b11) {
    d2.__proto__ = b11;
  } || function(d2, b11) {
    for (var p in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p))
        d2[p] = b11[p];
  };
  return extendStatics(d, b10);
};
function __extends(d, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics(d, b10);
  function __() {
    this.constructor = d;
  }
  d.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s += arguments[i2].length;
  for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
    for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-array-like.js
var isArrayLike3 = function(value) {
  return value !== null && typeof value !== "function" && isFinite(value.length);
};
var is_array_like_default = isArrayLike3;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-type.js
var toString3 = {}.toString;
var isType = function(value, type) {
  return toString3.call(value) === "[object " + type + "]";
};
var is_type_default = isType;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-function.js
var is_function_default = function(value) {
  return is_type_default(value, "Function");
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-nil.js
var isNil = function(value) {
  return value === null || value === void 0;
};
var is_nil_default = isNil;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-array.js
var is_array_default = function(value) {
  return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-object.js
var is_object_default = function(value) {
  var type = typeof value;
  return value !== null && type === "object" || type === "function";
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len2 = elements.length; i2 < len2; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default = each;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-object-like.js
var isObjectLike3 = function(value) {
  return typeof value === "object" && value !== null;
};
var is_object_like_default = isObjectLike3;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/max.js
var max_default = function(arr2) {
  if (!is_array_default(arr2)) {
    return void 0;
  }
  return arr2.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr2[0]);
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/min.js
var min_default = function(arr2) {
  if (!is_array_default(arr2)) {
    return void 0;
  }
  return arr2.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr2[0]);
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/pull.js
var arrPrototype = Array.prototype;
var splice3 = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/pull-at.js
var splice4 = Array.prototype.splice;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-string.js
var is_string_default = function(str3) {
  return is_type_default(str3, "String");
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-number.js
var isNumber2 = function(value) {
  return is_type_default(value, "Number");
};
var is_number_default = isNumber2;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-integer.js
var isInteger = Number.isInteger ? Number.isInteger : function(num) {
  return is_number_default(num) && num % 1 === 0;
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-number-equal.js
var PRECISION = 1e-5;
function isNumberEqual(a, b10, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b10) < precision;
}

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/mod.js
var mod = function(n2, m) {
  return (n2 % m + m) % m;
};
var mod_default = mod;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/to-degree.js
var DEGREE = 180 / Math.PI;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/to-radian.js
var RADIAN = Math.PI / 180;
var toRadian = function(degree2) {
  return RADIAN * degree2;
};
var to_radian_default = toRadian;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/values.js
var values3 = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each_default(obj, function(value, key) {
    if (!(is_function_default(obj) && key === "prototype")) {
      result.push(value);
    }
  });
  return result;
};
var values_default = values3;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/to-string.js
var to_string_default = function(value) {
  if (is_nil_default(value))
    return "";
  return value.toString();
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/upper-first.js
var upperFirst = function(value) {
  var str3 = to_string_default(value);
  return str3.charAt(0).toUpperCase() + str3.substring(1);
};
var upper_first_default = upperFirst;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/get-type.js
var toString4 = {}.toString;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-prototype.js
var objectProto3 = Object.prototype;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/mix.js
function _mix(dist2, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist2[key] = obj[key];
    }
  }
}
function mix(dist2, src1, src2, src3) {
  if (src1)
    _mix(dist2, src1);
  if (src2)
    _mix(dist2, src2);
  if (src3)
    _mix(dist2, src3);
  return dist2;
}

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/memoize.js
var memoize_default = function(f, resolver) {
  if (!is_function_default(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/is-equal.js
var isEqual = function(value, other) {
  if (value === other) {
    return true;
  }
  if (!value || !other) {
    return false;
  }
  if (is_string_default(value) || is_string_default(other)) {
    return false;
  }
  if (is_array_like_default(value) || is_array_like_default(other)) {
    if (value.length !== other.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < value.length; i2++) {
      rst = isEqual(value[i2], other[i2]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (is_object_like_default(value) || is_object_like_default(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < valueKeys.length; i2++) {
      rst = isEqual(value[valueKeys[i2]], other[valueKeys[i2]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var is_equal_default = isEqual;

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/to-array.js
var to_array_default = function(value) {
  return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/unique-id.js
var map3 = {};
var unique_id_default = function(prefix) {
  prefix = prefix || "g";
  if (!map3[prefix]) {
    map3[prefix] = 1;
  } else {
    map3[prefix] += 1;
  }
  return prefix + map3[prefix];
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/noop.js
var noop_default = function() {
};

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/measure-text-width.js
var ctx;
var measure_text_width_default = memoize_default(function(text, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize2 = font.fontSize, fontFamily2 = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize2 + "px", fontFamily2].join(" ");
  return ctx.measureText(is_string_default(text) ? text : "").width;
}, function(text, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text], values_default(font)).join("");
});

// ../../node_modules/.pnpm/@antv+util@2.0.17/node_modules/@antv/util/esm/cache.js
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/path.js
var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function(a, b10, c) {
    var params = [];
    var name = b10.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b10, params[0]]);
    }
    if (name === "r") {
      data.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};
var isEqual2 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each_default(obj1, function(item, i2) {
    if (item !== obj2[i2]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add3, modify) {
  var type = null;
  var min4 = modify;
  if (add3 < min4) {
    min4 = add3;
    type = "add";
  }
  if (del < min4) {
    min4 = del;
    type = "del";
  }
  return {
    type,
    min: min4
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist2 = [];
  for (var i2 = 0; i2 <= sourceLen; i2++) {
    dist2[i2] = [];
    dist2[i2][0] = { min: i2 };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist2[0][j] = { min: j };
  }
  for (var i2 = 1; i2 <= sourceLen; i2++) {
    sourceSegment = source[i2 - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];
      if (isEqual2(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist2[i2 - 1][j].min + 1;
      var add3 = dist2[i2][j - 1].min + 1;
      var modify = dist2[i2 - 1][j - 1].min + temp;
      dist2[i2][j] = getMinDiff(del, add3, modify);
    }
  }
  return dist2;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i2 = 1; i2 <= sourceLen; i2++) {
      var min4 = diffMatrix[i2][i2].min;
      minPos = i2;
      for (var j = index2; j <= targetLen; j++) {
        if (diffMatrix[i2][j].min < min4) {
          min4 = diffMatrix[i2][j].min;
          minPos = j;
        }
      }
      index2 = minPos;
      if (diffMatrix[i2][index2].type) {
        changes.push({ index: i2 - 1, type: diffMatrix[i2][index2].type });
      }
    }
    for (var i2 = changes.length - 1; i2 >= 0; i2--) {
      index2 = changes[i2].index;
      if (changes[i2].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i2 = 0; i2 < diff; i2++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index2;
  var t = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i2 = 1; i2 <= count; i2++) {
    t *= i2;
    index2 = Math.floor(points.length * t);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t + points[index2][0] * (1 - t), formerEnd[1] * t + points[index2][1] * (1 - t)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t + points[index2][0] * (1 - t),
        formerEnd[1] * t + points[index2][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i2 = 0; i2 < toPath.length; i2++) {
    if (fromPath[i2][0] !== toPath[i2][0]) {
      points = _getSegmentPoints(fromPath[i2]);
      switch (toPath[i2][0]) {
        case "M":
          fromPath[i2] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i2] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i2] = [].concat(toPath[i2]);
          fromPath[i2][6] = points[0][0];
          fromPath[i2][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["Q"].concat(points.reduce(function(arr2, i3) {
            return arr2.concat(i3);
          }, []));
          break;
        case "T":
          fromPath[i2] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 2);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["C"].concat(points.reduce(function(arr2, i3) {
            return arr2.concat(i3);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["S"].concat(points.reduce(function(arr2, i3) {
            return arr2.concat(i3);
          }, []));
          break;
        default:
          fromPath[i2] = toPath[i2];
      }
    }
  }
  return fromPath;
};

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = (
  /** @class */
  function() {
    function GraphEvent2(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent2.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent2.prototype.save = function() {
    };
    GraphEvent2.prototype.restore = function() {
    };
    return GraphEvent2;
  }()
);
var graph_event_default = GraphEvent;

// ../../node_modules/.pnpm/@antv+event-emitter@0.1.2/node_modules/@antv/event-emitter/esm/index.js
var WILDCARD2 = "*";
var EventEmitter2 = (
  /** @class */
  function() {
    function EventEmitter3() {
      this._events = {};
    }
    EventEmitter3.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter3.prototype.once = function(evt, callback) {
      this.on(evt, callback, true);
      return this;
    };
    EventEmitter3.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD2] || [];
      var doEmit = function(es) {
        var length3 = es.length;
        for (var i2 = 0; i2 < length3; i2++) {
          if (!es[i2]) {
            continue;
          }
          var _a = es[i2], callback = _a.callback, once = _a.once;
          if (once) {
            es.splice(i2, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length3--;
            i2--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter3.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i2 = 0; i2 < length_1; i2++) {
            if (events[i2].callback === callback) {
              events.splice(i2, 1);
              length_1--;
              i2--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter3.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter3;
  }()
);
var esm_default2 = EventEmitter2;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/util.js
function removeFromArray(arr2, obj) {
  var index2 = arr2.indexOf(obj);
  if (index2 !== -1) {
    arr2.splice(index2, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/base.js
var Base = (
  /** @class */
  function(_super) {
    __extends(Base3, _super);
    function Base3(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base3.prototype.getDefaultCfg = function() {
      return {};
    };
    Base3.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base3.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base3.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base3;
  }(esm_default2)
);
var base_default = Base;

// ../../node_modules/.pnpm/detect-browser@5.3.0/node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// ../../node_modules/.pnpm/@antv+matrix-util@3.1.0-beta.3/node_modules/@antv/matrix-util/esm/ext.js
var ext_exports2 = {};
__export(ext_exports2, {
  angleTo: () => angleTo2,
  direction: () => direction2,
  leftRotate: () => leftRotate3,
  leftScale: () => leftScale3,
  leftTranslate: () => leftTranslate2,
  transform: () => transform5,
  vertical: () => vertical2
});
function leftTranslate2(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v);
  return mat3_exports.multiply(out, transMat, a);
}
function leftRotate3(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a);
}
function leftScale3(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v);
  return mat3_exports.multiply(out, scaleMat, a);
}
function leftMultiply2(out, a, a1) {
  return mat3_exports.multiply(out, a1, a);
}
function transform5(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len2 = actions.length; i2 < len2; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate2(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale3(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate3(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply2(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction2(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo2(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction2(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical2(out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }
  return out;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a, b10) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b10[0];
  var b01 = b10[1];
  var b02 = b10[2];
  var b102 = b10[3];
  var b11 = b10[4];
  var b12 = b10[5];
  var b20 = b10[6];
  var b21 = b10[7];
  var b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m, v) {
  var out = [];
  var x2 = v[0];
  var y2 = v[1];
  out[0] = m[0] * x2 + m[3] * y2 + m[6];
  out[1] = m[1] * x2 + m[4] * y2 + m[7];
  return out;
}
function invert2(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/element.js
var transform6 = ext_exports2.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD3 = "*";
function _cloneArrayAttr(arr2) {
  var result = [];
  for (var i2 = 0; i2 < arr2.length; i2++) {
    if (is_array_default(arr2[i2])) {
      result.push([].concat(arr2[i2]));
    } else {
      result.push(arr2[i2]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation.toAttrs, function(v, k) {
        if (hasOwnProperty3.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element2 = (
  /** @class */
  function(_super) {
    __extends(Element4, _super);
    function Element4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element4.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element4.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element4.prototype.onCanvasChange = function(changeType) {
    };
    Element4.prototype.initAttrs = function(attrs) {
    };
    Element4.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element4.prototype.isGroup = function() {
      return false;
    };
    Element4.prototype.getParent = function() {
      return this.get("parent");
    };
    Element4.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element4.prototype.attr = function() {
      var _a;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a = {}, _a[name] = value, _a));
        return this;
      }
      return this.attrs[name];
    };
    Element4.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element4.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element4.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element4.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element4.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element4.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element4.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element4.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element4.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element4.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element4.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element4.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element4.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element4.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element4.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element4.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element4.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v);
      }
      return v;
    };
    Element4.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert2(matrix);
        if (invertMatrix) {
          return multiplyVec2(invertMatrix, v);
        }
      }
      return v;
    };
    Element4.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase2 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase2[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element4.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element4.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i2, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone3 = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone3.set(cfgName, _this.get(cfgName));
      });
      return clone3;
    };
    Element4.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element4.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element4.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a = args[2], easing = _a === void 0 ? "easeLinear" : _a, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element4.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element4.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element4.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element4.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i3) {
        var element = paths[i3];
        var name_1 = element.get("name");
        if (name_1) {
          if (
            // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent
            (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)
          ) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i2 = 0; i2 < paths.length; i2++) {
        var state_1 = _loop_1(i2);
        if (state_1 === "break")
          break;
      }
    };
    Element4.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD3]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element4.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform6(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.move = function(targetX, targetY) {
      var x2 = this.attr("x") || 0;
      var y2 = this.attr("y") || 0;
      this.translate(targetX - x2, targetY - y2);
      return this;
    };
    Element4.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element4.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform6(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform6(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotateAtStart = function(rotate4) {
      var _a = this.attr(), x2 = _a.x, y2 = _a.y;
      var matrix = this.getMatrix();
      var newMatrix = transform6(matrix, [
        ["t", -x2, -y2],
        ["r", rotate4],
        ["t", x2, y2]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element4.prototype.rotateAtPoint = function(x2, y2, rotate4) {
      var matrix = this.getMatrix();
      var newMatrix = transform6(matrix, [
        ["t", -x2, -y2],
        ["r", rotate4],
        ["t", x2, y2]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element4;
  }(base_default)
);
var element_default = Element2;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP2 = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare) {
  return function(left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = (
  /** @class */
  function(_super) {
    __extends(Container2, _super);
    function Container2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container2.prototype.isCanvas = function() {
      return false;
    };
    Container2.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box2 = child.getBBox();
          xArr.push(box2.minX, box2.maxX);
          yArr.push(box2.minY, box2.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box;
    };
    Container2.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box2 = child.getCanvasBBox();
          xArr.push(box2.minX, box2.maxX);
          yArr.push(box2.minY, box2.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box;
    };
    Container2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container2.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container2.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container2.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP2[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP2[cfg.type] = shapeType;
      }
      var ShapeBase2 = this.getShapeBase();
      var shape = new ShapeBase2[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container2.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group = new groupClass(cfg);
        } else {
          group = new groupClass({
            // canvas,
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group = new TmpGroupClass(tmpCfg);
      }
      this.add(group);
      return group;
    };
    Container2.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container2.prototype.getShape = function(x2, y2, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x2, y2, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x2, y2, ev);
      }
      return shape;
    };
    Container2.prototype._findShape = function(children, x2, y2, ev) {
      var shape = null;
      for (var i2 = children.length - 1; i2 >= 0; i2--) {
        var child = children[i2];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x2, y2, ev);
          } else if (child.isHit(x2, y2)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container2.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container2.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container2.prototype.getChildren = function() {
      return this.get("children");
    };
    Container2.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index2) {
        child[INDEX] = index2;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container2.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i2 = children.length - 1; i2 >= 0; i2--) {
        children[i2].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container2.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container2.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container2.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container2.prototype.getChildByIndex = function(index2) {
      var children = this.getChildren();
      return children[index2];
    };
    Container2.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container2.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container2.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container2.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container2.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container2.prototype.findById = function(id9) {
      return this.find(function(element) {
        return element.get("id") === id9;
      });
    };
    Container2.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container2.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container2;
  }(element_default)
);
var container_default = Container;

// ../../node_modules/.pnpm/d3-timer@1.0.10/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time3) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time3 = (time3 == null ? now() : +time3) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time3;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time3) {
  var t = new Timer();
  t.restart(callback, delay, time3);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t2, time3 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time3 > t12._time)
        time3 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t2 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t2 : taskHead = t2;
    }
  }
  taskTail = t02;
  sleep(time3);
}
function sleep(time3) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time3 - clockNow;
  if (delay > 24) {
    if (time3 < Infinity)
      timeout = setTimeout(wake, time3 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/basis.js
function basis2(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default3(values4) {
  var n2 = values4.length - 1;
  return function(t) {
    var i2 = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values4[i2], v2 = values4[i2 + 1], v0 = i2 > 0 ? values4[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values4[i2 + 2] : 2 * v2 - v1;
    return basis2((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values4) {
  var n2 = values4.length;
  return function(t) {
    var i2 = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values4[(i2 + n2 - 1) % n2], v1 = values4[i2 % n2], v2 = values4[(i2 + 1) % n2], v3 = values4[(i2 + 2) % n2];
    return basis2((t - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/constant.js
function constant_default3(x2) {
  return function() {
    return x2;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/color.js
function linear2(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential2(a, b10, y2) {
  return a = Math.pow(a, y2), b10 = Math.pow(b10, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b10, y2);
  };
}
function gamma2(y2) {
  return (y2 = +y2) === 1 ? nogamma2 : function(a, b10) {
    return b10 - a ? exponential2(a, b10, y2) : constant_default3(isNaN(a) ? b10 : a);
  };
}
function nogamma2(a, b10) {
  var d = b10 - a;
  return d ? linear2(a, d) : constant_default3(isNaN(a) ? b10 : a);
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/rgb.js
var rgb_default2 = function rgbGamma2(y2) {
  var color2 = gamma2(y2);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b10 = color2(start.b, end.b), opacity = nogamma2(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b10(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma2;
  return rgb2;
}(1);
function rgbSpline2(spline) {
  return function(colors) {
    var n2 = colors.length, r = new Array(n2), g = new Array(n2), b10 = new Array(n2), i2, color2;
    for (i2 = 0; i2 < n2; ++i2) {
      color2 = rgb(colors[i2]);
      r[i2] = color2.r || 0;
      g[i2] = color2.g || 0;
      b10[i2] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b10 = spline(b10);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b10(t);
      return color2 + "";
    };
  };
}
var rgbBasis2 = rgbSpline2(basis_default3);
var rgbBasisClosed2 = rgbSpline2(basisClosed_default2);

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default2(a, b10) {
  if (!b10)
    b10 = [];
  var n2 = a ? Math.min(b10.length, a.length) : 0, c = b10.slice(), i2;
  return function(t) {
    for (i2 = 0; i2 < n2; ++i2)
      c[i2] = a[i2] * (1 - t) + b10[i2] * t;
    return c;
  };
}
function isNumberArray2(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/array.js
function array_default2(a, b10) {
  return (isNumberArray2(b10) ? numberArray_default2 : genericArray2)(a, b10);
}
function genericArray2(a, b10) {
  var nb = b10 ? b10.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2)
    x2[i2] = value_default2(a[i2], b10[i2]);
  for (; i2 < nb; ++i2)
    c[i2] = b10[i2];
  return function(t) {
    for (i2 = 0; i2 < na; ++i2)
      c[i2] = x2[i2](t);
    return c;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/date.js
function date_default2(a, b10) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b10 = +b10, function(t) {
    return d.setTime(a * (1 - t) + b10 * t), d;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/number.js
function number_default2(a, b10) {
  return a = +a, b10 = +b10, function(t) {
    return a * (1 - t) + b10 * t;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/object.js
function object_default2(a, b10) {
  var i2 = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b10 === null || typeof b10 !== "object")
    b10 = {};
  for (k in b10) {
    if (k in a) {
      i2[k] = value_default2(a[k], b10[k]);
    } else {
      c[k] = b10[k];
    }
  }
  return function(t) {
    for (k in i2)
      c[k] = i2[k](t);
    return c;
  };
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/string.js
var reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB2 = new RegExp(reA2.source, "g");
function zero3(b10) {
  return function() {
    return b10;
  };
}
function one2(b10) {
  return function(t) {
    return b10(t) + "";
  };
}
function string_default2(a, b10) {
  var bi = reA2.lastIndex = reB2.lastIndex = 0, am, bm, bs, i2 = -1, s = [], q = [];
  a = a + "", b10 = b10 + "";
  while ((am = reA2.exec(a)) && (bm = reB2.exec(b10))) {
    if ((bs = bm.index) > bi) {
      bs = b10.slice(bi, bs);
      if (s[i2])
        s[i2] += bs;
      else
        s[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i2])
        s[i2] += bm;
      else
        s[++i2] = bm;
    } else {
      s[++i2] = null;
      q.push({ i: i2, x: number_default2(am, bm) });
    }
    bi = reB2.lastIndex;
  }
  if (bi < b10.length) {
    bs = b10.slice(bi);
    if (s[i2])
      s[i2] += bs;
    else
      s[++i2] = bs;
  }
  return s.length < 2 ? q[0] ? one2(q[0].x) : zero3(b10) : (b10 = q.length, function(t) {
    for (var i3 = 0, o; i3 < b10; ++i3)
      s[(o = q[i3]).i] = o.x(t);
    return s.join("");
  });
}

// ../../node_modules/.pnpm/d3-interpolate@1.4.0/node_modules/d3-interpolate/src/value.js
function value_default2(a, b10) {
  var t = typeof b10, c;
  return b10 == null || t === "boolean" ? constant_default3(b10) : (t === "number" ? number_default2 : t === "string" ? (c = color(b10)) ? (b10 = c, rgb_default2) : string_default2 : b10 instanceof color ? rgb_default2 : b10 instanceof Date ? date_default2 : isNumberArray2(b10) ? numberArray_default2 : Array.isArray(b10) ? genericArray2 : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object_default2 : number_default2)(a, b10);
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/index.js
var src_exports = {};
__export(src_exports, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear3,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/linear.js
function linear3(t) {
  return +t;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/quad.js
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/cubic.js
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/sin.js
var pi2 = Math.PI;
var halfPi = pi2 / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi2 * t)) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/math.js
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/exp.js
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/circle.js
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// ../../node_modules/.pnpm/d3-ease@1.0.7/node_modules/d3-ease/src/elastic.js
var tau2 = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau2);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau2);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau2);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau2);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau2);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau2);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports[type];
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation, ratio) {
  var cProps = {};
  var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = parsePathString(toAttrs[k]);
          fromPath = parsePathString(fromAttrs[k]);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i2 = 0; i2 < toPath.length; i2++) {
          var toPathPoint = toPath[i2];
          var fromPathPoint = fromPath[i2];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
              interf = value_default2(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = array_default2(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!is_function_default(toAttrs[k])) {
        interf = value_default2(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation, elapsed) {
  var startTime = animation.startTime, delay = animation.delay;
  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }
  var ratio;
  var duration = animation.duration;
  var easing = animation.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation.delay;
  if (animation.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }
      return true;
    }
  }
  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }
  return false;
}
var Timeline = (
  /** @class */
  function() {
    function Timeline2(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline2.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i2 = _this.animators.length - 1; i2 >= 0; i2--) {
            shape = _this.animators[i2];
            if (shape.destroyed) {
              _this.removeAnimator(i2);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i2);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline2.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline2.prototype.removeAnimator = function(index2) {
      this.animators.splice(index2, 1);
    };
    Timeline2.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline2.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline2.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline2.prototype.getTime = function() {
      return this.current;
    };
    return Timeline2;
  }()
);
var timeline_default = Timeline;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = (
  /** @class */
  function() {
    function EventController2(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController2.prototype.init = function() {
      this._bindEvents();
    };
    EventController2.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._getEventObj = function(type, event, point2, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point2.x;
      eventObj.y = point2.y;
      eventObj.clientX = point2.clientX;
      eventObj.clientY = point2.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController2.prototype._getShape = function(point2, ev) {
      return this.canvas.getShape(point2.x, point2.y, ev);
    };
    EventController2.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point2 = canvas.getPointByEvent(ev);
      return {
        x: point2.x,
        y: point2.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController2.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController2.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist2 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist2 > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController2.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController2;
  }()
);
var event_contoller_default = EventController;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas4.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas4.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas4.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas4.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas4.prototype.setDOMSize = function(width2, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width2 + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas4.prototype.changeSize = function(width2, height) {
      this.setDOMSize(width2, height);
      this.set("width", width2);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas4.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas4.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas4.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas4.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas4.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas4.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas4.prototype.getClientByPoint = function(x2, y2) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x2 + bbox.left,
        y: y2 + bbox.top
      };
    };
    Canvas4.prototype.draw = function() {
    };
    Canvas4.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas4.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas4.prototype.isCanvas = function() {
      return true;
    };
    Canvas4.prototype.getParent = function() {
      return null;
    };
    Canvas4.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas4;
  }(container_default)
);
var canvas_default = Canvas;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/group.js
var AbstractGroup = (
  /** @class */
  function(_super) {
    __extends(AbstractGroup2, _super);
    function AbstractGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup2.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup2.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup2.prototype.clone = function() {
      var clone3 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        clone3.add(child.clone());
      }
      return clone3;
    };
    return AbstractGroup2;
  }(container_default)
);
var group_default2 = AbstractGroup;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/abstract/shape.js
var AbstractShape = (
  /** @class */
  function(_super) {
    __extends(AbstractShape2, _super);
    function AbstractShape2(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape2.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape2.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape2.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape2.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a = attrs.shadowBlur, shadowBlur = _a === void 0 ? 0 : _a, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape2.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape2.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape2.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape2.prototype.isHit = function(x2, y2) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x2, y2, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape2;
  }(element_default)
);
var shape_default = AbstractShape;

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method) {
  cache.set(type, method);
}
function getMethod(type) {
  return cache.get(type);
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, width2 = attrs.width, height = attrs.height;
  return {
    x: x2,
    y: y2,
    width: width2,
    height
  };
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a = shape.attr(), x2 = _a.x, y2 = _a.y, r = _a.r;
  return {
    x: x2 - r,
    y: y2 - r,
    width: r * 2,
    height: r * 2
  };
}

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance2,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
function minNum(array) {
  return Math.min.apply(null, array);
}
function maxNum(array) {
  return Math.max.apply(null, array);
}
function distance2(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: minNum([x1, x2]),
    maxX: maxNum([x1, x2]),
    minY: minNum([y1, y2]),
    maxY: maxNum([y1, y2])
  };
}
function piMod(angle2) {
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/line.js
var line_default2 = {
  /**
   * 计算线段的包围盒
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {object} 包围盒对象
   */
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 线段的长度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 距离
   */
  length: function(x1, y1, x2, y2) {
    return distance2(x1, y1, x2, y2);
  },
  /**
   * 根据比例获取点
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} t 指定比例
   * @return {object} 包含 x, y 的点
   */
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointDistance: function(x1, y1, x2, y2, x3, y3) {
    var cross2 = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1);
    if (cross2 < 0) {
      return distance2(x1, y1, x3, y3);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross2 > lengthSquare) {
      return distance2(x2, y2, x3, y3);
    }
    return this.pointToLine(x1, y1, x2, y2, x3, y3);
  },
  /**
   * 点到直线的距离，而不是点到线段的距离
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @param {number} x  测试点 x
   * @param {number} y  测试点 y
   * @return {number} 距离
   */
  pointToLine: function(x1, y1, x2, y2, x3, y3) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals2(d, [0, 0])) {
      return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
    }
    var u = [-d[1], d[0]];
    normalize(u, u);
    var a = [x3 - x1, y3 - y1];
    return Math.abs(dot(a, u));
  },
  /**
   * 线段的角度
   * @param {number} x1 起始点 x
   * @param {number} y1 起始点 y
   * @param {number} x2 结束点 x
   * @param {number} y2 结束点 y
   * @return {number} 导数
   */
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/bezier.js
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x2, y2, tCallback, length3) {
  var t;
  var d = Infinity;
  var v0 = [x2, y2];
  var segNum = 20;
  if (length3 && length3 > 200) {
    segNum = length3 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t = i2 * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance2(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance2(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance2(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i2 = 0; i2 < count; i2++) {
    var x2 = xArr[i2];
    var y2 = yArr[i2];
    var nextX = xArr[(i2 + 1) % count];
    var nextY = yArr[(i2 + 1) % count];
    totalLength += distance2(x2, y2, nextX, nextY);
  }
  return totalLength / 2;
}

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = line_default2.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = line_default2.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance2(x1, y1, x2, y2) + distance2(x2, y2, x3, y3) + distance2(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
var quadratic_default = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance2(point2.x, point2.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle2 = Math.atan2(dy, dx);
    return piMod(angle2);
  }
};

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt2(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b10 = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t2;
  var discSqrt;
  if (isNumberEqual2(a, 0)) {
    if (!isNumberEqual2(b10, 0)) {
      t12 = -c / b10;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b10 * b10 - 4 * a * c;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b10 / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b10 + discSqrt) / (2 * a);
      t2 = (-b10 - discSqrt) / (2 * a);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = line_default2.pointAt(x1, y1, x2, y2, t);
  var c2 = line_default2.pointAt(x2, y2, x3, y3, t);
  var c3 = line_default2.pointAt(x3, y3, x4, y4, t);
  var c12 = line_default2.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = line_default2.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x2, x3, x4);
    var yExtrema2 = extrema2(y1, y2, y3, y4);
    for (var i2 = 0; i2 < xExtrema2.length; i2++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i2]));
    }
    for (var i2 = 0; i2 < yExtrema2.length; i2++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i2]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length3);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3);
    return distance2(point2.x, point2.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt2(x1, x2, x3, x4, t);
    var dy = derivativeAt2(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  /**
   * 包围盒计算
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {object} 包围盒
   */
  box: function(x2, y2, rx, ry) {
    return {
      x: x2 - rx,
      y: y2 - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 计算周长，使用近似法
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @return {number} 椭圆周长
   */
  length: function(x2, y2, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 距离椭圆最近的点
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {object} 椭圆上距离指定点最近的点
   */
  nearestPoint: function(x2, y2, rx, ry, x0, y0) {
    var a = rx;
    var b10 = ry;
    if (a === 0 || b10 === 0) {
      return {
        x: x2,
        y: y2
      };
    }
    var relativeX = x0 - x2;
    var relativeY = y0 - y2;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b10 * b10;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i2 = 0; i2 < 4; i2++) {
      nearestX = a * Math.cos(t);
      nearestY = b10 * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b10;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x2 + copysign(nearestX, relativeX),
      y: y2 + copysign(nearestY, relativeY)
    };
  },
  /**
   * 点到椭圆最近的距离
   * @param {number} x  椭圆中心 x
   * @param {number} y  椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} x0  指定的点 x
   * @param {number} y0  指定的点 y
   * @return {number} 点到椭圆的距离
   */
  pointDistance: function(x2, y2, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x2, y2, rx, ry, x0, y0);
    return distance2(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  /**
   * 根据比例获取点
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例，x轴方向为 0
   * @return {object} 点
   */
  pointAt: function(x2, y2, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    return {
      x: x2 + rx * Math.cos(angle2),
      y: y2 + ry * Math.sin(angle2)
    };
  },
  /**
   * 根据比例计算切线角度
   * @param {number} x 椭圆中心 x
   * @param {number} y 椭圆中心 y
   * @param {number} rx 椭圆 x 方向半径
   * @param {number} ry 椭圆 y 方向半径
   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整
   * @return {number} 角度，在 0 - 2PI 之间
   */
  tangentAngle: function(x2, y2, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle2), -rx * Math.sin(angle2));
    return piMod(tangentAngle);
  }
};

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle2) - ry * Math.sin(xRotation) * Math.cos(angle2);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle2) + ry * Math.cos(xRotation) * Math.cos(angle2);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
}
function getAngle(rx, ry, x0, y0) {
  var angle2 = Math.atan2(y0 * rx, x0 * ry);
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle2) {
  return {
    x: rx * Math.cos(angle2),
    y: ry * Math.sin(angle2)
  };
}
function rotate3(x2, y2, angle2) {
  var cos = Math.cos(angle2);
  var sin = Math.sin(angle2);
  return [x2 * cos - y2 * sin, x2 * sin + y2 * cos];
}
var arc_default = {
  /**
   * 计算包围盒
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @return {object} 包围盒对象
   */
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var xAngle = xDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x2 = xAt(cx, cy, rx, ry, xRotation, xs[i2]);
      if (x2 < minX) {
        minX = x2;
      }
      if (x2 > maxX) {
        maxX = x2;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var yAngle = yDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i2 = 0; i2 < ys.length; i2++) {
      var y2 = yAt(cx, cy, rx, ry, xRotation, ys[i2]);
      if (y2 < minY) {
        minY = y2;
      }
      if (y2 > maxY) {
        maxY = y2;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  /**
   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，
   * 仅跟 rx, ry, startAngle, endAngle 相关
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   */
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 获取指定点到圆弧的最近距离的点
   * @param {number} cx         圆心 x
   * @param {number} cy         圆心 y
   * @param {number} rx         x 轴方向的半径
   * @param {number} ry         y 轴方向的半径
   * @param {number} xRotation  旋转角度
   * @param {number} startAngle 起始角度
   * @param {number} endAngle   结束角度
   * @param {number} x0         指定点的 x
   * @param {number} y0         指定点的 y
   * @return {object} 到指定点最近距离的点
   */
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle2 = getAngle(rx, ry, relativePoint.x, relativePoint.y);
    if (angle2 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle2 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance2(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle2),
      y: yAt(cx, cy, rx, ry, xRotation, angle2)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    return piMod(Math.atan2(dy, dx));
  }
};

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to = points[i2 + 1];
    var length_1 = distance2(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to = points[i2 + 1];
    totalLength += distance2(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }
  var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point2 = null;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point2 = line_default2.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point2;
}
function angleAtSegments(points, t) {
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }
  var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;
  var startRatio = 0;
  var angle2 = 0;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle2;
}
function distanceAtSegment(points, x2, y2) {
  var minDistance = Infinity;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var point2 = points[i2];
    var nextPoint = points[i2 + 1];
    var distance_1 = line_default2.pointDistance(point2[0], point2[1], nextPoint[0], nextPoint[1], x2, y2);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// ../../node_modules/.pnpm/@antv+g-math@0.1.7/node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  /**
   * 计算多折线的包围盒
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 包围盒
   */
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i2 = 0; i2 < points.length; i2++) {
      var point2 = points[i2];
      xArr.push(point2[0]);
      yArr.push(point2[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 计算多折线的长度
   * @param {array} points 点的集合 [x,y] 的形式
   * @return {object} 多条边的长度
   */
  length: function(points) {
    return lengthOfSegment(points);
  },
  /**
   * 根据比例获取多折线的点
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的点
   */
  pointAt: function(points, t) {
    return pointAtSegments(points, t);
  },
  /**
   * 指定点到多折线的距离
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} x 指定点的 x
   * @param {number} y 指定点的 y
   * @return {number} 点到多折线的距离
   */
  pointDistance: function(points, x2, y2) {
    return distanceAtSegment(points, x2, y2);
  },
  /**
   * 根据比例获取多折线的切线角度
   * @param {array} points 点的集合 [x,y] 的形式
   * @param {number} t 在多折线的长度上的比例
   * @return {object} 根据比例值计算出来的角度
   */
  tangentAngle: function(points, t) {
    return angleAtSegments(points, t);
  }
};

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point2 = points[i2];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a = util_exports.getBBoxByArray(xArr, yArr), x2 = _a.x, y2 = _a.y, width2 = _a.width, height = _a.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width2,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point2 = points[i2];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize2, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize2, lineHeight);
    return fontSize2 * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize2;
}
function getLineSpaceing(fontSize2, lineHeight) {
  return lineHeight ? lineHeight - fontSize2 : fontSize2 * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width2 = 0;
  if (is_nil_default(text) || text === "") {
    return width2;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width2 < measureWidth) {
        width2 = measureWidth;
      }
    });
  } else {
    width2 = context.measureText(text).width;
  }
  context.restore();
  return width2;
}
function assembleFont(attrs) {
  var fontSize2 = attrs.fontSize, fontFamily2 = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize2 + "px", fontFamily2].join(" ").trim();
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, text = attrs.text, fontSize2 = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width2 = getTextWidth(text, font);
  var bbox;
  if (!width2) {
    bbox = {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize2, lineHeight);
    var point2 = {
      x: x2,
      y: y2 - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width2;
      } else if (textAlign === "center") {
        point2.x -= width2 / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width: width2,
      height
    };
  }
  return bbox;
}

// ../../node_modules/.pnpm/@antv+path-util@2.0.15/node_modules/@antv/path-util/esm/parse-path.js
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path4 = p || [];
  if (is_array_default(path4)) {
    return path4;
  }
  if (is_string_default(path4)) {
    path4 = path4.match(regexTags);
    each_default(path4, function(item, index2) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag2 = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag2;
      }
      each_default(item, function(sub3, i2) {
        if (!isNaN(sub3)) {
          item[i2] = +sub3;
        }
      });
      path4[index2] = item;
    });
    return path4;
  }
}
var parse_path_default = parsePath;

// ../../node_modules/.pnpm/@antv+path-util@2.0.15/node_modules/@antv/path-util/esm/parse-path-string.js
var SPACES2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");

// ../../node_modules/.pnpm/@antv+path-util@2.0.15/node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// ../../node_modules/.pnpm/@antv+path-util@2.0.15/node_modules/@antv/path-util/esm/get-arc-params.js
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// ../../node_modules/.pnpm/@antv+path-util@2.0.15/node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry(point2, center) {
  return [center[0] + (center[0] - point2[0]), center[1] + (center[1] - point2[1])];
}
function getSegments(path4) {
  path4 = parse_path_default(path4);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path4.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path4[i2];
    nextParams = path4[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path4[lastStartMovePointIndex + 1];
    } else {
      var len2 = params.length;
      currentPoint = [params[len2 - 2], params[len2 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path4[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i2 - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a = segment["arcParams"] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/path.js
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box = void 0;
    switch (segment.command) {
      case "Q":
        box = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box) {
      segment.box = box;
      xArr.push(box.x, box.x + box.width);
      yArr.push(box.y, box.y + box.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i2 = 0; i2 < segmentsWithAngle.length; i2++) {
    var segment = segmentsWithAngle[i2];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default2(shape) {
  var attrs = shape.attr();
  var path4 = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path4);
  var _a = getPathBox(segments, lineWidth), x2 = _a.x, y2 = _a.y, width2 = _a.width, height = _a.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width2,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/line.js
function line_default3(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x2 - rx,
    y: y2 - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// ../../node_modules/.pnpm/@antv+g-base@0.5.11/node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default2);
register("line", line_default3);
register("ellipse", ellipse_default2);

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/util/dom.js
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(
    // 要求为元素节点，且不能为 defs 节点
    function(node2) {
      return node2.nodeType === 1 && node2.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model3, context) {
  var el = model3.cfg.el;
  var attrs = model3.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id9 = context.find("filter", cfg);
    if (!id9) {
      id9 = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id9 + ")");
  }
}
function setTransform(model3) {
  var matrix = model3.attr().matrix;
  if (matrix) {
    var el = model3.cfg.el;
    var transform7 = [];
    for (var i2 = 0; i2 < 9; i2 += 3) {
      transform7.push(matrix[i2] + "," + matrix[i2 + 1]);
    }
    transform7 = transform7.join(",");
    if (transform7.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform7 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model3, context) {
  var clip = model3.getClip();
  var el = model3.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id9 = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id9 + ")");
  }
}

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b10) {
          return children_1.indexOf(a) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/group.js
var Group = (
  /** @class */
  function(_super) {
    __extends(Group2, _super);
    function Group2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group2.prototype.isEntityGroup = function() {
      return true;
    };
    Group2.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group2.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group2.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group2.prototype.getGroupBase = function() {
      return Group2;
    };
    Group2.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren(context, children);
        }
      }
    };
    Group2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      setTransform(this);
    };
    return Group2;
  }(group_default2)
);
var group_default3 = Group;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase = (
  /** @class */
  function(_super) {
    __extends(ShapeBase2, _super);
    function ShapeBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase2.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase2.prototype.getGroupBase = function() {
      return group_default3;
    };
    ShapeBase2.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase2.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x2 = bbox.x, y2 = bbox.y, width2 = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x2 - halfWidth;
        var minY = y2 - halfWidth;
        var maxX = x2 + width2 + halfWidth;
        var maxY = y2 + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY,
          width: width2 + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase2.prototype.isFill = function() {
      var _a = this.attr(), fill = _a.fill, fillStyle = _a.fillStyle;
      return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase2.prototype.isStroke = function() {
      var _a = this.attr(), stroke = _a.stroke, strokeStyle = _a.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase2.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase2.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase2.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase2.prototype._setColor = function(context, attr, value) {
      var el = this.get("el");
      if (!value) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value = value.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
        var id9 = context.find("gradient", value);
        if (!id9) {
          id9 = context.addGradient(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id9 + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
        var id9 = context.find("pattern", value);
        if (!id9) {
          id9 = context.addPattern(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id9 + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    };
    ShapeBase2.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a = targetAttrs || attrs, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY, shadowBlur = _a.shadowBlur, shadowColor = _a.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase2.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase2.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase2.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase2.prototype.getHitLineWidth = function() {
      var _a = this.attrs, lineWidth = _a.lineWidth, lineAppendWidth = _a.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase2;
  }(shape_default)
);
var base_default2 = ShapeBase;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/circle.js
var Circle = (
  /** @class */
  function(_super) {
    __extends(Circle2, _super);
    function Circle2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Circle2;
  }(base_default2)
);
var circle_default2 = Circle;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/dom.js
var Dom = (
  /** @class */
  function(_super) {
    __extends(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i2 = children.length - 1; i2 >= 0; i2--) {
            el.removeChild(children[i2]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default2)
);
var dom_default = Dom;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/ellipse.js
var Ellipse = (
  /** @class */
  function(_super) {
    __extends(Ellipse2, _super);
    function Ellipse2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Ellipse2;
  }(base_default2)
);
var ellipse_default3 = Ellipse;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/image.js
var Image2 = (
  /** @class */
  function(_super) {
    __extends(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value) {
      this.attrs[name] = value;
      if (name === "img") {
        this._setImage(value);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default2)
);
var image_default = Image2;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/line.js
var Line = (
  /** @class */
  function(_super) {
    __extends(Line3, _super);
    function Line3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id9 = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id9 + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Line3.prototype.getTotalLength = function() {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default2.length(x1, y1, x2, y2);
    };
    Line3.prototype.getPoint = function(ratio) {
      var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;
      return line_default2.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line3;
  }(base_default2)
);
var line_default4 = Line;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols = {
  // 圆
  circle: function(x2, y2, r) {
    return [
      ["M", x2, y2],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  // 正方形
  square: function(x2, y2, r) {
    return [["M", x2 - r, y2 - r], ["L", x2 + r, y2 - r], ["L", x2 + r, y2 + r], ["L", x2 - r, y2 + r], ["Z"]];
  },
  // 菱形
  diamond: function(x2, y2, r) {
    return [["M", x2 - r, y2], ["L", x2, y2 - r], ["L", x2 + r, y2], ["L", x2, y2 + r], ["Z"]];
  },
  // 三角形
  triangle: function(x2, y2, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r, y2 + diffY], ["z"]];
  },
  // 倒三角形
  triangleDown: function(x2, y2, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r, y2 - diffY], ["L", x2 + r, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols[type];
  },
  register: function(type, func) {
    Symbols[type] = func;
  },
  remove: function(type) {
    delete Symbols[type];
  },
  getAll: function() {
    return Symbols;
  }
};

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker = (
  /** @class */
  function(_super) {
    __extends(Marker2, _super);
    function Marker2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker2.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker2.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (is_array_default(d)) {
        return d.map(function(path4) {
          return path4.join(" ");
        }).join("");
      }
      return d;
    };
    Marker2.prototype._getPath = function() {
      var attrs = this.attr();
      var x2 = attrs.x, y2 = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (is_function_default(symbol)) {
        method = symbol;
      } else {
        method = symbols_default.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x2, y2, r);
    };
    Marker2.symbolsFactory = symbols_default;
    return Marker2;
  }(base_default2)
);
var marker_default = Marker;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/path.js
var Path2 = (
  /** @class */
  function(_super) {
    __extends(Path3, _super);
    function Path3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Path3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "path" && is_array_default(value)) {
          el.setAttribute("d", _this._formatPath(value));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id9 = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id9 + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Path3.prototype._formatPath = function(value) {
      var newValue = value.map(function(path4) {
        return path4.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path3.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path3.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point2 = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point2 ? {
        x: point2.x,
        y: point2.y
      } : null;
    };
    return Path3;
  }(base_default2)
);
var path_default3 = Path2;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/polygon.js
var Polygon = (
  /** @class */
  function(_super) {
    __extends(Polygon2, _super);
    function Polygon2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Polygon2;
  }(base_default2)
);
var polygon_default3 = Polygon;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/polyline.js
var Polyline = (
  /** @class */
  function(_super) {
    __extends(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      each_default(tCache, function(v, i2) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index2 = i2;
        }
      });
      return line_default2.pointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p, i2) {
        if (points[i2 + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default2.length(p[0], p[1], points[i2 + 1][0], points[i2 + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return Polyline2;
  }(base_default2)
);
var polyline_default3 = Polyline;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/util/format.js
function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/rect.js
var Rect = (
  /** @class */
  function(_super) {
    __extends(Rect2, _super);
    function Rect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect2.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Rect2.prototype._assembleRect = function(attrs) {
      var x2 = attrs.x;
      var y2 = attrs.y;
      var w = attrs.width;
      var h = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x2 + "," + y2 + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
      }
      var r = parseRadius(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x2 + r.r1) + "," + y2],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect2;
  }(base_default2)
);
var rect_default2 = Rect;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/shape/text.js
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text = (
  /** @class */
  function(_super) {
    __extends(Text3, _super);
    function Text3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "text") {
          _this._setText("" + value);
        } else if (attr === "matrix" && value) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text3.prototype._setFont = function() {
      var el = this.get("el");
      var _a = this.attr(), textBaseline = _a.textBaseline, textAlign = _a.textAlign;
      var browser2 = detect();
      if (browser2 && browser2.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text3.prototype._setText = function(text) {
      var el = this.get("el");
      var _a = this.attr(), x2 = _a.x, _b = _a.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i2) {
          if (i2 === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x2 + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x2 + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x2 + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x2 + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x2 + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x2 + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text3;
  }(base_default2)
);
var text_default2 = Text;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/gradient.js
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop(steps) {
  var arr2 = steps.match(regexColorStop);
  if (!arr2) {
    return "";
  }
  var stops = "";
  arr2.sort(function(a, b10) {
    a = a.split(":");
    b10 = b10.split(":");
    return Number(a[0]) - Number(b10[0]);
  });
  each_default(arr2, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient(color2, el) {
  var arr2 = regexLG.exec(color2);
  var angle2 = mod_default(to_radian_default(parseFloat(arr2[1])), Math.PI * 2);
  var steps = arr2[2];
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle2 && angle2 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x2 = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y2 = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x2);
  el.setAttribute("y2", y2);
  el.innerHTML = addStop(steps);
}
function parseRadialGradient(color2, self2) {
  var arr2 = regexRG.exec(color2);
  var cx = parseFloat(arr2[1]);
  var cy = parseFloat(arr2[2]);
  var r = parseFloat(arr2[3]);
  var steps = arr2[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r);
  self2.innerHTML = addStop(steps);
}
var Gradient = (
  /** @class */
  function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id9 = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient(cfg, el);
      }
      el.setAttribute("id", id9);
      this.el = el;
      this.id = id9;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }()
);
var gradient_default = Gradient;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/shadow.js
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = (
  /** @class */
  function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config2 = this.cfg;
      each_default(Object.keys(config2), function(attr) {
        if (config2[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value) {
      var config2 = this.cfg;
      config2[ATTR_MAP[name]] = value;
      this._parseShadow(config2, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config2, el) {
      var child = '<feDropShadow\n      dx="' + (config2.dx || 0) + '"\n      dy="' + (config2.dy || 0) + '"\n      stdDeviation="' + (config2.blur ? config2.blur / 10 : 0) + '"\n      flood-color="' + (config2.color ? config2.color : "#000") + '"\n      flood-opacity="' + (config2.opacity ? config2.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }()
);
var shadow_default = Shadow;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/arrow.js
var Arrow = (
  /** @class */
  function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id9 = unique_id_default("marker_");
      el.setAttribute("id", id9);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id9;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "5");
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent = this.el;
      var path4 = this.cfg.path;
      var d = this.cfg.d;
      if (is_array_default(path4)) {
        path4 = path4.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path4);
      parent.appendChild(el);
      if (d) {
        parent.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill);
      } else {
        child.setAttribute("fill", fill);
      }
    };
    return Arrow2;
  }()
);
var arrow_default = Arrow;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/clip.js
var Clip = (
  /** @class */
  function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }()
);
var clip_default = Clip;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/pattern.js
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = (
  /** @class */
  function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id9 = unique_id_default("pattern_");
      el.id = id9;
      this.el = el;
      this.id = id9;
      this.cfg = cfg;
      var arr2 = regexPR.exec(cfg);
      var source = arr2[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }()
);
var pattern_default = Pattern;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/defs/index.js
var Defs = (
  /** @class */
  function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id9 = unique_id_default("defs_");
      el.id = id9;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i2 = 0; i2 < children.length; i2++) {
        if (children[i2].match(type, attr)) {
          result = children[i2].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id9) {
      var children = this.children;
      var flag = null;
      for (var i2 = 0; i2 < children.length; i2++) {
        if (children[i2].id === id9) {
          flag = children[i2];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient = new gradient_default(cfg);
      this.el.appendChild(gradient.el);
      this.add(gradient);
      return gradient.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern = new pattern_default(cfg);
      this.el.appendChild(pattern.el);
      this.add(pattern);
      return pattern.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new clip_default(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }()
);
var defs_default = Defs;

// ../../node_modules/.pnpm/@antv+g-svg@0.5.6/node_modules/@antv/g-svg/esm/canvas.js
var Canvas2 = (
  /** @class */
  function(_super) {
    __extends(Canvas4, _super);
    function Canvas4(cfg) {
      return _super.call(this, __assign(__assign({}, cfg), {
        autoDraw: true,
        // 设置渲染引擎为 canvas，只读属性
        renderer: "svg"
      })) || this;
    }
    Canvas4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas4.prototype.getGroupBase = function() {
      return group_default3;
    };
    Canvas4.prototype.getShape = function(x2, y2, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas4.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas4.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b10) {
            return children_1.indexOf(a) - children_1.indexOf(b10) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas4.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren(context, children);
      }
    };
    return Canvas4;
  }(canvas_default)
);
var canvas_default2 = Canvas2;

// ../pintora-renderer/lib/renderers/SvgRenderer.js
var SvgRenderer = class extends BaseRenderer {
  getCanvasClass() {
    return canvas_default2;
  }
  preProcessMarkAttrs(mark) {
    if (mark.type === "text") {
      return {
        ...mark.attrs,
        text: escapeHtml(mark.attrs.text)
      };
    }
    return mark.attrs;
  }
  onShapeAdd(shape, mark) {
    super.onShapeAdd(shape, mark);
    if (mark.class) {
      const el = shape.get("el");
      if (el && el.classList) {
        mark.class.split(" ").forEach((cls) => {
          if (cls)
            el.classList.add(cls);
        });
      }
    }
  }
};
function escapeHtml(unsafe) {
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

// ../pintora-renderer/lib/renderers/CanvasRenderer.js
var import_g_canvas = __toESM(require_canvas());
var CanvasRenderer = class extends BaseRenderer {
  getCanvasClass() {
    return import_g_canvas.Canvas;
  }
};

// ../pintora-renderer/lib/renderers/index.js
var RendererRegistry = class {
  constructor() {
    this.renderers = {
      svg: SvgRenderer,
      canvas: CanvasRenderer
    };
  }
  getRendererClass(name) {
    return this.renderers[name];
  }
  register(name, cls) {
    this.renderers[name] = cls;
  }
};
var rendererRegistry = new RendererRegistry();
function makeRenderer(ir, type) {
  type = type || "svg";
  const rendererCtor = rendererRegistry.getRendererClass(type);
  if (!rendererCtor) {
    return new SvgRenderer(ir);
  }
  return new rendererCtor(ir);
}

// ../pintora-renderer/lib/index.js
function render(ir, opts) {
  const renderer = makeRenderer(ir, opts.renderer).setContainer(opts.container);
  renderer.render();
  if (opts.onRender) {
    opts.onRender(renderer);
  }
}

// ../pintora-standalone/src/index.ts
function initDiagrams() {
  Object.keys(DIAGRAMS).forEach((name) => {
    diagramRegistry.registerDiagram(name, DIAGRAMS[name]);
  });
}
initDiagrams();
var CLASSES = {
  wrapper: "pintora-wrapper"
};
var ConfigStack = class {
  constructor() {
    this.list = [];
  }
  push(c) {
    this.list.push(c);
  }
  pop() {
    return this.list.pop();
  }
  get size() {
    return this.list.length;
  }
};
var configStack = new ConfigStack();
var pintoraStandalone = {
  renderTo(code, options) {
    const { container, config: config2 } = options;
    let ctn;
    if (typeof container === "string") {
      ctn = document.querySelector(container);
    } else {
      ctn = container;
    }
    let backupConfig;
    if (config2) {
      backupConfig = config_default.cloneConfig();
      configStack.push(backupConfig);
      pintoraStandalone.setConfig(config2);
    }
    let drawResult;
    try {
      const containerSize = {
        width: ctn.clientWidth
      };
      drawResult = parseAndDraw(code, safeAssign({ containerSize }, options));
    } catch (error) {
      //const onError = options.onError || console.warn;
      console.warn(code);
      console.warn(error);
    }
    try {
      if (drawResult) {
        let graphicIR = drawResult.graphicIR;
        if (options.enhanceGraphicIR)
          graphicIR = options.enhanceGraphicIR(graphicIR);
        if (!graphicIR.bgColor) {
          const diagramIR = drawResult.diagramIR;
          const conf6 = config_default.gnernateNewConfig(diagramIR.overrideConfig || {});
          const canvasBackground = conf6.themeConfig.themeVariables?.canvasBackground;
          if (canvasBackground)
            graphicIR.bgColor = canvasBackground;
        }
        const originOnRender = options.onRender;
        render(graphicIR, {
          ...options,
          container: ctn,
          onRender(renderer) {
            diagramEventManager.wireCurrentEventsToRenderer(renderer, drawResult.diagramIR);
            if (options.eventsHandlers) {
              for (const [eventName, handler] of Object.entries(options.eventsHandlers)) {
                diagramEventManager.wireDiagramEventToRenderer(
                  renderer,
                  eventName,
                  handler,
                  drawResult.diagramIR
                );
              }
            }
            if (originOnRender)
              originOnRender(renderer);
          }
        });
      }
    } finally {
      if (config2 && backupConfig) {
        config_default.replaceConfig(backupConfig);
        configStack.pop();
      }
    }
  },
  /**
   * Init in browser
   */
  initBrowser(options = {}) {
    const selector = ".pintora";
    const containers = document.querySelectorAll(selector);
    containers.forEach((container) => {
      pintoraStandalone.renderContentOf(container);
    });
  },
  renderContentOf(container, opts = {}) {
    let resultContainer = opts.resultContainer;
    if (!resultContainer) {
      const prevSibling = container.previousElementSibling;
      if (prevSibling && prevSibling.classList.contains(CLASSES.wrapper)) {
        prevSibling.remove();
      }
      const wrapper = document.createElement("div");
      wrapper.className=(CLASSES.wrapper);
      container.style.display = "none";
      if (container.parentNode) {
        container.parentNode.insertBefore(wrapper, container);
      }
      resultContainer = wrapper;
    }
    const configFromEle = pintoraStandalone.getConfigFromElement(container);
    const renderer = configFromEle.renderer || config_default.getConfig().core?.defaultRenderer || "svg";
    let config2 = null;
    if (configFromEle.theme) {
      config2 = {
        themeConfig: {
          theme: configFromEle.theme
        }
      };
    }
    const code = opts.getContent ? opts.getContent(container) : container.innerText;
    console.log(code);
    pintoraStandalone.renderTo(code, {
      container: resultContainer,
      renderer,
      config: config2,
      eventsHandlers: opts.eventsHandlers
    });
    return resultContainer;
  },
  /**
   * Get pintora config from element's dataset, some available configs:
   * - `data-renderer`
   * - `data-theme`
   */
  getConfigFromElement(ele) {
    const output = ["renderer", "theme"].reduce((acc, k) => {
      const v = ele.dataset[k];
      if (v) {
        acc[k] = v;
      }
      return acc;
    }, {});
    return output;
  },
  getConfig: config_default.getConfig,
  setConfig: config_default.setConfig,
  diagramEventManager,
  configApi: config_default,
  configEngine: config_engine_exports,
  diagramRegistry,
  themeRegistry,
  symbolRegistry,
  parseAndDraw,
  util
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/defaults.js
var defaults_exports = {};
__export(defaults_exports, {
  fontDir: () => fontDir,
  fontFamily: () => fontFamily,
  fontFamilyMappings: () => fontFamilyMappings,
  fontSize: () => fontSize
});
var import_node_path = __toESM(require_path_browserify(), 1);
var import_node_url = __toESM(require_url2(), 1);
var __dirname = (0, import_node_path.dirname)((0, import_node_url.fileURLToPath)(import.meta.url));
var fontSize = 16;
var fontFamily = "sans-serif";
var fontDir = (0, import_node_path.join)(__dirname, "../../", "fonts/");
var fontFamilyMappings = {
  "sans-serif": "OpenSans-Regular.ttf",
  "Open Sans": "OpenSans-Regular.ttf"
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/objectCreationUtils.js
var extend2 = (...modules) => {
  var methods, key, i2;
  methods = modules.pop();
  for (i2 = modules.length - 1; i2 >= 0; i2--) {
    for (key in methods) {
      modules[i2].prototype[key] = methods[key];
    }
  }
};
var extendStatic = (...modules) => {
  var methods, key, i2;
  methods = modules.pop();
  for (i2 = modules.length - 1; i2 >= 0; i2--) {
    for (key in methods) {
      modules[i2][key] = methods[key];
    }
  }
};
var mixin = (mixin2, _class) => {
  const descriptors = Object.getOwnPropertyDescriptors(mixin2);
  Object.defineProperties(_class.prototype, descriptors);
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/EventTarget.js
var $ = Symbol("private properties");
var EventTarget = class {
  constructor() {
    this[$] = {};
    this[$].listeners = {};
  }
  addEventListener(type, callback) {
    if (!(type in this[$].listeners)) {
      this[$].listeners[type] = [];
    }
    this[$].listeners[type].push(callback);
  }
  dispatchEvent(event) {
    if (!(event.type in this[$].listeners)) {
      return true;
    }
    var stack = this[$].listeners[event.type];
    event.target = this;
    stack.forEach(function(el) {
      el(event);
    });
    return !event.defaultPrevented;
  }
  removeEventListener(type, callback) {
    if (!(type in this[$].listeners)) {
      return;
    }
    var stack = this[$].listeners[type];
    for (var i2 = 0, il = stack.length; i2 < il; i2++) {
      if (stack[i2] === callback) {
        stack.splice(i2, 1);
        return;
      }
    }
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/tagUtils.js
var htmlEntities = function(str3) {
  return String(str3).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
var emptyElements = {
  br: true,
  hr: true,
  img: true,
  link: true
};
var tag = function(node2) {
  const attrs = [...node2.attrs].map(function(node3) {
    return (node3.prefix ? node3.prefix + ":" : "") + node3.localName + '="' + htmlEntities(node3.value) + '"';
  });
  const { prefix, localName } = node2;
  const qualifiedName = (prefix ? prefix + ":" : "") + localName;
  return "<" + [].concat(qualifiedName, attrs).join(" ") + ">" + (emptyElements[qualifiedName.toLowerCase()] ? "" : node2.innerHTML + "</" + qualifiedName + ">");
};
var cloneNode = function(node2) {
  const { prefix, localName, namespaceURI: ns, nodeValue, ownerDocument } = node2;
  const qualifiedName = (prefix ? prefix + ":" : "") + localName;
  const local = localName.includes(":");
  var clone3 = new node2.constructor(qualifiedName, {
    attrs: new Set([...node2.attrs].map((node3) => node3.cloneNode())),
    nodeValue,
    ownerDocument,
    local
  }, ns);
  return clone3;
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/namespaces.js
var svg = "http://www.w3.org/2000/svg";
var html = "http://www.w3.org/1999/xhtml";
var xml = "http://www.w3.org/XML/1998/namespace";
var xmlns = "http://www.w3.org/2000/xmlns/";

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Node.js
var nodeTypes = {
  ELEMENT_NODE: 1,
  ATTRIBUTE_NODE: 2,
  TEXT_NODE: 3,
  CDATA_SECTION_NODE: 4,
  ENTITY_REFERENCE_NODE: 5,
  ENTITY_NODE: 6,
  PROCESSING_INSTRUCTION_NODE: 7,
  COMMENT_NODE: 8,
  DOCUMENT_NODE: 9,
  DOCUMENT_TYPE_NODE: 10,
  DOCUMENT_FRAGMENT_NODE: 11,
  NOTATION_NODE: 12
};
var Node = class _Node extends EventTarget {
  constructor(name = "", props = {}, ns = null) {
    super();
    if (name.includes(":") && !props.local) {
      ;
      [this.prefix, this.localName] = name.split(":");
    } else {
      this.localName = name;
      this.prefix = null;
    }
    this.nodeName = ns === html ? name.toUpperCase() : name;
    this.namespaceURI = ns;
    this.nodeType = _Node.ELEMENT_NODE;
    this.nodeValue = props.nodeValue != null ? props.nodeValue : null;
    this.childNodes = [];
    this.attrs = props.attrs || /* @__PURE__ */ new Set();
    this.ownerDocument = props.ownerDocument || null;
    this.parentNode = null;
    if (props.childNodes) {
      for (let i2 = 0, il = props.childNodes.length; i2 < il; ++i2) {
        this.appendChild(props.childNodes[i2]);
      }
    }
  }
  appendChild(node2) {
    return this.insertBefore(node2);
  }
  cloneNode(deep = false) {
    const clone3 = cloneNode(this);
    if (deep) {
      this.childNodes.forEach(function(el) {
        const node2 = el.cloneNode(deep);
        clone3.appendChild(node2);
      });
    }
    return clone3;
  }
  contains(node2) {
    if (node2 === this)
      return false;
    while (node2.parentNode) {
      if (node2 === this)
        return true;
      node2 = node2.parentNode;
    }
    return false;
  }
  getRootNode() {
    if (!this.parentNode || this.nodeType === _Node.DOCUMENT_NODE)
      return this;
    return this.parentNode.getRootNode();
  }
  hasChildNodes() {
    return !!this.childNodes.length;
  }
  insertBefore(node2, before) {
    let index2 = this.childNodes.indexOf(before);
    if (index2 === -1) {
      index2 = this.childNodes.length;
    }
    if (node2.nodeType === _Node.DOCUMENT_FRAGMENT_NODE) {
      let child;
      let oldChild = before;
      while (child = node2.childNodes.pop()) {
        this.insertBefore(child, oldChild);
        oldChild = child;
      }
      return node2;
    }
    if (node2.parentNode) {
      node2.parentNode.removeChild(node2);
    }
    node2.parentNode = this;
    this.childNodes.splice(index2, 0, node2);
    return node2;
  }
  isDefaultNamespace(namespaceURI) {
    switch (this.nodeType) {
      case _Node.ELEMENT_NODE:
        if (!this.prefix) {
          return this.namespaceURI === namespaceURI;
        }
        if (this.hasAttribute("xmlns")) {
          return this.getAttribute("xmlns");
        }
        if (this.parentNode) {
          return this.parentNode.isDefaultNamespace(namespaceURI);
        }
        return false;
      case _Node.DOCUMENT_NODE:
        return this.documentElement.isDefaultNamespace(namespaceURI);
      case _Node.ENTITY_NODE:
      case _Node.NOTATION_NODE:
      case _Node.DOCUMENT_TYPE_NODE:
      case _Node.DOCUMENT_FRAGMENT_NODE:
        return false;
      case _Node.ATTRIBUTE_NODE:
        if (this.ownerElement) {
          return this.ownerElement.isDefaultNamespace(namespaceURI);
        }
        return false;
      default:
        if (this.parentNode) {
          return this.parentNode.isDefaultNamespace(namespaceURI);
        }
        return false;
    }
  }
  isEqualNode(node2) {
    this.normalize();
    node2.normalize();
    let bool = this.nodeName === node2.nodeName;
    bool = bool && this.localName === node2.localName;
    bool = bool && this.namespaceURI === node2.namespaceURI;
    bool = bool && this.prefix === node2.prefix;
    bool = bool && this.nodeValue === node2.nodeValue;
    bool = bool && this.childNodes.length === node2.childNodes.length;
    if (!bool)
      return false;
    bool = bool && !this.childNodes.reduce((last4, curr, index2) => {
      return last4 && curr.isEqualNode(node2.childNodes[index2]);
    }, true);
    if (this.nodeType === _Node.DOCUMENT_TYPE_NODE && node2.nodeType === _Node.DOCUMENT_TYPE_NODE) {
      bool = bool && this.publicId === node2.publicId;
      bool = bool && this.systemId === node2.systemId;
      bool = bool && this.internalSubset === node2.internalSubset;
    }
    return bool;
  }
  isSameNode(node2) {
    return this === node2;
  }
  lookupNamespacePrefix(namespaceURI, originalElement) {
    if (this.namespaceURI && this.namespaceURI === namespaceURI && this.prefix && originalElement.lookupNamespaceURI(this.prefix) === namespaceURI) {
      return this.prefix;
    }
    for (const [key, val] of this.attrs.entries()) {
      if (!key.includes(":"))
        continue;
      const [attrPrefix, name] = key.split(":");
      if (attrPrefix === "xmlns" && val === namespaceURI && originalElement.lookupNamespaceURI(name) === namespaceURI) {
        return name;
      }
    }
    if (this.parentNode) {
      return this.parentNode.lookupNamespacePrefix(namespaceURI, originalElement);
    }
    return null;
  }
  lookupNamespaceURI(prefix) {
    switch (this.nodeType) {
      case _Node.ELEMENT_NODE:
        if (this.namespaceURI != null && this.prefix === prefix) {
          return this.namespaceURI;
        }
        for (const [key, val] of this.attrs.entries()) {
          if (!key.includes(":"))
            continue;
          const [attrPrefix, name] = key.split(":");
          if (attrPrefix === "xmlns" && name === prefix) {
            if (val != null) {
              return val;
            }
            return null;
          } else if (name === "xmlns" && prefix == null) {
            if (val != null) {
              return val;
            }
            return null;
          }
        }
        if (this.parentNode) {
          return this.parentNode.lookupNamespaceURI(prefix);
        }
        return null;
      case _Node.DOCUMENT_NODE:
        return this.documentElement.lookupNamespaceURI(prefix);
      case _Node.ENTITY_NODE:
      case _Node.NOTATION_NODE:
      case _Node.DOCUMENT_TYPE_NODE:
      case _Node.DOCUMENT_FRAGMENT_NODE:
        return null;
      case _Node.ATTRIBUTE_NODE:
        if (this.ownerElement) {
          return this.ownerElement.lookupNamespaceURI(prefix);
        }
        return null;
      default:
        if (this.parentNode) {
          return this.parentNode.lookupNamespaceURI(prefix);
        }
        return null;
    }
  }
  lookupPrefix(namespaceURI) {
    if (!namespaceURI) {
      return null;
    }
    const type = this.nodeType;
    switch (type) {
      case _Node.ELEMENT_NODE:
        return this.lookupNamespacePrefix(namespaceURI, this);
      case _Node.DOCUMENT_NODE:
        return this.documentElement.lookupNamespacePrefix(namespaceURI);
      case _Node.ENTITY_NODE:
      case _Node.NOTATION_NODE:
      case _Node.DOCUMENT_FRAGMENT_NODE:
      case _Node.DOCUMENT_TYPE_NODE:
        return null;
      case _Node.ATTRIBUTE_NODE:
        if (this.ownerElement) {
          return this.ownerElement.lookupNamespacePrefix(namespaceURI);
        }
        return null;
      default:
        if (this.parentNode) {
          return this.parentNode.lookupNamespacePrefix(namespaceURI);
        }
        return null;
    }
  }
  normalize() {
    const childNodes = [];
    for (const node2 of this.childNodes) {
      const last4 = childNodes.shift();
      if (!last4) {
        if (node2.data) {
          childNodes.unshift(node2);
        }
        continue;
      }
      if (node2.nodeType === _Node.TEXT_NODE) {
        if (!node2.data) {
          childNodes.unshift(last4);
          continue;
        }
        if (last4.nodeType === _Node.TEXT_NODE) {
          const merged = this.ownerDocument.createTextNode(last4.data + node2.data);
          childNodes.push(merged);
          continue;
        }
        childNodes.push(last4, node2);
      }
    }
    childNodes.forEach((node2) => {
      node2.parentNode = this;
    });
    this.childNodes = childNodes;
  }
  removeChild(node2) {
    node2.parentNode = null;
    const index2 = this.childNodes.indexOf(node2);
    if (index2 === -1)
      return node2;
    this.childNodes.splice(index2, 1);
    return node2;
  }
  replaceChild(newChild, oldChild) {
    const before = oldChild.nextSibling;
    this.removeChild(oldChild);
    this.insertBefore(newChild, before);
    return oldChild;
  }
  get nextSibling() {
    const child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) + 1];
    return child || null;
  }
  get previousSibling() {
    const child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) - 1];
    return child || null;
  }
  get textContent() {
    if (this.nodeType === _Node.TEXT_NODE)
      return this.data;
    if (this.nodeType === _Node.CDATA_SECTION_NODE)
      return this.data;
    if (this.nodeType === _Node.COMMENT_NODE)
      return this.data;
    return this.childNodes.reduce(function(last4, current) {
      return last4 + current.textContent;
    }, "");
  }
  set textContent(text) {
    if (this.nodeType === _Node.TEXT_NODE || this.nodeType === _Node.CDATA_SECTION_NODE || this.nodeType === _Node.COMMENT_NODE) {
      this.data = text;
      return;
    }
    this.childNodes = [];
    this.appendChild(this.ownerDocument.createTextNode(text));
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
};
extendStatic(Node, nodeTypes);
extend2(Node, nodeTypes);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Attr.js
var Attr = class extends Node {
  constructor(name, props, ns) {
    super(name, { nodeValue: "", ...props }, ns);
    this.nodeName = ns === html ? name.toLowerCase() : name;
    this.nodeType = Node.ATTRIBUTE_NODE;
    this.ownerElement = null;
  }
  get value() {
    return this.nodeValue;
  }
  set value(val) {
    this.nodeValue = val;
  }
  get name() {
    return this.nodeName;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/mixins/NonDocumentTypeChildNode.js
var NonDocumentTypeChildNode = {};
Object.defineProperties(NonDocumentTypeChildNode, {
  previousElementSibling: {
    get() {
      let node2;
      while (node2 = this.previousSibling) {
        if (node2.nodeType === node2.ELEMENT_NODE) {
          return node2;
        }
      }
      return null;
    }
  },
  nextElementSibling: {
    get() {
      let node2;
      while (node2 = this.nextSibling) {
        if (node2.nodeType === node2.ELEMENT_NODE) {
          return node2;
        }
      }
      return null;
    }
  }
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/nodesToNode.js
var nodesToNode = (nodes, document2) => {
  nodes = nodes.map((node3) => {
    if (typeof node3 === "string") {
      return document2.createTextNode(node3);
    }
    return node3;
  });
  if (nodes.length === 1) {
    return nodes[0];
  }
  const node2 = document2.createDocumentFragment();
  nodes.forEach(node2.appendChild, node2);
  return node2;
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/mixins/ChildNode.js
var ChildNode = {
  before(...nodes) {
    if (!this.parentNode)
      return;
    const node2 = nodesToNode(nodes, this.ownerDocument);
    this.parentNode.insertBefore(node2, this);
  },
  after(...nodes) {
    if (!this.parentNode)
      return;
    const node2 = nodesToNode(nodes, this.ownerDocument);
    this.parentNode.insertBefore(node2, this.nextSibling);
  },
  replaceWith(...nodes) {
    if (!this.parentNode)
      return;
    const next = this.nextSibling;
    const node2 = nodesToNode(nodes, this.ownerDocument);
    this.parentNode.insertBefore(node2, next);
    this.remove();
  },
  remove() {
    if (!this.parentNode)
      return;
    this.parentNode.removeChild(this);
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/CharacterData.js
var CharacterData = class extends Node {
  constructor(name, props) {
    super(name, props);
    this.data = this.nodeValue;
  }
  appendData(data) {
    this.data += data;
  }
  deleteData(offset, count) {
    this.data = this.data.slice(0, offset) + this.data.slice(0, offset + count);
  }
  insertData(offset, data) {
    this.data = this.data.slice(0, offset) + data + this.data.slice(offset);
  }
  replaceData(offset, count, data) {
    this.deleteData(offset, count);
    this.insertData(offset, data);
  }
  substringData(offset, count) {
    this.data = this.data.substr(offset, count);
  }
  get length() {
    return this.data.length;
  }
};
mixin(NonDocumentTypeChildNode, CharacterData);
mixin(ChildNode, CharacterData);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Comment.js
var Comment = class extends CharacterData {
  constructor(name, props) {
    super(name, props);
    this.nodeType = Node.COMMENT_NODE;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Event.js
var Event = class {
  constructor(type) {
    this.type = type;
    this.cancelable = false;
    this.defaultPrevented = false;
    this.target = null;
  }
  preventDefault() {
    if (this.cancelable) {
      this.defaultPrevented = true;
    }
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/CustomEvent.js
var CustomEvent = class extends Event {
  constructor(name, props = {}) {
    super(name);
    this.detail = props.detail || null;
    this.cancelable = props.cancelable || false;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Text.js
var Text2 = class extends CharacterData {
  constructor(name, props) {
    super(name, props);
    this.nodeType = Node.TEXT_NODE;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/NodeFilter.js
var NodeFilter = class _NodeFilter {
  acceptNode() {
    return _NodeFilter.FILTER_ACCEPT;
  }
};
extendStatic(NodeFilter, {
  FILTER_ACCEPT: 1,
  FILTER_REJECT: 2,
  FILTER_IGNORE: 4,
  SHOW_ALL: -1,
  SHOW_ELEMENT: 1,
  SHOW_TEXT: 4,
  SHOW_ENTITY_REFERENCE: 16,
  SHOW_ENTITY: 32,
  SHOW_PROCESSING_INSTRUCTION: 64,
  SHOW_COMMENT: 128,
  SHOW_DOCUMENT: 256,
  SHOW_DOCUMENT_TYPE: 512,
  SHOW_DOCUMENT_FRAGMENT: 1024,
  SHOW_NOTATION: 2048
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/NodeIterator.js
var showThisNode = (whatToShow, node2) => {
  if (whatToShow === NodeFilter.SHOW_ALL)
    return true;
  if (whatToShow & NodeFilter.SHOW_ELEMENT && node2.nodeType === node2.ELEMENT_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_TEXT && node2.nodeType === node2.TEXT_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_ENTITY_REFERENCE && node2.nodeType === node2.ENTITY_REFERENCE_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_ENTITY && node2.nodeType === node2.ENTITY_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_PROCESSING_INSTRUCTION && node2.nodeType === node2.PROCESSING_INSTRUCTION_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_COMMENT && node2.nodeType === node2.COMMENT_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_DOCUMENT && node2.nodeType === node2.DOCUMENT_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_DOCUMENT_TYPE && node2.nodeType === node2.DOCUMENT_TYPE_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_DOCUMENT_FRAGMENT && node2.nodeType === node2.DOCUMENT_FRAGMENT_NODE)
    return true;
  if (whatToShow & NodeFilter.SHOW_NOTATION && node2.nodeType === node2.NOTATION_NODE)
    return true;
  return false;
};
var NodeIterator = class _NodeIterator {
  constructor(root3, whatToShow = NodeFilter.SHOW_ALL, filter3 = () => NodeFilter.FILTER_ACCEPT, includeParent = true) {
    this.root = includeParent ? { childNodes: [root3] } : root3;
    this.whatToShow = whatToShow;
    this.filter = filter3;
  }
  *[Symbol.iterator]() {
    const nodes = this.root.childNodes;
    for (const node2 of nodes) {
      if (!showThisNode(this.whatToShow, node2))
        continue;
      const filterRet = this.filter(node2);
      if (filterRet === NodeFilter.FILTER_REJECT)
        continue;
      if (filterRet === NodeFilter.FILTER_ACCEPT) {
        yield node2;
      }
      yield* new _NodeIterator(node2, this.whatToShow, this.filter, false);
    }
    return this;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/mixins/elementAccess.js
var hasClass = (node2, name) => {
  const classList = node2.className.split(/\s+/);
  return classList.includes(name);
};
var elementAccess = {
  getElementsByTagName(name) {
    const iter = new NodeIterator(this, NodeFilter.SHOW_ELEMENT, (node2) => node2.nodeName === name ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_IGNORE, false);
    return [...iter];
  },
  getElementsByTagNameNS(ns, name) {
    const iter = new NodeIterator(this, NodeFilter.SHOW_ELEMENT, (node2) => node2.isNamespace(ns) && node2.nodeName === name ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_IGNORE, false);
    return [...iter];
  },
  getElementsByClassName(name) {
    const iter = new NodeIterator(this, NodeFilter.SHOW_ELEMENT, (node2) => hasClass(node2, name) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_IGNORE, false);
    return [...iter];
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/strUtils.js
var fullHex = function(hex2) {
  return hex2.length === 4 ? [
    "#",
    hex2.substring(1, 2),
    hex2.substring(1, 2),
    hex2.substring(2, 3),
    hex2.substring(2, 3),
    hex2.substring(3, 4),
    hex2.substring(3, 4)
  ].join("") : hex2;
};
var hexToRGB = function(valOrMap) {
  if (typeof valOrMap instanceof Map) {
    for (const [key, val] of valOrMap) {
      valOrMap.set(key, hexToRGB(val));
    }
    return valOrMap;
  }
  if (!/#[0-9a-f]{3,6}/.test(valOrMap)) {
    return valOrMap;
  }
  valOrMap = fullHex(valOrMap);
  return "rgb(" + [
    parseInt(valOrMap.slice(1, 3), 16),
    parseInt(valOrMap.slice(3, 5), 16),
    parseInt(valOrMap.slice(5, 7), 16)
  ].join(",") + ")";
};
function decamelize(s) {
  return String(s).replace(/([a-z])([A-Z])/g, function(m, g1, g2) {
    return g1 + "-" + g2.toLowerCase();
  });
}
function camelCase(s) {
  return String(s).replace(/([a-z])-([a-z])/g, function(m, g1, g2) {
    return g1 + g2.toUpperCase();
  });
}
function removeQuotes(str3) {
  if (str3.startsWith('"') || str3.startsWith("'")) {
    return str3.slice(1, -1);
  }
  return str3;
}
function htmlEntities2(str3) {
  return String(str3).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function cdata(str3) {
  return `<![CDATA[${str3}]]>`;
}
function comment(str3) {
  return `<!--${str3}-->`;
}
var splitNotInBrackets = (str3, delimiter2) => {
  var roundBrackets = 0;
  var squareBrackets = 0;
  var lastIndex = 0;
  var split = [];
  var ch;
  var i2;
  var il;
  for (i2 = 0, il = str3.length; i2 < il; ++i2) {
    ch = str3.charAt(i2);
    if (ch === delimiter2 && !roundBrackets && !squareBrackets) {
      split.push(str3.slice(lastIndex, i2).trim());
      lastIndex = i2 + 1;
      continue;
    }
    if (ch === "(")
      ++roundBrackets;
    else if (ch === ")")
      --roundBrackets;
    else if (ch === "[")
      ++squareBrackets;
    else if (ch === "]")
      --squareBrackets;
  }
  split.push(str3.slice(lastIndex).trim());
  return split;
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/regex.js
var transforms = /\)\s*,?\s*/;
var delimiter = /[\s,]+/;
var hyphen = /([^e])-/gi;
var pathLetters = /[MLHVCSQTAZ]/gi;
var isPathLetter = /[MLHVCSQTAZ]/i;
var numbersWithDots = /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi;
var dots = /\./g;

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/other/CssQuery.js
var CssQuery = class _CssQuery {
  constructor(query) {
    if (_CssQuery.cache.has(query)) {
      this.queries = _CssQuery.cache.get(query);
      return;
    }
    let queries = splitNotInBrackets(query, ",");
    queries = queries.map((query2) => {
      let roundBrackets = 0;
      let squareBrackets = 0;
      query2 = query2.replace(/[()[\]>~+]/g, function(ch) {
        if (ch === "(")
          ++roundBrackets;
        else if (ch === ")")
          --roundBrackets;
        else if (ch === "[")
          ++squareBrackets;
        else if (ch === "]")
          --squareBrackets;
        if ("()[]".indexOf(ch) > -1)
          return ch;
        if (squareBrackets || roundBrackets)
          return ch;
        return " " + ch + " ";
      });
      query2 = splitNotInBrackets(query2, " ").filter((el) => !!el.length);
      const pairs = [];
      let relation = "%";
      for (let i2 = 0, il = query2.length; i2 < il; ++i2) {
        if (">~+%".indexOf(query2[i2]) > -1) {
          relation = query2[i2];
          continue;
        }
        pairs.push([relation, query2[i2]]);
        relation = "%";
      }
      return pairs;
    });
    this.queries = queries;
    if (_CssQuery.cacheKeys.length > 50) {
      _CssQuery.cache.delete(_CssQuery.cacheKeys.shift());
    }
    _CssQuery.cache.set(query, queries);
    _CssQuery.cacheKeys.push(query);
  }
  matches(node2, scope) {
    for (let i2 = this.queries.length; i2--; ) {
      if (this.matchHelper(this.queries[i2], node2, scope)) {
        return true;
      }
    }
    return false;
  }
  matchHelper(query, node2, scope) {
    query = query.slice();
    const last4 = query.pop();
    if (!new CssQueryNode(last4[1]).matches(node2, scope)) {
      return false;
    }
    if (!query.length)
      return true;
    if (last4[0] === ",")
      return true;
    if (last4[0] === "+") {
      return !!node2.previousSibling && this.matchHelper(query, node2.previousSibling, scope);
    }
    if (last4[0] === ">") {
      return !!node2.parentNode && this.matchHelper(query, node2.parentNode, scope);
    }
    if (last4[0] === "~") {
      while (node2 = node2.previousSibling) {
        if (this.matchHelper(query, node2, scope)) {
          return true;
        }
      }
      return false;
    }
    if (last4[0] === "%") {
      while (node2 = node2.parentNode) {
        if (this.matchHelper(query, node2, scope)) {
          return true;
        }
      }
      return false;
    }
  }
};
CssQuery.cache = /* @__PURE__ */ new Map();
CssQuery.cacheKeys = [];
var nth3 = (node, arr, nth) => {
  if (nth === "even")
    nth = "2n";
  else if (nth === "odd")
    nth = "2n+1";
  if (/[^\d\-n+*/]+/.test(nth))
    return false;
  nth = nth.replace("n", "*n");
  for (var i, n = 0, nl = arr.length; n < nl; ++n) {
    i = eval(nth);
    if (i > nl)
      break;
    if (arr[i - 1] === node)
      return true;
  }
  return false;
};
var lower = (a) => a.toLowerCase();
var eq3 = (a, b10, i2) => i2 ? lower(a) === lower(b10) : a === b10;
var attributeMatcher = {
  "=": (i2, a, b10) => eq3(a, b10, i2),
  "~=": (i2, a, b10) => b10.split(delimiter).filter((el) => eq3(el, a, i2)).length > 0,
  "|=": (i2, a, b10) => eq3(b10.split(delimiter)[0], a, i2),
  "^=": (i2, a, b10) => i2 ? lower(b10).startsWith(lower(a)) : b10.startsWith(a),
  "$=": (i2, a, b10) => i2 ? lower(b10).endsWith(lower(a)) : b10.endsWith(a),
  "*=": (i2, a, b10) => i2 ? lower(b10).includes(lower(a)) : b10.includes(a),
  "*": (i2, a, b10) => b10 != null
};
var getAttributeValue = (prefix, name, node2) => {
  if (!prefix || prefix === "*") {
    return node2.getAttribute(name);
  }
  return node2.getAttribute(prefix + ":" + name);
};
var pseudoMatcher = {
  "first-child": (a, n2) => n2.parentNode && n2.parentNode.firstChild === n2,
  "last-child": (a, n2) => n2.parentNode && n2.parentNode.lastChild === n2,
  "nth-child": (a, n2) => n2.parentNode && nth3(n2, n2.parentNode.childNodes, a),
  "nth-last-child": (a, n2) => n2.parentNode && nth3(n2, n2.parentNode.childNodes.slice().reverse(), a),
  "first-of-type": (a, n2) => n2.parentNode && n2.parentNode.childNodes.filter((el) => el.nodeName === n2.nodeName)[0] === n2,
  "last-of-type": (a, n2) => n2.parentNode && n2.parentNode.childNodes.filter((el) => el.nodeName === n2.nodeName).pop() === n2,
  "nth-of-type": (a, n2) => n2.parentNode && nth3(n2, n2.parentNode.childNodes.filter((el) => el.nodeName === n2.nodeName), a),
  "nth-last-of-type": (a, n2) => n2.parentNode && nth3(n2, n2.parentNode.childNodes.filter((el) => el.nodeName === n2.nodeName).reverse(), a),
  "only-child": (a, n2) => n2.parentNode && n2.parentNode.childNodes.length === 1,
  "only-of-type": (a, n2) => n2.parentNode && n2.parentNode.childNodes.filter((el) => el.nodeName === n2.nodeName).length === 1,
  root: (a, n2) => n2.ownerDocument.documentElement === n2,
  not: (a, n2, s) => !new CssQuery(a).matches(n2, s),
  matches: (a, n2, s) => new CssQuery(a).matches(n2, s),
  scope: (a, n2, s) => n2 === s
};
var CssQueryNode = class {
  constructor(node2) {
    this.tag = "";
    this.id = "";
    this.classList = [];
    this.attrs = [];
    this.pseudo = [];
    let matches = node2.match(/^[\w-]+|^\*/);
    if (matches) {
      this.tag = matches[0];
      node2 = node2.slice(this.tag.length);
    }
    while (matches = /:([\w-]+)(?:\((.+)\))?/g.exec(node2)) {
      this.pseudo.push(pseudoMatcher[matches[1]].bind(this, removeQuotes(matches[2] || "")));
      node2 = node2.slice(0, matches.index) + node2.slice(matches.index + matches[0].length);
    }
    while (matches = /\[([\w-*]+\|)?([\w-]+)(([=^~$|*]+)(.+?)( +[iI])?)?\]/g.exec(node2)) {
      const prefix = matches[1] ? matches[1].split("|")[0] : null;
      this.attrs.push({
        name: matches[2],
        getValue: getAttributeValue.bind(this, prefix, matches[2]),
        matcher: attributeMatcher[matches[4] || "*"].bind(
          this,
          !!matches[6],
          // case insensitive yes/no
          removeQuotes((matches[5] || "").trim())
          // attribute value
        )
      });
      node2 = node2.slice(0, matches.index) + node2.slice(matches.index + matches[0].length);
    }
    matches = node2.match(/#([\w-]+)/);
    if (matches) {
      this.id = matches[1];
      node2 = node2.slice(0, matches.index) + node2.slice(matches.index + matches[0].length);
    }
    while (matches = /\.([\w-]+)/g.exec(node2)) {
      this.classList.push(matches[1]);
      node2 = node2.slice(0, matches.index) + node2.slice(matches.index + matches[0].length);
    }
  }
  matches(node2, scope) {
    let i2;
    if (node2.nodeType !== 1)
      return false;
    if (node2.namespaceURI === html) {
      this.tag = this.tag.toUpperCase();
    }
    if (this.tag && this.tag !== node2.nodeName && this.tag !== "*") {
      return false;
    }
    if (this.id && this.id !== node2.id) {
      return false;
    }
    const classList = (node2.getAttribute("class") || "").split(delimiter).filter((el) => !!el.length);
    if (this.classList.filter((className) => classList.indexOf(className) < 0).length) {
      return false;
    }
    for (i2 = this.attrs.length; i2--; ) {
      const attrValue = this.attrs[i2].getValue(node2);
      if (attrValue === null || !this.attrs[i2].matcher(attrValue)) {
        return false;
      }
    }
    for (i2 = this.pseudo.length; i2--; ) {
      if (!this.pseudo[i2](node2, scope)) {
        return false;
      }
    }
    return true;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/mixins/ParentNode.js
var ParentNode = {
  matchWithScope(query, scope) {
    return new CssQuery(query).matches(this, scope);
  },
  query(query, scope, single = false) {
    const iter = new NodeIterator(scope, NodeFilter.SHOW_ELEMENT, (node2) => node2.matchWithScope(query, scope) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_IGNORE, false);
    const nodes = [];
    for (const node2 of iter) {
      nodes.push(node2);
      if (single)
        return nodes;
    }
    return nodes;
  },
  querySelectorAll(query) {
    return this.query(query, this);
  },
  querySelector(query) {
    return this.query(query, this, true)[0] || null;
  },
  closest(query) {
    const cssQuery = new CssQuery(query);
    let node2 = this;
    while (node2) {
      if (cssQuery.matches(node2, this)) {
        return node2;
      }
      node2 = node2.parentNode;
    }
    return null;
  },
  prepend(...nodes) {
    const node2 = nodesToNode(nodes, this.ownerDocument);
    this.insertBefore(node2, this.firstChild);
  },
  append(...nodes) {
    const node2 = nodesToNode(nodes, this.ownerDocument);
    this.appendChild(node2);
  },
  replaceChildren(...nodes) {
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }
    this.append(...nodes);
  }
};
Object.defineProperties(ParentNode, {
  children: {
    get() {
      return this.childNodes.filter(function(node2) {
        return node2.nodeType === node2.ELEMENT_NODE;
      });
    }
  },
  firstElementChild: {
    get() {
      for (const node2 of this.childNodes) {
        if (node2 && node2.nodeType === node2.ELEMENT_NODE) {
          return node2;
        }
      }
      return null;
    }
  },
  lastElementChild: {
    get() {
      for (const node2 of this.childNodes.slice().reverse()) {
        if (node2 && node2.nodeType === node2.ELEMENT_NODE) {
          return node2;
        }
      }
      return null;
    }
  },
  childElementCount: {
    get() {
      return this.children.length;
    }
  }
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/mixins/NonElementParentNode.js
var NonElementParentNode = {
  getElementById(id9) {
    const iter = new NodeIterator(this, NodeFilter.SHOW_ELEMENT, (node2) => id9 === node2.id ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_IGNORE, false);
    for (const node2 of iter) {
      return node2;
    }
    return null;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/DocumentFragment.js
var DocumentFragment = class extends Node {
  constructor(name, props) {
    super(name, props);
    this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
  }
};
mixin(elementAccess, DocumentFragment);
mixin(ParentNode, DocumentFragment);
mixin(NonElementParentNode, DocumentFragment);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/html/HTMLParser.js
var import_sax = __toESM(require_sax(), 1);
var HTMLParser = function(str3, el) {
  let currentTag = el;
  let document2 = el.ownerDocument;
  let cdata2 = null;
  if (el.nodeType !== el.DOCUMENT_NODE) {
    str3 = '<svgdom:wrapper xmlns:svgdom="svgdom:rocks">' + str3 + "</svgdom:wrapper>";
  } else {
    document2 = el;
  }
  const parser = import_sax.default.parser(true, {
    // lowercase: true,
    xmlns: true,
    strictEntities: true
  });
  parser.onerror = (e) => {
    throw e;
  };
  parser.ondoctype = (str4) => {
    if (currentTag !== document2) {
      throw new Error("Doctype can only be appended to document");
    }
    currentTag.appendChild(document2.implementation.createDocumentType());
  };
  parser.ontext = (str4) => currentTag.appendChild(document2.createTextNode(str4));
  parser.oncomment = (str4) => currentTag.appendChild(document2.createComment(str4));
  parser.onopentag = (node2) => {
    if (node2.name === "svgdom:wrapper")
      return;
    const attrs = node2.attributes;
    const uri = node2.uri || currentTag.lookupNamespaceURI(node2.prefix || null);
    var newElement = document2.createElementNS(uri, node2.name);
    for (const [name, node3] of Object.entries(attrs)) {
      newElement.setAttributeNS(node3.uri, name, node3.value);
    }
    currentTag.appendChild(newElement);
    currentTag = newElement;
  };
  parser.onclosetag = (tagName) => {
    if (tagName === "svgdom:wrapper")
      return;
    currentTag = currentTag.parentNode;
  };
  parser.onopencdata = () => {
    cdata2 = document2.createCDATASection("");
  };
  parser.oncdata = (str4) => {
    cdata2.appendData(str4);
  };
  parser.onclosecdata = () => {
    currentTag.appendChild(cdata2);
  };
  parser.write(str3);
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/mapUtils.js
var mapMap = function(map4, cb) {
  var arr2 = [];
  map4.forEach(function(value, key) {
    arr2.push(cb(value, key));
  });
  return arr2;
};
var mapToCss = function(myMap) {
  return mapMap(myMap, function(value, key) {
    if (!value)
      return false;
    return decamelize(key) + ": " + value;
  }).filter(function(el) {
    return !!el;
  }).join("; ") + ";" || null;
};
var cssToMap = function(css) {
  return new Map(css.split(/\s*;\s*/).filter(function(el) {
    return !!el;
  }).map(function(el) {
    return el.split(/\s*:\s*/);
  }));
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Element.js
var validateAndExtract = (ns, name) => {
  let prefix = null;
  let localname = name;
  if (!ns)
    ns = null;
  if (name.includes(":")) {
    [prefix, localname] = name.split(":");
  }
  if (!ns && prefix) {
    throw new Error("Namespace Error");
  }
  if (prefix === "xml" && ns !== xml) {
    throw new Error("Namespace Error");
  }
  if ((prefix === "xmlns" || name === "xmlns") && ns !== xmlns) {
    throw new Error("Namespace Error");
  }
  if (prefix !== "xmlns" && name !== "xmlns" && ns === xmlns) {
    throw new Error("Namespace Error");
  }
  return [ns, prefix, localname];
};
var getAttributeByNsAndLocalName = (el, ns, localName) => {
  if (!ns)
    ns = null;
  return [...el.attrs].find((node2) => node2.localName === localName && node2.namespaceURI === ns);
};
var getAttributeByQualifiedName = (el, qualifiedName) => {
  if (el.namespaceURI === html && el.ownerDocument.namespaceURI === html) {
    qualifiedName = qualifiedName.toLowerCase();
  }
  return [...el.attrs].find((node2) => node2.name === qualifiedName);
};
var getStyleProxy = (node2) => {
  return new Proxy(node2, {
    get(target, key) {
      const styles = target.getAttribute("style") || "";
      const styleMap = cssToMap(styles);
      if (key === "cssText") {
        return styles;
      }
      if (key === "setProperty") {
        return function(propertyName, value = "", priority = "") {
          node2.style[propertyName] = value + (priority ? ` !${priority}` : "");
        };
      }
      if (key === "getPropertyValue") {
        return function(propertyName) {
          return node2.style[propertyName] ?? "";
        };
      }
      key = decamelize(key);
      if (!styleMap.has(key))
        return "";
      return styleMap.get(key);
    },
    set(target, key, value) {
      key = decamelize(key);
      if (key === "css-text") {
        target.setAttribute("style", mapToCss(cssToMap(value)));
        return true;
      } else {
        value = hexToRGB(value.toString());
        const styles = target.getAttribute("style") || "";
        const styleMap = cssToMap(styles);
        styleMap.set(key, value);
        target.setAttribute("style", mapToCss(styleMap));
        return true;
      }
    }
  });
};
var Element3 = class extends Node {
  constructor(name, props, ns) {
    super(name, props, ns);
    this.style = getStyleProxy(this);
    this.tagName = this.nodeName;
  }
  getAttribute(qualifiedName) {
    const attr = this.getAttributeNode(qualifiedName);
    return attr ? attr.value : null;
  }
  getAttributeNode(qualifiedName) {
    return getAttributeByQualifiedName(this, qualifiedName);
  }
  getAttributeNodeNS(ns, localName) {
    return getAttributeByNsAndLocalName(this, ns, localName);
  }
  getAttributeNS(ns, localName) {
    const attr = this.getAttributeNodeNS(ns, localName);
    return attr ? attr.value : null;
  }
  getBoundingClientRect() {
    throw new Error("Only implemented for SVG Elements");
  }
  hasAttribute(qualifiedName) {
    const attr = this.getAttributeNode(qualifiedName);
    return !!attr;
  }
  hasAttributeNS(ns, localName) {
    const attr = this.getAttributeNodeNS(ns, localName);
    return !!attr;
  }
  matches(query) {
    return this.matchWithScope(query, this);
  }
  removeAttribute(qualifiedName) {
    const attr = this.getAttributeNode(qualifiedName);
    if (attr) {
      this.removeAttributeNode(attr);
    }
    return attr;
  }
  removeAttributeNode(node2) {
    if (!this.attrs.delete(node2))
      throw new Error("Attribute cannot be removed because it was not found on the element");
    return node2;
  }
  // call is: d.removeAttributeNS('http://www.mozilla.org/ns/specialspace', 'align', 'center');
  removeAttributeNS(ns, localName) {
    const attr = this.getAttributeNodeNS(ns, localName);
    if (attr) {
      this.removeAttributeNode(attr);
    }
    return attr;
  }
  /* The setAttribute(qualifiedName, value) method, when invoked, must run these steps:
  
      If qualifiedName does not match the Name production in XML, then throw an "InvalidCharacterError" DOMException.
  
      If this is in the HTML namespace and its node document is an HTML document, then set qualifiedName to qualifiedName in ASCII lowercase.
  
      Let attribute be the first attribute in this’s attribute list whose qualified name is qualifiedName, and null otherwise.
  
      If attribute is null, create an attribute whose local name is qualifiedName, value is value, and node document is this’s node document, then append this attribute to this, and then return.
  
      Change attribute to value.
    */
  setAttribute(qualifiedName, value) {
    if (this.namespaceURI === html && this.ownerDocument.namespaceURI === html) {
      qualifiedName = qualifiedName.toLowerCase();
    }
    let attr = this.getAttributeNode(qualifiedName);
    if (!attr) {
      attr = this.ownerDocument.createAttributeNS(null, qualifiedName, true);
      this.setAttributeNode(attr);
    }
    attr.value = value;
  }
  /*
      Let namespace, prefix, and localName be the result of passing namespace and qualifiedName to validate and extract.
  
      Set an attribute value for this using localName, value, and also prefix and namespace.
  
      If prefix is not given, set it to null.
      If namespace is not given, set it to null.
      Let attribute be the result of getting an attribute given namespace, localName, and element.
      If attribute is null, create an attribute whose namespace is namespace, namespace prefix is prefix, local name is localName, value is value, and node document is element’s node document, then append this attribute to element, and then return.
  
      Change attribute to value.
    */
  setAttributeNode(node2) {
    this.attrs.add(node2);
    node2.ownerElement = this;
  }
  // call is: d.setAttributeNS('http://www.mozilla.org/ns/specialspace', 'spec:align', 'center');
  setAttributeNS(namespace, name, value) {
    const [ns, prefix, localName] = validateAndExtract(namespace, name);
    let attr = this.getAttributeNodeNS(ns, localName);
    if (!attr) {
      attr = this.ownerDocument.createAttributeNS(ns, name);
      this.setAttributeNode(attr);
    }
    attr.value = value;
    this.attrs.add(attr);
  }
  get attributes() {
    return [...this.attrs];
  }
  get className() {
    return this.getAttribute("class");
  }
  set className(c) {
    this.setAttribute("class", c);
  }
  get id() {
    return this.getAttribute("id") || "";
  }
  set id(id9) {
    return this.setAttribute("id", id9);
  }
  get innerHTML() {
    return this.childNodes.map((node2) => {
      if (node2.nodeType === Node.TEXT_NODE)
        return htmlEntities2(node2.data);
      if (node2.nodeType === Node.CDATA_SECTION_NODE)
        return cdata(node2.data);
      if (node2.nodeType === Node.COMMENT_NODE)
        return comment(node2.data);
      return node2.outerHTML;
    }).join("");
  }
  set innerHTML(str3) {
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }
    HTMLParser(str3, this);
  }
  get outerHTML() {
    return tag(this);
  }
  set outerHTML(str3) {
    const well = new DocumentFragment();
    HTMLParser(str3, well);
    this.parentNode.insertBefore(well, this);
    this.parentNode.removeChild(this);
  }
};
mixin(ParentNode, Element3);
mixin(elementAccess, Element3);
mixin(NonDocumentTypeChildNode, Element3);
mixin(ChildNode, Element3);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/html/HTMLElement.js
var HTMLElement2 = class extends Element3 {
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/html/HTMLLinkElement.js
var HTMLLinkElement = class extends HTMLElement2 {
};
Object.defineProperties(HTMLLinkElement.prototype, {
  href: {
    get() {
      return this.getAttribute("href");
    },
    set(val) {
      this.setAttribute("href", val);
    }
  },
  rel: {
    get() {
      return this.getAttribute("rel");
    },
    set(val) {
      this.setAttribute("rel", val);
    }
  },
  type: {
    get() {
      return this.getAttribute("type");
    },
    set(val) {
      this.setAttribute("type", val);
    }
  }
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/html/HTMLScriptElement.js
var HTMLScriptElement = class extends HTMLElement2 {
};
Object.defineProperties(HTMLScriptElement.prototype, {
  src: {
    get() {
      return this.getAttribute("src");
    },
    set(val) {
      this.setAttribute("src", val);
    }
  },
  type: {
    get() {
      return this.getAttribute("type");
    },
    set(val) {
      this.setAttribute("type", val);
    }
  }
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/html/HTMLImageElement.js
var import_image_size = __toESM(require_dist(), 1);
var HTMLImageElement = class extends HTMLElement2 {
  constructor(...args) {
    super(...args);
    this.naturalWidth = 0;
    this.naturalHeight = 0;
    this.complete = false;
  }
};
Object.defineProperties(HTMLImageElement.prototype, {
  src: {
    get() {
      return this.getAttribute("src");
    },
    set(val) {
      this.setAttribute("src", val);
      (0, import_image_size.default)(val, (err, size4) => {
        if (err) {
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.naturalWidth = size4.width;
        this.naturalHeight = size4.height;
        this.complete = true;
        this.dispatchEvent(new Event("load"));
      });
    }
  },
  height: {
    get() {
      return this.getAttribute("height") || this.naturalHeight;
    },
    set(val) {
      this.setAttribute("height", val);
    }
  },
  width: {
    get() {
      return this.getAttribute("width") || this.naturalWidth;
    },
    set(val) {
      this.setAttribute("width", val);
    }
  }
});

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGElement.js
var SVGElement = class extends Element3 {
  get ownerSVGElement() {
    let parent = this;
    while (parent = parent.parentNode) {
      if ("svg" == parent.nodeName) {
        return parent;
      }
    }
    return null;
  }
  get viewportElement() {
    let parent = this;
    while (parent = parent.parentNode) {
      if (["svg", "symbol"].includes(parent.nodeName)) {
        return parent;
      }
    }
    return null;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGPoint.js
var SVGPoint = class _SVGPoint {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
  matrixTransform(m) {
    var r = new _SVGPoint();
    r.x = m.a * this.x + m.c * this.y + m.e * 1;
    r.y = m.b * this.x + m.d * this.y + m.f * 1;
    return r;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/other/Point.js
var Point = class _Point {
  // Initialize
  constructor(x2, y2) {
    const base = { x: 0, y: 0 };
    const source = Array.isArray(x2) ? { x: x2[0], y: x2[1] } : typeof x2 === "object" ? { x: x2.x, y: x2.y } : x2 != null ? { x: x2, y: y2 != null ? y2 : x2 } : base;
    this.x = source.x;
    this.y = source.y;
  }
  abs() {
    return Math.sqrt(this.absQuad());
  }
  absQuad() {
    return this.x * this.x + this.y * this.y;
  }
  add(x2, y2) {
    const p = new _Point(x2, y2);
    return new _Point(this.x + p.x, this.y + p.y);
  }
  angleTo(p) {
    let sign = Math.sign(this.x * p.y - this.y * p.x);
    sign = sign || 1;
    return sign * Math.acos(Math.round(this.dot(p) / (this.abs() * p.abs()) * 1e6) / 1e6);
  }
  // Clone point
  clone() {
    return new _Point(this);
  }
  closeTo(p, eta = 1e-5) {
    return this.equals(p) || Math.abs(this.x - p.x) < eta && Math.abs(this.y - p.y) < eta;
  }
  div(factor) {
    return new _Point(this.x / factor, this.y / factor);
  }
  dot(p) {
    return this.x * p.x + this.y * p.y;
  }
  equals(p) {
    return this.x === p.x && this.y === p.y;
  }
  mul(factor) {
    return new _Point(this.x * factor, this.y * factor);
  }
  // Convert to native SVGPoint
  native() {
    const point2 = new SVGPoint();
    point2.x = this.x;
    point2.y = this.y;
    return point2;
  }
  normal() {
    return new _Point(this.y, -this.x);
  }
  normalize() {
    const abs = this.abs();
    if (!abs)
      throw new Error("Can't normalize vector of zero length");
    return this.div(abs);
  }
  reflectAt(p) {
    return p.add(p.sub(this));
  }
  sub(x2, y2) {
    const p = new _Point(x2, y2);
    return new _Point(this.x - p.x, this.y - p.y);
  }
  toArray() {
    return [this.x, this.y];
  }
  toPath() {
    return ["M", this.x, this.y].join(" ");
  }
  // transform point with matrix
  transform(matrix) {
    return new _Point(this.native().matrixTransform(matrix));
  }
  transformO(matrix) {
    const { x: x2, y: y2 } = this.native().matrixTransform(matrix);
    this.x = x2;
    this.y = y2;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/other/Box.js
var Box = class _Box {
  constructor(source) {
    var base = [0, 0, 0, 0];
    source = typeof source === "string" ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : typeof source === "object" ? [
      source.left != null ? source.left : source.x,
      source.top != null ? source.top : source.y,
      source.width,
      source.height
    ] : arguments.length === 4 ? [].slice.call(arguments) : base;
    this.x = this.left = source[0];
    this.y = this.top = source[1];
    this.width = source[2];
    this.height = source[3];
    this.right = this.left + this.width;
    this.bottom = this.top + this.height;
  }
  // Merge rect box with another, return a new instance
  merge(box) {
    if (box instanceof NoBox)
      return new _Box(this);
    var x2 = Math.min(this.x, box.x);
    var y2 = Math.min(this.y, box.y);
    return new _Box(
      x2,
      y2,
      Math.max(this.x + this.width, box.x + box.width) - x2,
      Math.max(this.y + this.height, box.y + box.height) - y2
    );
  }
  transform(m) {
    var xMin = Infinity;
    var xMax = -Infinity;
    var yMin = Infinity;
    var yMax = -Infinity;
    var pts = [
      new Point(this.x, this.y),
      new Point(this.x + this.width, this.y),
      new Point(this.x, this.y + this.height),
      new Point(this.x + this.width, this.y + this.height)
    ];
    pts.forEach(function(p) {
      p = p.transform(m);
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });
    return new _Box(
      xMin,
      yMin,
      xMax - xMin,
      yMax - yMin
    );
  }
};
var NoBox = class _NoBox extends Box {
  // NoBox has no valid values so it cant be merged
  merge(box) {
    return box instanceof _NoBox ? new _NoBox() : new Box(box);
  }
  transform(m) {
    return new _NoBox();
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGMatrix.js
var radians = function(d) {
  return d % 360 * Math.PI / 180;
};
function matrixFactory(a, b10, c, d, e, f) {
  var r = new SVGMatrix();
  r.a = a;
  r.b = b10;
  r.c = c;
  r.d = d;
  r.e = e;
  r.f = f;
  return r;
}
var SVGMatrix = class _SVGMatrix {
  constructor() {
    this.a = this.d = 1;
    this.b = this.c = this.e = this.f = 0;
  }
  inverse() {
    var a = this.a;
    var b10 = this.b;
    var c = this.c;
    var d = this.d;
    var e = this.e;
    var f = this.f;
    var det = a * d - b10 * c;
    if (!det)
      throw new Error("Cannot invert " + this);
    var na = d / det;
    var nb = -b10 / det;
    var nc = -c / det;
    var nd = a / det;
    var ne = -(na * e + nc * f);
    var nf = -(nb * e + nd * f);
    this.a = na;
    this.b = nb;
    this.c = nc;
    this.d = nd;
    this.e = ne;
    this.f = nf;
    return this;
  }
  multiply(m) {
    var r = new _SVGMatrix();
    r.a = this.a * m.a + this.c * m.b + this.e * 0;
    r.b = this.b * m.a + this.d * m.b + this.f * 0;
    r.c = this.a * m.c + this.c * m.d + this.e * 0;
    r.d = this.b * m.c + this.d * m.d + this.f * 0;
    r.e = this.a * m.e + this.c * m.f + this.e * 1;
    r.f = this.b * m.e + this.d * m.f + this.f * 1;
    return r;
  }
  rotate(r, x2, y2) {
    r = r % 360 * Math.PI / 180;
    return this.multiply(matrixFactory(
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      x2 ? -Math.cos(r) * x2 + Math.sin(r) * y2 + x2 : 0,
      y2 ? -Math.sin(r) * x2 - Math.cos(r) * y2 + y2 : 0
    ));
  }
  scale(scaleX, scaleY = scaleX) {
    return this.multiply(matrixFactory(scaleX, 0, 0, scaleY, 0, 0));
  }
  skew(x2, y2) {
    return this.multiply(matrixFactory(1, Math.tan(radians(y2)), Math.tan(radians(x2)), 1, 0, 0));
  }
  skewX(x2) {
    return this.skew(x2, 0);
  }
  skewY(y2) {
    return this.skew(0, y2);
  }
  toString() {
    return "SVGMatrix";
  }
  translate(x2 = 0, y2 = 0) {
    return this.multiply(matrixFactory(1, 0, 0, 1, x2, y2));
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/PointCloud.js
var PointCloud = class _PointCloud extends Array {
  constructor(...args) {
    if (args.length === 1 && typeof args[0] === "number") {
      super(args.shift());
    } else {
      super();
    }
    args.reduce((last4, curr) => {
      last4.push(...curr);
      return this;
    }, this);
  }
  bbox() {
    if (!this.length) {
      return new NoBox();
    }
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    this.forEach(function(p) {
      xMin = Math.min(xMin, p.x);
      xMax = Math.max(xMax, p.x);
      yMin = Math.min(yMin, p.y);
      yMax = Math.max(yMax, p.y);
    });
    return new Box(
      xMin,
      yMin,
      xMax - xMin,
      yMax - yMin
    );
  }
  merge(cloud) {
    return new _PointCloud(this, cloud);
  }
  transform(m) {
    return new _PointCloud(this.map((p) => p.transform(m)));
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/pathUtils.js
var pathHandlers = {
  M(c, p, r, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];
    return new Move(p);
  },
  L(c, p) {
    const ret = new Line2(p.x, p.y, c[0], c[1]);
    p.x = c[0];
    p.y = c[1];
    return ret;
  },
  H(c, p) {
    return pathHandlers.L([c[0], p.y], p);
  },
  V(c, p) {
    return pathHandlers.L([p.x, c[0]], p);
  },
  Q(c, p, r) {
    const ret = Cubic.fromQuad(p, new Point(c[0], c[1]), new Point(c[2], c[3]));
    p.x = c[2];
    p.y = c[3];
    const reflect = new Point(c[0], c[1]).reflectAt(p);
    r.x = reflect.x;
    r.y = reflect.y;
    return ret;
  },
  T(c, p, r, p0, reflectionIsPossible) {
    if (reflectionIsPossible) {
      c = [r.x, r.y].concat(c);
    } else {
      c = [p.x, p.y].concat(c);
    }
    return pathHandlers.Q(c, p, r);
  },
  C(c, p, r) {
    const ret = new Cubic(p, new Point(c[0], c[1]), new Point(c[2], c[3]), new Point(c[4], c[5]));
    p.x = c[4];
    p.y = c[5];
    const reflect = new Point(c[2], c[3]).reflectAt(p);
    r.x = reflect.x;
    r.y = reflect.y;
    return ret;
  },
  S(c, p, r, p0, reflectionIsPossible) {
    if (reflectionIsPossible) {
      c = [r.x, r.y].concat(c);
    } else {
      c = [p.x, p.y].concat(c);
    }
    return pathHandlers.C(c, p, r);
  },
  Z(c, p, r, p0) {
    return pathHandlers.L([p0.x, p0.y], p);
  },
  A(c, p, r) {
    const ret = new Arc(p, new Point(c[5], c[6]), c[0], c[1], c[2], c[3], c[4]);
    p.x = c[5];
    p.y = c[6];
    return ret;
  }
};
var mlhvqtcsa = "mlhvqtcsaz".split("");
for (let i2 = 0, il = mlhvqtcsa.length; i2 < il; ++i2) {
  pathHandlers[mlhvqtcsa[i2]] = /* @__PURE__ */ function(i3) {
    return function(c, p, r, p0, reflectionIsPossible) {
      if (i3 === "H")
        c[0] = c[0] + p.x;
      else if (i3 === "V")
        c[0] = c[0] + p.y;
      else if (i3 === "A") {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (let j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }
      return pathHandlers[i3](c, p, r, p0, reflectionIsPossible);
    };
  }(mlhvqtcsa[i2].toUpperCase());
}
function pathRegReplace(a, b10, c, d) {
  return c + d.replace(dots, " .");
}
function isBeziere(obj) {
  return obj instanceof Cubic;
}
var pathParser = (array) => {
  if (!array)
    return [];
  const paramCnt = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
  array = array.replace(numbersWithDots, pathRegReplace).replace(pathLetters, " $& ").replace(hyphen, "$1 -").trim().split(delimiter);
  const arr2 = [];
  const p = new Point();
  const p0 = new Point();
  const r = new Point();
  let index2 = 0;
  const len2 = array.length;
  let s;
  do {
    if (isPathLetter.test(array[index2])) {
      s = array[index2];
      ++index2;
    } else if (s === "M") {
      s = "L";
    } else if (s === "m") {
      s = "l";
    }
    arr2.push(
      pathHandlers[s].call(
        null,
        array.slice(index2, index2 = index2 + paramCnt[s.toUpperCase()]).map(parseFloat),
        p,
        r,
        p0,
        isBeziere(arr2[arr2.length - 1])
      )
    );
  } while (len2 > index2);
  return arr2;
};
var Move = class {
  constructor(p) {
    this.p1 = p.clone();
  }
  // FIXME: Use pointcloud
  bbox() {
    const p = this.p1;
    return new Box(p.x, p.y, 0, 0);
  }
  getCloud() {
    return new PointCloud([this.p1]);
  }
  length() {
    return 0;
  }
  toPath() {
    return ["M", this.p1.x, this.p1.y].join(" ");
  }
  toPathFragment() {
    return ["M", this.p1.x, this.p1.y];
  }
  transform(matrix) {
    this.p1.transformO(matrix);
    return this;
  }
};
var Arc = class _Arc {
  constructor(p1, p2, rx, ry, \u03C6, arc, sweep) {
    if (!rx || !ry)
      return new Line2(p1, p2);
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    this.p1 = p1.clone();
    this.p2 = p2.clone();
    this.arc = arc ? 1 : 0;
    this.sweep = sweep ? 1 : 0;
    const cos\u03C6 = Math.cos(\u03C6 / 180 * Math.PI);
    const sin\u03C6 = Math.sin(\u03C6 / 180 * Math.PI);
    const p1_ = new Point(
      (p1.x - p2.x) / 2,
      (p1.y - p2.y) / 2
    ).transform(matrixFactory(
      cos\u03C6,
      -sin\u03C6,
      sin\u03C6,
      cos\u03C6,
      0,
      0
    ));
    const ratio = p1_.x ** 2 / rx ** 2 + p1_.y ** 2 / ry ** 2;
    if (ratio > 1) {
      rx = Math.sqrt(ratio) * rx;
      ry = Math.sqrt(ratio) * ry;
    }
    const rxQuad = rx ** 2;
    const ryQuad = ry ** 2;
    const divisor1 = rxQuad * p1_.y ** 2;
    const divisor2 = ryQuad * p1_.x ** 2;
    const dividend = rxQuad * ryQuad - divisor1 - divisor2;
    let c_;
    if (Math.abs(dividend) < 1e-15) {
      c_ = new Point(0, 0);
    } else {
      c_ = new Point(
        rx * p1_.y / ry,
        -ry * p1_.x / rx
      ).mul(Math.sqrt(
        dividend / (divisor1 + divisor2)
      ));
    }
    if (this.arc === this.sweep)
      c_ = c_.mul(-1);
    const c = c_.transform(matrixFactory(
      cos\u03C6,
      sin\u03C6,
      -sin\u03C6,
      cos\u03C6,
      0,
      0
    )).add(new Point(
      (p1.x + p2.x) / 2,
      (p1.y + p2.y) / 2
    ));
    const anglePoint = new Point(
      (p1_.x - c_.x) / rx,
      (p1_.y - c_.y) / ry
    );
    const \u03B8 = new Point(1, 0).angleTo(anglePoint);
    let \u0394\u03B8 = anglePoint.angleTo(new Point(
      (-p1_.x - c_.x) / rx,
      (-p1_.y - c_.y) / ry
    ));
    \u0394\u03B8 = \u0394\u03B8 % (2 * Math.PI);
    if (!sweep && \u0394\u03B8 > 0)
      \u0394\u03B8 -= 2 * Math.PI;
    if (sweep && \u0394\u03B8 < 0)
      \u0394\u03B8 += 2 * Math.PI;
    this.c = c;
    this.theta = \u03B8 * 180 / Math.PI;
    this.theta2 = (\u03B8 + \u0394\u03B8) * 180 / Math.PI;
    this.delta = \u0394\u03B8 * 180 / Math.PI;
    this.rx = rx;
    this.ry = ry;
    this.phi = \u03C6;
    this.cos\u03C6 = cos\u03C6;
    this.sin\u03C6 = sin\u03C6;
  }
  static fromCenterForm(c, rx, ry, \u03C6, \u03B8, \u0394\u03B8) {
    const cos\u03C6 = Math.cos(\u03C6 / 180 * Math.PI);
    const sin\u03C6 = Math.sin(\u03C6 / 180 * Math.PI);
    const m = matrixFactory(cos\u03C6, sin\u03C6, -sin\u03C6, cos\u03C6, 0, 0);
    const p1 = new Point(
      rx * Math.cos(\u03B8 / 180 * Math.PI),
      ry * Math.sin(\u03B8 / 180 * Math.PI)
    ).transform(m).add(c);
    const p2 = new Point(
      rx * Math.cos((\u03B8 + \u0394\u03B8) / 180 * Math.PI),
      ry * Math.sin((\u03B8 + \u0394\u03B8) / 180 * Math.PI)
    ).transform(m).add(c);
    const arc = Math.abs(\u0394\u03B8) > 180 ? 1 : 0;
    const sweep = \u0394\u03B8 > 0 ? 1 : 0;
    return new _Arc(p1, p2, rx, ry, \u03C6, arc, sweep);
  }
  bbox() {
    const cloud = this.getCloud();
    return cloud.bbox();
  }
  clone() {
    return new _Arc(this.p1, this.p2, this.rx, this.ry, this.phi, this.arc, this.sweep);
  }
  getCloud() {
    if (this.p1.equals(this.p2))
      return new PointCloud([this.p1]);
    let \u03B801 = Math.atan(-this.sin\u03C6 / this.cos\u03C6 * this.ry / this.rx) * 180 / Math.PI;
    let \u03B802 = Math.atan(this.cos\u03C6 / this.sin\u03C6 * this.ry / this.rx) * 180 / Math.PI;
    let \u03B81 = this.theta;
    let \u03B82 = this.theta2;
    if (\u03B81 < 0 || \u03B82 < 0) {
      \u03B81 += 360;
      \u03B82 += 360;
    }
    if (\u03B82 < \u03B81) {
      const temp = \u03B81;
      \u03B81 = \u03B82;
      \u03B82 = temp;
    }
    while (\u03B801 - 90 > \u03B801)
      \u03B801 -= 90;
    while (\u03B801 < \u03B81)
      \u03B801 += 90;
    while (\u03B802 - 90 > \u03B802)
      \u03B802 -= 90;
    while (\u03B802 < \u03B81)
      \u03B802 += 90;
    const angleToTest = [\u03B801, \u03B802, \u03B801 + 90, \u03B802 + 90, \u03B801 + 180, \u03B802 + 180, \u03B801 + 270, \u03B802 + 270];
    const points = angleToTest.filter(function(angle2) {
      return angle2 > \u03B81 && angle2 < \u03B82;
    }).map(function(angle2) {
      while (this.theta < angle2)
        angle2 -= 360;
      return this.pointAt((angle2 - this.theta) % 360 / this.delta);
    }.bind(this)).concat(this.p1, this.p2);
    return new PointCloud(points);
  }
  length() {
    if (this.p1.equals(this.p2))
      return 0;
    const length3 = this.p2.sub(this.p1).abs();
    const ret = this.splitAt(0.5);
    const len1 = ret[0].p2.sub(ret[0].p1).abs();
    const len2 = ret[1].p2.sub(ret[1].p1).abs();
    if (len1 + len2 - length3 < 1e-5) {
      return len1 + len2;
    }
    return ret[0].length() + ret[1].length();
  }
  pointAt(t) {
    if (this.p1.equals(this.p2))
      return this.p1.clone();
    const tInAngle = (this.theta + t * this.delta) / 180 * Math.PI;
    const sin\u03B8 = Math.sin(tInAngle);
    const cos\u03B8 = Math.cos(tInAngle);
    return new Point(
      this.cos\u03C6 * this.rx * cos\u03B8 - this.sin\u03C6 * this.ry * sin\u03B8 + this.c.x,
      this.sin\u03C6 * this.ry * cos\u03B8 + this.cos\u03C6 * this.rx * sin\u03B8 + this.c.y
    );
  }
  splitAt(t) {
    const absDelta = Math.abs(this.delta);
    const delta1 = absDelta * t;
    const delta2 = absDelta * (1 - t);
    const pointAtT = this.pointAt(t);
    return [
      new _Arc(this.p1, pointAtT, this.rx, this.ry, this.phi, delta1 > 180, this.sweep),
      new _Arc(pointAtT, this.p2, this.rx, this.ry, this.phi, delta2 > 180, this.sweep)
    ];
  }
  toPath() {
    return ["M", this.p1.x, this.p1.y, "A", this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y].join(" ");
  }
  toPathFragment() {
    return ["A", this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y];
  }
  toString() {
    return `p1: ${this.p1.x.toFixed(4)} ${this.p1.y.toFixed(4)}, p2: ${this.p2.x.toFixed(4)} ${this.p2.y.toFixed(4)}, c: ${this.c.x.toFixed(4)} ${this.c.y.toFixed(4)} theta: ${this.theta.toFixed(4)}, theta2: ${this.theta2.toFixed(4)}, delta: ${this.delta.toFixed(4)}, large: ${this.arc}, sweep: ${this.sweep}`;
  }
  transform(matrix) {
    return new _Arc(this.p1.transform(matrix), this.p2.transform(matrix), this.rx, this.ry, this.phi, this.arc, this.sweep);
  }
};
var Cubic = class _Cubic {
  constructor(p1, c1, c2, p2) {
    if (p1 instanceof Point) {
      this.p1 = new Point(p1);
      this.c1 = new Point(c1);
      this.c2 = new Point(c2);
      this.p2 = new Point(p2);
    } else {
      this.p1 = new Point(p1.p1);
      this.c1 = new Point(p1.c1);
      this.c2 = new Point(p1.c2);
      this.p2 = new Point(p1.p2);
    }
  }
  static fromQuad(p1, c, p2) {
    const c1 = p1.mul(1 / 3).add(c.mul(2 / 3));
    const c2 = c.mul(2 / 3).add(p2.mul(1 / 3));
    return new _Cubic(p1, c1, c2, p2);
  }
  bbox() {
    return this.getCloud().bbox();
  }
  findRoots() {
    return this.findRootsX().concat(this.findRootsY());
  }
  findRootsX() {
    return this.findRootsXY(this.p1.x, this.c1.x, this.c2.x, this.p2.x);
  }
  findRootsXY(p1, p2, p3, p4) {
    const a = 3 * (-p1 + 3 * p2 - 3 * p3 + p4);
    const b10 = 6 * (p1 - 2 * p2 + p3);
    const c = 3 * (p2 - p1);
    if (a === 0)
      return [-c / b10].filter(function(el) {
        return el > 0 && el < 1;
      });
    if (b10 * b10 - 4 * a * c < 0)
      return [];
    if (b10 * b10 - 4 * a * c === 0)
      return [Math.round(-b10 / (2 * a) * 1e5) / 1e5].filter(function(el) {
        return el > 0 && el < 1;
      });
    return [
      Math.round((-b10 + Math.sqrt(b10 * b10 - 4 * a * c)) / (2 * a) * 1e5) / 1e5,
      Math.round((-b10 - Math.sqrt(b10 * b10 - 4 * a * c)) / (2 * a) * 1e5) / 1e5
    ].filter(function(el) {
      return el > 0 && el < 1;
    });
  }
  findRootsY() {
    return this.findRootsXY(this.p1.y, this.c1.y, this.c2.y, this.p2.y);
  }
  flatness() {
    let ux = Math.pow(3 * this.c1.x - 2 * this.p1.x - this.p2.x, 2);
    let uy = Math.pow(3 * this.c1.y - 2 * this.p1.y - this.p2.y, 2);
    const vx = Math.pow(3 * this.c2.x - 2 * this.p2.x - this.p1.x, 2);
    const vy = Math.pow(3 * this.c2.y - 2 * this.p2.y - this.p1.y, 2);
    if (ux < vx) {
      ux = vx;
    }
    if (uy < vy) {
      uy = vy;
    }
    return ux + uy;
  }
  getCloud() {
    const points = this.findRoots().filter((root3) => root3 !== 0 && root3 !== 1).map((root3) => this.pointAt(root3)).concat(this.p1, this.p2);
    return new PointCloud(points);
  }
  length() {
    return this.lengthAt();
  }
  lengthAt(t = 1) {
    const curves = this.splitAt(t)[0].makeFlat(t);
    let length3 = 0;
    for (let i2 = 0, len2 = curves.length; i2 < len2; ++i2) {
      length3 += curves[i2].p2.sub(curves[i2].p1).abs();
    }
    return length3;
  }
  makeFlat(t) {
    if (this.flatness() > 0.15) {
      return this.splitAt(0.5).map(function(el) {
        return el.makeFlat(t * 0.5);
      }).reduce(function(last4, current) {
        return last4.concat(current);
      }, []);
    } else {
      this.t_value = t;
      return [this];
    }
  }
  pointAt(t) {
    return new Point(
      (1 - t) * (1 - t) * (1 - t) * this.p1.x + 3 * (1 - t) * (1 - t) * t * this.c1.x + 3 * (1 - t) * t * t * this.c2.x + t * t * t * this.p2.x,
      (1 - t) * (1 - t) * (1 - t) * this.p1.y + 3 * (1 - t) * (1 - t) * t * this.c1.y + 3 * (1 - t) * t * t * this.c2.y + t * t * t * this.p2.y
    );
  }
  splitAt(z) {
    const x2 = this.splitAtScalar(z, "x");
    const y2 = this.splitAtScalar(z, "y");
    const a = new _Cubic(
      new Point(x2[0][0], y2[0][0]),
      new Point(x2[0][1], y2[0][1]),
      new Point(x2[0][2], y2[0][2]),
      new Point(x2[0][3], y2[0][3])
    );
    const b10 = new _Cubic(
      new Point(x2[1][0], y2[1][0]),
      new Point(x2[1][1], y2[1][1]),
      new Point(x2[1][2], y2[1][2]),
      new Point(x2[1][3], y2[1][3])
    );
    return [a, b10];
  }
  splitAtScalar(z, p) {
    const p1 = this.p1[p];
    const p2 = this.c1[p];
    const p3 = this.c2[p];
    const p4 = this.p2[p];
    const t = z * z * z * p4 - 3 * z * z * (z - 1) * p3 + 3 * z * (z - 1) * (z - 1) * p2 - (z - 1) * (z - 1) * (z - 1) * p1;
    return [
      [
        p1,
        z * p2 - (z - 1) * p1,
        z * z * p3 - 2 * z * (z - 1) * p2 + (z - 1) * (z - 1) * p1,
        t
      ],
      [
        t,
        z * z * p4 - 2 * z * (z - 1) * p3 + (z - 1) * (z - 1) * p2,
        z * p4 - (z - 1) * p3,
        p4
      ]
    ];
  }
  toPath() {
    return ["M", this.p1.x, this.p1.y].concat(this.toPathFragment()).join(" ");
  }
  toPathFragment() {
    return ["C", this.c1.x, this.c1.y, this.c2.x, this.c2.y, this.p2.x, this.p2.y];
  }
  transform(matrix) {
    this.p1.transformO(matrix);
    this.c1.transformO(matrix);
    this.c2.transformO(matrix);
    this.p2.transformO(matrix);
    return this;
  }
};
var Line2 = class {
  constructor(x1, y1, x2, y2) {
    if (x1 instanceof Object) {
      this.p1 = new Point(x1);
      this.p2 = new Point(y1);
    } else {
      this.p1 = new Point(x1, y1);
      this.p2 = new Point(x2, y2);
    }
  }
  bbox() {
    return this.getCloud().bbox();
  }
  getCloud() {
    return new PointCloud([this.p1, this.p2]);
  }
  length() {
    return this.p2.sub(this.p1).abs();
  }
  pointAt(t) {
    const vec = this.p2.sub(this.p1).mul(t);
    return this.p1.add(vec);
  }
  toPath() {
    return ["M", this.p1.x, this.p1.y, this.p2.x, this.p2.y].join(" ");
  }
  toPathFragment() {
    return ["L", this.p2.x, this.p2.y];
  }
  transform(matrix) {
    this.p1.transformO(matrix);
    this.p2.transformO(matrix);
    return this;
  }
};
var PathSegmentArray = class extends Array {
  bbox() {
    return this.reduce((l, c) => l.merge(c.bbox()), new NoBox());
  }
  cloud() {
    return this.reduce(
      (cloud, segment) => segment.getCloud().merge(cloud),
      new PointCloud()
    );
  }
  merge(other) {
    return this.concat(other);
  }
  transform(matrix) {
    return this.map((segment) => segment.transform(matrix));
  }
};
var getPathSegments = function(d) {
  return new PathSegmentArray(...pathParser(d));
};
var pointAtLength = function(d, len2) {
  const segs = pathParser(d);
  const segLengths = segs.map((el) => el.length());
  const length3 = segLengths.reduce((l, c) => l + c, 0);
  let i2 = 0;
  let t = len2 / length3;
  if (t >= 1) {
    if (segs[segs.length - 1].p2) {
      return segs[segs.length - 1].p2.native();
    } else {
      return segs[segs.length - 1].p1.native();
    }
  }
  if (t <= 0)
    return segs[0].p1.native();
  while (segs[segs.length - 1] instanceof Move)
    segs.pop();
  let segEnd = 0;
  for (const il = segLengths.length; i2 < il; ++i2) {
    const k = segLengths[i2] / length3;
    segEnd += k;
    if (segEnd > t) {
      break;
    }
  }
  const ratio = length3 / segLengths[i2];
  t = ratio * (t - segEnd) + 1;
  return segs[i2].pointAt(t).native();
};
var length2 = function(d) {
  return pathParser(d).reduce((l, c) => l + c.length(), 0);
};
var pathFrom = {
  box({ x: x2, y: y2, width: width2, height }) {
    return `M ${x2} ${y2} h ${width2} v ${height} H ${x2} V ${y2}`;
  },
  rect(node2) {
    const width2 = parseFloat(node2.getAttribute("width")) || 0;
    const height = parseFloat(node2.getAttribute("height")) || 0;
    const x2 = parseFloat(node2.getAttribute("x")) || 0;
    const y2 = parseFloat(node2.getAttribute("y")) || 0;
    return `M ${x2} ${y2} h ${width2} v ${height} H ${x2} V ${y2}`;
  },
  circle(node2) {
    const r = parseFloat(node2.getAttribute("r")) || 0;
    const x2 = parseFloat(node2.getAttribute("cx")) || 0;
    const y2 = parseFloat(node2.getAttribute("cy")) || 0;
    if (r === 0)
      return "M0 0";
    return `M ${x2 - r} ${y2} A ${r} ${r} 0 0 0 ${x2 + r} ${y2} A ${r} ${r} 0 0 0 ${x2 - r} ${y2}`;
  },
  ellipse(node2) {
    const rx = parseFloat(node2.getAttribute("rx")) || 0;
    const ry = parseFloat(node2.getAttribute("ry")) || 0;
    const x2 = parseFloat(node2.getAttribute("cx")) || 0;
    const y2 = parseFloat(node2.getAttribute("cy")) || 0;
    return `M ${x2 - rx} ${y2} A ${rx} ${ry} 0 0 0 ${x2 + rx} ${y2} A ${rx} ${ry} 0 0 0 ${x2 - rx} ${y2}`;
  },
  line(node2) {
    const x1 = parseFloat(node2.getAttribute("x1")) || 0;
    const x2 = parseFloat(node2.getAttribute("x2")) || 0;
    const y1 = parseFloat(node2.getAttribute("y1")) || 0;
    const y2 = parseFloat(node2.getAttribute("y2")) || 0;
    return `M ${x1} ${y1} L ${x2} ${y2}`;
  },
  polygon(node2) {
    return `M ${node2.getAttribute("points")} z`;
  },
  polyline(node2) {
    return `M ${node2.getAttribute("points")}`;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/textUtils.js
var import_node_path2 = __toESM(require_path_browserify(), 1);

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/DecodeStream.js
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length3, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length3);
    try {
      let decoder = new TextDecoder(encoding);
      return decoder.decode(buf);
    } catch (err) {
      return buf;
    }
  }
  readBuffer(length3) {
    return this.buffer.slice(this.pos, this.pos += length3);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    DecodeStream.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length3) {
    if (length3 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length3);
      this.pos += length3;
    } else {
      const buf = new Uint8Array(length3);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap) {
  let buf = new Uint16Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    let code = string.charCodeAt(i2);
    if (swap) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i2] = code;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    buf[i2] = string.charCodeAt(i2);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value) {
      this.view[key](this.pos, value, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type + "LE"] = function(value) {
        this.view[key](this.pos, value, true);
        this.pos += bytes;
      };
    }
  }
}

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Base.js
var Base2 = class {
  fromBuffer(buffer) {
    let stream = new DecodeStream(buffer);
    return this.decode(stream);
  }
  toBuffer(value) {
    let size4 = this.size(value);
    let buffer = new Uint8Array(size4);
    let stream = new EncodeStream(buffer);
    this.encode(stream, value);
    return buffer;
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Number.js
var NumberT = class extends Base2 {
  constructor(type, endian = "BE") {
    super();
    this.type = type;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream) {
    return stream[`read${this.fn}`]();
  }
  encode(stream, val) {
    return stream[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  constructor(size4, endian, fracBits = size4 >> 1) {
    super(`Int${size4}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream) {
    return super.decode(stream) / this._point;
  }
  encode(stream, val) {
    return super.encode(stream, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/utils.js
function resolveLength(length3, stream, parent) {
  let res;
  if (typeof length3 === "number") {
    res = length3;
  } else if (typeof length3 === "function") {
    res = length3.call(parent, parent);
  } else if (parent && typeof length3 === "string") {
    res = parent[length3];
  } else if (stream && length3 instanceof NumberT) {
    res = length3.decode(stream);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
var PropertyDescriptor = class {
  constructor(opts = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts) {
      const val = opts[key];
      this[key] = val;
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Array.js
var ArrayT = class extends Base2 {
  constructor(type, length3, lengthType = "count") {
    super();
    this.type = type;
    this.length = length3;
    this.lengthType = lengthType;
  }
  decode(stream, parent) {
    let length3;
    const { pos } = stream;
    const res = [];
    let ctx2 = parent;
    if (this.length != null) {
      length3 = resolveLength(this.length, stream, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length3 }
      });
      ctx2 = res;
    }
    if (length3 == null || this.lengthType === "bytes") {
      const target = length3 != null ? stream.pos + length3 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
      while (stream.pos < target) {
        res.push(this.type.decode(stream, ctx2));
      }
    } else {
      for (let i2 = 0, end = length3; i2 < end; i2++) {
        res.push(this.type.decode(stream, ctx2));
      }
    }
    return res;
  }
  size(array, ctx2, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx2) * resolveLength(this.length, null, ctx2);
    }
    let size4 = 0;
    if (this.length instanceof NumberT) {
      size4 += this.length.size();
      ctx2 = { parent: ctx2, pointerSize: 0 };
    }
    for (let item of array) {
      size4 += this.type.size(item, ctx2);
    }
    if (ctx2 && includePointers && this.length instanceof NumberT) {
      size4 += ctx2.pointerSize;
    }
    return size4;
  }
  encode(stream, array, parent) {
    let ctx2 = parent;
    if (this.length instanceof NumberT) {
      ctx2 = {
        pointers: [],
        startOffset: stream.pos,
        parent
      };
      ctx2.pointerOffset = stream.pos + this.size(array, ctx2, false);
      this.length.encode(stream, array.length);
    }
    for (let item of array) {
      this.type.encode(stream, item, ctx2);
    }
    if (this.length instanceof NumberT) {
      let i2 = 0;
      while (i2 < ctx2.pointers.length) {
        const ptr = ctx2.pointers[i2++];
        ptr.type.encode(stream, ptr.val, ptr.parent);
      }
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/LazyArray.js
var LazyArray = class extends ArrayT {
  decode(stream, parent) {
    const { pos } = stream;
    const length3 = resolveLength(this.length, stream, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length3
      };
    }
    const res = new LazyArrayValue(this.type, length3, stream, parent);
    stream.pos += length3 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx2) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx2);
  }
  encode(stream, val, ctx2) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream, val, ctx2);
  }
};
var LazyArrayValue = class {
  constructor(type, length3, stream, ctx2) {
    this.type = type;
    this.length = length3;
    this.stream = stream;
    this.ctx = ctx2;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.length) {
      return void 0;
    }
    if (this.items[index2] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index2;
      this.items[index2] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index2];
  }
  toArray() {
    const result = [];
    for (let i2 = 0, end = this.length; i2 < end; i2++) {
      result.push(this.get(i2));
    }
    return result;
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Bitfield.js
var Bitfield = class extends Base2 {
  constructor(type, flags = []) {
    super();
    this.type = type;
    this.flags = flags;
  }
  decode(stream) {
    const val = this.type.decode(stream);
    const res = {};
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        res[flag] = !!(val & 1 << i2);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream, keys3) {
    let val = 0;
    for (let i2 = 0; i2 < this.flags.length; i2++) {
      const flag = this.flags[i2];
      if (flag != null) {
        if (keys3[flag]) {
          val |= 1 << i2;
        }
      }
    }
    return this.type.encode(stream, val);
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Buffer.js
var BufferT = class extends Base2 {
  constructor(length3) {
    super();
    this.length = length3;
  }
  decode(stream, parent) {
    const length3 = resolveLength(this.length, stream, parent);
    return stream.readBuffer(length3);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len2 = val.length;
    if (this.length instanceof NumberT) {
      len2 += this.length.size();
    }
    return len2;
  }
  encode(stream, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream, buf.length);
    }
    return stream.writeBuffer(buf);
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Optional.js
var Optional = class extends Base2 {
  constructor(type, condition = true) {
    super();
    this.type = type;
    this.condition = condition;
  }
  decode(stream, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream, val, parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Reserved.js
var Reserved = class extends Base2 {
  constructor(type, count = 1) {
    super();
    this.type = type;
    this.count = count;
  }
  decode(stream, parent) {
    stream.pos += this.size(null, parent);
    return void 0;
  }
  size(data, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream, val, parent) {
    return stream.fill(0, this.size(val, parent));
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/String.js
var StringT = class extends Base2 {
  constructor(length3, encoding = "ascii") {
    super();
    this.length = length3;
    this.encoding = encoding;
  }
  decode(stream, parent) {
    let length3, pos;
    if (this.length != null) {
      length3 = resolveLength(this.length, stream, parent);
    } else {
      let buffer;
      ({ buffer, length: length3, pos } = stream);
      while (pos < length3 && buffer[pos] !== 0) {
        ++pos;
      }
      length3 = pos - stream.pos;
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    const string = stream.readString(length3, encoding);
    if (this.length == null && stream.pos < stream.length) {
      stream.pos++;
    }
    return string;
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size4 = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size4 += this.length.size();
    }
    if (this.length == null) {
      size4++;
    }
    return size4;
  }
  encode(stream, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream, byteLength(val, encoding));
    }
    stream.writeString(val, encoding);
    if (this.length == null) {
      return stream.writeUInt8(0);
    }
  }
};
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len2 = 0;
      for (let i2 = 0; i2 < string.length; i2++) {
        let c = string.charCodeAt(i2);
        if (c >= 55296 && c <= 56319 && i2 < string.length - 1) {
          let c2 = string.charCodeAt(++i2);
          if ((c2 & 64512) === 56320) {
            c = ((c & 1023) << 10) + (c2 & 1023) + 65536;
          } else {
            i2--;
          }
        }
        if ((c & 4294967168) === 0) {
          len2++;
        } else if ((c & 4294965248) === 0) {
          len2 += 2;
        } else if ((c & 4294901760) === 0) {
          len2 += 3;
        } else if ((c & 4292870144) === 0) {
          len2 += 4;
        }
      }
      return len2;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Struct.js
var Struct = class extends Base2 {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream, parent, length3 = 0) {
    const res = this._setup(stream, parent, length3);
    this._parseFields(stream, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream);
    }
    return res;
  }
  _setup(stream, parent, length3) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length3 }
    });
    return res;
  }
  _parseFields(stream, res, fields) {
    for (let key in fields) {
      var val;
      const type = fields[key];
      if (typeof type === "function") {
        val = type.call(res, res);
      } else {
        val = type.decode(stream, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx2 = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size4 = 0;
    for (let key in this.fields) {
      const type = this.fields[key];
      if (type.size != null) {
        size4 += type.size(val[key], ctx2);
      }
    }
    if (includePointers) {
      size4 += ctx2.pointerSize;
    }
    return size4;
  }
  encode(stream, val, parent) {
    let type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream);
    }
    const ctx2 = {
      pointers: [],
      startOffset: stream.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx2.pointerOffset = stream.pos + this.size(val, ctx2, false);
    for (let key in this.fields) {
      type = this.fields[key];
      if (type.encode != null) {
        type.encode(stream, val[key], ctx2);
      }
    }
    let i2 = 0;
    while (i2 < ctx2.pointers.length) {
      const ptr = ctx2.pointers[i2++];
      ptr.type.encode(stream, ptr.val, ptr.parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/VersionedStruct.js
var getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
var VersionedStruct = class _VersionedStruct extends Struct {
  constructor(type, versions = {}) {
    super();
    this.type = type;
    this.versions = versions;
    if (typeof type === "string") {
      this.versionPath = type.split(".");
    }
  }
  decode(stream, parent, length3 = 0) {
    const res = this._setup(stream, parent, length3);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream);
    }
    if (this.versions.header) {
      this._parseFields(stream, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream, parent);
    }
    this._parseFields(stream, res, fields);
    if (this.process != null) {
      this.process.call(res, stream);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx2 = {
      parent,
      val,
      pointerSize: 0
    };
    let size4 = 0;
    if (typeof this.type !== "string") {
      size4 += this.type.size(val.version, ctx2);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.size != null) {
          size4 += type.size(val[key], ctx2);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type = fields[key];
      if (type.size != null) {
        size4 += type.size(val[key], ctx2);
      }
    }
    if (includePointers) {
      size4 += ctx2.pointerSize;
    }
    return size4;
  }
  encode(stream, val, parent) {
    let key, type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream);
    }
    const ctx2 = {
      pointers: [],
      startOffset: stream.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx2.pointerOffset = stream.pos + this.size(val, ctx2, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.encode != null) {
          type.encode(stream, val[key], ctx2);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type = fields[key];
      if (type.encode != null) {
        type.encode(stream, val[key], ctx2);
      }
    }
    let i2 = 0;
    while (i2 < ctx2.pointers.length) {
      const ptr = ctx2.pointers[i2++];
      ptr.type.encode(stream, ptr.val, ptr.parent);
    }
  }
};

// ../../node_modules/.pnpm/restructure@3.0.0/node_modules/restructure/src/Pointer.js
var Pointer = class extends Base2 {
  constructor(offsetType, type, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream, ctx2) {
    const offset = this.offsetType.decode(stream, ctx2);
    if (offset === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx2._startOffset;
        break;
      case "immediate":
        relative = stream.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx2.parent._startOffset;
        break;
      default:
        var c = ctx2;
        while (c.parent) {
          c = c.parent;
        }
        relative = c._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx2);
    }
    const ptr = offset + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream;
        stream.pos = ptr;
        val = this.type.decode(stream, ctx2);
        stream.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx2) {
    const parent = ctx2;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx2 = ctx2.parent;
        break;
      default:
        while (ctx2.parent) {
          ctx2 = ctx2.parent;
        }
    }
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    if (val && ctx2) {
      let size4 = type.size(val, parent);
      ctx2.pointerSize += size4;
    }
    return this.offsetType.size();
  }
  encode(stream, val, ctx2) {
    let relative;
    const parent = ctx2;
    if (val == null) {
      this.offsetType.encode(stream, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx2.startOffset;
        break;
      case "immediate":
        relative = stream.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx2 = ctx2.parent;
        relative = ctx2.startOffset;
        break;
      default:
        relative = 0;
        while (ctx2.parent) {
          ctx2 = ctx2.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream, ctx2.pointerOffset - relative);
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    ctx2.pointers.push({
      type,
      val,
      parent
    });
    return ctx2.pointerOffset += type.size(val, parent);
  }
};
var VoidPointer = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
};

// ../../node_modules/.pnpm/@swc+helpers@0.4.36/node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else
    obj[key] = value;
  return obj;
}

// ../../node_modules/.pnpm/tslib@2.6.2/node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../../node_modules/.pnpm/fontkit@2.0.2/node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// ../../node_modules/.pnpm/unicode-properties@1.4.1/node_modules/unicode-properties/dist/module.mjs
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("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"));
var $747425b437e121da$var$log2 = Math.log2 || ((n2) => Math.log(n2) / Math.LN2);
var $747425b437e121da$var$bits = (n2) => $747425b437e121da$var$log2(n2) + 1 | 0;
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, /* @__PURE__ */ $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}

// ../../node_modules/.pnpm/fontkit@2.0.2/node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone2 = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e, n2, v, s) {
  Object.defineProperty(e, n2, { get: v, set: s, enumerable: true, configurable: true });
}
function $parcel$interopDefault2(a) {
  return a && a.__esModule ? a.default : a;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format) {
  $d636bc798e7178db$var$formats.push(format);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i2 = 0; i2 < $d636bc798e7178db$var$formats.length; i2++) {
    let format = $d636bc798e7178db$var$formats[i2];
    if (format.probe(buffer)) {
      let font = new format(new (0, DecodeStream)(buffer));
      if (postscriptName)
        return font.getFont(postscriptName);
      return font;
    }
  }
  throw new Error("Unknown font format");
}
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key1, descriptor) {
  if (descriptor.get) {
    let get3 = descriptor.get;
    descriptor.get = function() {
      let value = get3.call(this);
      Object.defineProperty(this, key1, {
        value
      });
      return value;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache1 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key = args.length > 0 ? args[0] : "value";
          if (cache1.has(key))
            return cache1.get(key);
          let result = fn.apply(this, args);
          cache1.set(key, result);
          return result;
        }
        Object.defineProperty(this, key1, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t) => Math.max.apply(Math, t.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t) => t.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t) => (t.length - t._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t) => t.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t) => t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID])
    return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026 \xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7",
  "x-mac-gaelic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83",
  "x-mac-greek": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026 \u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
  "x-mac-icelandic": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-inuit": "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026 \u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142",
  "x-mac-ce": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026 \u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7",
  "x-mac-romanian": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7",
  "x-mac-turkish": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026 \xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached)
    return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mapping.length; i2++)
      res.set(mapping.charCodeAt(i2), 128 + i2);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i2 = 0; i2 < 128; i2++)
      mapping2[i2] = 128 + i2;
    let res = /* @__PURE__ */ new Map();
    let s = decoder.decode(mapping2);
    for (let i1 = 0; i1 < 128; i1++)
      res.set(s.charCodeAt(i1), 128 + i1);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "hz-gb-2312",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf16be",
    "shift-jis",
    "gb18030",
    "big5",
    "x-cp20949",
    "johab",
    null,
    null,
    null,
    "utf16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t.platformID, t.encodingID, t.languageID)), {
    type: "parent",
    relativeTo: (ctx2) => ctx2.parent.stringOffset,
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx2) => ctx2.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768)
      language = this.langTags[record.languageID - 32768].tag;
    if (language == null)
      language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null)
      records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256)
      obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string")
      obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records))
    return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures")
      continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName")
      records.push({
        platformID: 1,
        encodingID: 0,
        languageID: 0,
        nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
        length: val.en.length,
        string: val.en
      });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t) => t.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i2 = 0; i2 < this.offsets.length; i2++)
      this.offsets[i2] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i2 = 0; i2 < this.offsets.length; i2++)
      this.offsets[i2] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  getCFFVersion(ctx2) {
    while (ctx2 && !ctx2.hdrSize)
      ctx2 = ctx2.parent;
    return ctx2 ? ctx2.version : -1;
  }
  decode(stream, parent) {
    let version = this.getCFFVersion(parent);
    let count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();
    if (count === 0)
      return [];
    let offSize = stream.readUInt8();
    let offsetType;
    if (offSize === 1)
      offsetType = uint8;
    else if (offSize === 2)
      offsetType = uint16;
    else if (offSize === 3)
      offsetType = uint24;
    else if (offSize === 4)
      offsetType = uint32;
    else
      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream.pos}`);
    let ret = [];
    let startPos = stream.pos + (count + 1) * offSize - 1;
    let start = offsetType.decode(stream);
    for (let i2 = 0; i2 < count; i2++) {
      let end = offsetType.decode(stream);
      if (this.type != null) {
        let pos = stream.pos;
        stream.pos = startPos + start;
        parent.length = end - start;
        ret.push(this.type.decode(stream, parent));
        stream.pos = pos;
      } else
        ret.push({
          offset: startPos + start,
          length: end - start
        });
      start = end;
    }
    stream.pos = startPos + start;
    return ret;
  }
  size(arr2, parent) {
    let size4 = 2;
    if (arr2.length === 0)
      return size4;
    let type = this.type || new BufferT();
    let offset = 1;
    for (let i2 = 0; i2 < arr2.length; i2++) {
      let item = arr2[i2];
      offset += type.size(item, parent);
    }
    let offsetType;
    if (offset <= 255)
      offsetType = uint8;
    else if (offset <= 65535)
      offsetType = uint16;
    else if (offset <= 16777215)
      offsetType = uint24;
    else if (offset <= 4294967295)
      offsetType = uint32;
    else
      throw new Error("Bad offset in CFFIndex");
    size4 += 1 + offsetType.size() * (arr2.length + 1);
    size4 += offset - 1;
    return size4;
  }
  encode(stream, arr2, parent) {
    stream.writeUInt16BE(arr2.length);
    if (arr2.length === 0)
      return;
    let type = this.type || new BufferT();
    let sizes = [];
    let offset = 1;
    for (let item of arr2) {
      let s = type.size(item, parent);
      sizes.push(s);
      offset += s;
    }
    let offsetType;
    if (offset <= 255)
      offsetType = uint8;
    else if (offset <= 65535)
      offsetType = uint16;
    else if (offset <= 16777215)
      offsetType = uint24;
    else if (offset <= 4294967295)
      offsetType = uint32;
    else
      throw new Error("Bad offset in CFFIndex");
    stream.writeUInt8(offsetType.size());
    offset = 1;
    offsetType.encode(stream, offset);
    for (let size4 of sizes) {
      offset += size4;
      offsetType.encode(stream, offset);
    }
    for (let item1 of arr2)
      type.encode(stream, item1, parent);
    return;
  }
  constructor(type) {
    this.type = type;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static decode(stream, value) {
    if (32 <= value && value <= 246)
      return value - 139;
    if (247 <= value && value <= 250)
      return (value - 247) * 256 + stream.readUInt8() + 108;
    if (251 <= value && value <= 254)
      return -(value - 251) * 256 - stream.readUInt8() - 108;
    if (value === 28)
      return stream.readInt16BE();
    if (value === 29)
      return stream.readInt32BE();
    if (value === 30) {
      let str3 = "";
      while (true) {
        let b10 = stream.readUInt8();
        let n1 = b10 >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF)
          break;
        str3 += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n2 = b10 & 15;
        if (n2 === $c2d28e92708f99da$var$FLOAT_EOF)
          break;
        str3 += $c2d28e92708f99da$var$FLOAT_LOOKUP[n2];
      }
      return parseFloat(str3);
    }
    return null;
  }
  static size(value) {
    if (value.forceLarge)
      value = 32768;
    if ((value | 0) !== value) {
      let str3 = "" + value;
      return 1 + Math.ceil((str3.length + 1) / 2);
    } else if (-107 <= value && value <= 107)
      return 1;
    else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108)
      return 2;
    else if (-32768 <= value && value <= 32767)
      return 3;
    else
      return 5;
  }
  static encode(stream, value) {
    let val = Number(value);
    if (value.forceLarge) {
      stream.writeUInt8(29);
      return stream.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream.writeUInt8(30);
      let str3 = "" + val;
      for (let i2 = 0; i2 < str3.length; i2 += 2) {
        let c1 = str3[i2];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i2 === str3.length - 1)
          var n2 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c2 = str3[i2 + 1];
          var n2 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream.writeUInt8(n1 << 4 | n2 & 15);
      }
      if (n2 !== $c2d28e92708f99da$var$FLOAT_EOF)
        return stream.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107)
      return stream.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream.writeUInt8((val >> 8) + 247);
      return stream.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream.writeUInt8((val >> 8) + 251);
      return stream.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream.writeUInt8(28);
      return stream.writeInt16BE(val);
    } else {
      stream.writeUInt8(29);
      return stream.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  decodeOperands(type, stream, ret, operands) {
    if (Array.isArray(type))
      return operands.map((op, i2) => this.decodeOperands(type[i2], stream, ret, [
        op
      ]));
    else if (type.decode != null)
      return type.decode(stream, ret, operands);
    else
      switch (type) {
        case "number":
        case "offset":
        case "sid":
          return operands[0];
        case "boolean":
          return !!operands[0];
        default:
          return operands;
      }
  }
  encodeOperands(type, stream, ctx2, operands) {
    if (Array.isArray(type))
      return operands.map((op, i2) => this.encodeOperands(type[i2], stream, ctx2, op)[0]);
    else if (type.encode != null)
      return type.encode(stream, operands, ctx2);
    else if (typeof operands === "number")
      return [
        operands
      ];
    else if (typeof operands === "boolean")
      return [
        +operands
      ];
    else if (Array.isArray(operands))
      return operands;
    else
      return [
        operands
      ];
  }
  decode(stream, parent) {
    let end = stream.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream.pos < end) {
      let b10 = stream.readUInt8();
      if (b10 < 28) {
        if (b10 === 12)
          b10 = b10 << 8 | stream.readUInt8();
        let field = this.fields[b10];
        if (!field)
          throw new Error(`Unknown operator ${b10}`);
        let val = this.decodeOperands(field[2], stream, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor))
            Object.defineProperty(ret, field[1], val);
          else
            ret[field[1]] = val;
        }
        operands = [];
      } else
        operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream, b10));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx2 = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len2 = 0;
    for (let k in this.fields) {
      let field = this.fields[k];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
        continue;
      let operands = this.encodeOperands(field[2], null, ctx2, val);
      for (let op of operands)
        len2 += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len2 += key.length;
    }
    if (includePointers)
      len2 += ctx2.pointerSize;
    return len2;
  }
  encode(stream, dict, parent) {
    let ctx2 = {
      pointers: [],
      startOffset: stream.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx2.pointerOffset = stream.pos + this.size(dict, ctx2, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
        continue;
      let operands = this.encodeOperands(field[2], stream, ctx2, val);
      for (let op of operands)
        (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op1 of key)
        stream.writeUInt8(op1);
    }
    let i2 = 0;
    while (i2 < ctx2.pointers.length) {
      let ptr = ctx2.pointers[i2++];
      ptr.type.encode(stream, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  decode(stream, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream, parent, operands);
  }
  encode(stream, value, ctx2) {
    if (!stream) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value, ctx2);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream2, val) => ptr = val
    };
    super.encode(stream, value, ctx2);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type, options = {}) {
    if (options.type == null)
      options.type = "global";
    super(null, type, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static decode(stream, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends)
      operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t) => t.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t) => t.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t) => t.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t) => t.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t) => t.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t) => t.parent.regionIndexCount - t.parent.shortDeltaCount),
  deltas: (t) => t.shortDeltas.concat(t.regionDeltas)
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  decode(stream, parent, operands) {
    if (this.predefinedOps[operands[0]])
      return this.predefinedOps[operands[0]];
    return this.type.decode(stream, parent, operands);
  }
  size(value, ctx2) {
    return this.type.size(value, ctx2);
  }
  encode(stream, value, ctx2) {
    let index2 = this.predefinedOps.indexOf(value);
    if (index2 !== -1)
      return index2;
    return this.type.encode(stream, value, ctx2);
  }
  constructor(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  decode(stream) {
    return uint8.decode(stream) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  decode(stream, parent) {
    let length3 = (0, resolveLength)(this.length, stream, parent);
    let count = 0;
    let res = [];
    while (count < length3) {
      let range2 = this.type.decode(stream, parent);
      range2.offset = count;
      count += range2.nLeft + 1;
      res.push(range2);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t) => t.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t) => t.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t) => t.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t) => t.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  decode(stream, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx2) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx2, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx2)[0]
    ];
  }
  encode(stream, dict, ctx2) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx2, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream, dict, ctx2)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static decode(stream) {
    return new _$822ac0d589e4e237$var$CFFFont(stream);
  }
  decode() {
    let start = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1)
        throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2)
      return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length)
      return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2)
      return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2)
      return null;
    if (this.isCIDFont)
      return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset))
      return charset[gid];
    if (gid === 0)
      return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i2 = 0; i2 < charset.ranges.length; i2++) {
          let range2 = charset.ranges[i2];
          if (range2.offset <= gid && gid <= range2.offset + range2.nLeft)
            return this.string(range2.first + (gid - range2.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect)
      return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first)
            high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first)
            low = mid + 1;
          else
            return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd])
        return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2)
      return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream) {
    this.stream = stream;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
};
var $0941618dc22a946d$var$BitAligned = class {
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t) => t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t) => t.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t) => t.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx2) => ctx2.rel
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx2) => ctx2.rel
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx2) => ctx2.rel
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx2) => ctx2.rel
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent)
      struct = struct.parent;
    if (!struct[this.key])
      return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format = struct[this.key];
    for (let key in format)
      if (format[key])
        fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx2) {
    return this.buildStruct(ctx2).size(val, ctx2);
  }
  decode(stream, parent) {
    let res = this.buildStruct(parent).decode(stream, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t) => t.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t) => t.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t) => t.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  decode(stream, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream.readUInt8();
      case 2:
        return stream.readUInt16BE();
      case 3:
        return stream.readUInt24BE();
      case 4:
        return stream.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size4) {
    this._size = size4;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t) => ((t.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t) => t.entry >> (t.parent.entryFormat & 15) + 1,
  innerIndex: (t) => t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t) => t.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t) => t.offsets.length && Math.max.apply(Math, t.offsets)
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t) => t._startOffset - t.parent.parent._startOffset,
  len: (t) => ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t) => t.leftClassCount * t.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t) => t.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t) => t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  getItem(index2) {
    if (this._items[index2] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index2;
      this._items[index2] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index2];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type, stream, parent) {
    this.type = type;
    this.stream = stream;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  decode(stream, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream, parent);
  }
  constructor(type) {
    super(type, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow2 {
    decode(stream, ctx2) {
      ctx2 = ctx2.parent.parent;
      return this.type.decode(stream, ctx2);
    }
    size(val, ctx2) {
      ctx2 = ctx2.parent.parent;
      return this.type.size(val, ctx2);
    }
    encode(stream, val, ctx2) {
      ctx2 = ctx2.parent.parent;
      return this.type.encode(stream, val, ctx2);
    }
    constructor(type) {
      this.type = type;
    }
  }
  ValueType = new Shadow2(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t) => t.lastGlyph - t.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t) => t.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t) => t.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t) => t.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t) => t.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t) => (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t) => t.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t) => t.parent.parent.parent.name.records.fontFeatures[t.nameIndex]
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t) => t.parent.parent.name.records.fontFeatures[t.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID]
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t) => t.parent.parent.name.records.fontFeatures[t.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t) => t.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t) => t.parent.instanceSize - t._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static decode(stream, parent) {
    return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx2) => ctx2.offsetToData,
    allowNull: false
  }), (t) => t.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t) => t.actionLength - t._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx2) => ctx2.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t) => t.length - t._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables)
    tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag2 in this.tables) {
      let table = this.tables[tag2];
      if (table)
        tables.push({
          tag: tag2,
          checkSum: 0,
          offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag2], table),
          length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag2].size(table)
        });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr2, cmp) {
  let min4 = 0;
  let max4 = arr2.length - 1;
  while (min4 <= max4) {
    let mid = min4 + max4 >> 1;
    let res = cmp(arr2[mid]);
    if (res < 0)
      max4 = mid - 1;
    else if (res > 0)
      min4 = mid + 1;
    else
      return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index2, end) {
  let range1 = [];
  while (index2 < end)
    range1.push(index2++);
  return range1;
}
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i2 = 0; i2 < $12727730ddfc8bfe$var$CHARS.length; i2++)
  $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i2)] = i2;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=")
      bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p = 0;
  for (let i1 = 0, len2 = base64.length; i1 < len2; i1 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  findSubtable(cmapTable, pairs) {
    for (let [platformID, encodingID] of pairs)
      for (let cmap of cmapTable.tables) {
        if (cmap.platformID === platformID && cmap.encodingID === encodingID)
          return cmap.table;
      }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding)
      codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid)
        return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min4 = 0;
        let max4 = cmap.segCount - 1;
        while (min4 <= max4) {
          let mid = min4 + max4 >> 1;
          if (codepoint < cmap.startCode.get(mid))
            max4 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid))
            min4 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0)
              gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index2 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index2) || 0;
              if (gid !== 0)
                gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min4 = 0;
        let max4 = cmap.nGroups - 1;
        while (min4 <= max4) {
          let mid = min4 + max4 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode)
            max4 = mid - 1;
          else if (codepoint > group.endCharCode)
            min4 = mid + 1;
          else {
            if (cmap.version === 12)
              return group.glyphID + (codepoint - group.startCharCode);
            else
              return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs)
      return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x2) => variationSelector - x2.varSelector);
    let sel = selectors[i2];
    if (i2 !== -1 && sel.defaultUVS)
      i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x2) => codepoint < x2.startUnicodeValue ? -1 : codepoint > x2.startUnicodeValue + x2.additionalCount ? 1 : 0);
    if (i2 !== -1 && sel.nonDefaultUVS) {
      i2 = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x2) => codepoint - x2.unicodeValue);
      if (i2 !== -1)
        return sel.nonDefaultUVS[i2].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i2 = 0; i2 < endCodes.length; i2++) {
          let tail = endCodes[i2] + 1;
          let start = cmap.startCode.get(i2);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray())
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i2 = 0; i2 < 256; i2++)
          if (cmap.codeMap.get(i2) === gid)
            res.push(i2);
        return res;
      }
      case 4: {
        let res = [];
        for (let i2 = 0; i2 < cmap.segCount; i2++) {
          let end = cmap.endCode.get(i2);
          let start = cmap.startCode.get(i2);
          let rangeOffset = cmap.idRangeOffset.get(i2);
          let delta = cmap.idDelta.get(i2);
          for (var c = start; c <= end; c++) {
            let g = 0;
            if (rangeOffset === 0)
              g = c + delta;
            else {
              let index2 = rangeOffset / 2 + (c - start) - (cmap.segCount - i2);
              g = cmap.glyphIndexArray.get(index2) || 0;
              if (g !== 0)
                g += delta;
            }
            if (g === gid)
              res.push(c);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray())
          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode))
            res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray())
          if (gid === group.glyphID)
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap)
      for (let cmap of cmapTable.tables) {
        let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
        let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
        if (mapping) {
          this.cmap = cmap.table;
          this.encoding = mapping;
        }
      }
    if (!this.cmap)
      throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14)
      this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream)
        continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal)
            continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation)
            continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0)
            val = s.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs)
            leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
          else
            leftOffset = s.array.off;
          if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs)
            rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
          let index2 = (leftOffset + rightOffset - s.array.off) / 2;
          val = s.array.values.get(index2);
          break;
        case 3:
          if (left >= s.glyphCount || right >= s.glyphCount)
            return 0;
          val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override)
        res = val;
      else
        res += val;
    }
    return res;
  }
  constructor(font) {
    this.kern = font.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.isMark)
        clusterEnd = index2;
      else {
        if (clusterStart !== clusterEnd)
          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index2;
      }
    }
    if (clusterStart !== clusterEnd)
      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index2 = clusterStart + 1; index2 <= clusterEnd; index2++) {
      let mark = glyphs[index2];
      let markBox = mark.cbox;
      let position2 = positions[index2];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position2.xOffset = position2.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position2.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position2.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position2.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position2.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below")
              baseBox.minY += yGap;
            position2.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right")
              baseBox.maxY += yGap;
            position2.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position2.xAdvance = position2.yAdvance = 0;
        position2.xOffset += xOffset;
        position2.yOffset += yOffset;
      } else {
        xOffset -= position2.xAdvance;
        yOffset -= position2.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered")
        switch (codePoint) {
          case 3633:
          case 3636:
          case 3637:
          case 3638:
          case 3639:
          case 3655:
          case 3660:
          case 3645:
          case 3662:
            return "Above_Right";
          case 3761:
          case 3764:
          case 3765:
          case 3766:
          case 3767:
          case 3771:
          case 3788:
          case 3789:
            return "Above";
          case 3772:
            return "Below";
        }
      else if (codePoint === 3642)
        return "Below_Right";
    }
    switch (combiningClass) {
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font) {
    this.font = font;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x2, y2) {
    if (Math.abs(x2) !== Infinity) {
      if (x2 < this.minX)
        this.minX = x2;
      if (x2 > this.maxX)
        this.maxX = x2;
    }
    if (Math.abs(y2) !== Infinity) {
      if (y2 < this.minY)
        this.minY = y2;
      if (y2 > this.maxY)
        this.maxY = y2;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag2 = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag2))
    for (let t of tag2)
      $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t] = script;
  else
    $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag2] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag2) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag2];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len2 = string.length;
  let idx = 0;
  while (idx < len2) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len2) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script2 = (0, $747425b437e121da$export$941569448d136665)(code);
    if (script2 !== "Common" && script2 !== "Inherited" && script2 !== "Unknown")
      return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script2];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i2 = 0; i2 < codePoints.length; i2++) {
    let codePoint = codePoints[i2];
    let script3 = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script3 !== "Common" && script3 !== "Inherited" && script3 !== "Unknown")
      return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script3];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script4) {
  if ($130d1a642ebcd2b7$var$RTL[script4])
    return "rtl";
  return "ltr";
}
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width2 = 0;
    for (let position2 of this.positions)
      width2 += position2.xAdvance;
    return width2;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height = 0;
    for (let position2 of this.positions)
      height += position2.yAdvance;
    return height;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x2 = 0;
    let y2 = 0;
    for (let index2 = 0; index2 < this.glyphs.length; index2++) {
      let glyph = this.glyphs[index2];
      let p = this.positions[index2];
      let b10 = glyph.bbox;
      bbox.addPoint(b10.minX + x2 + p.xOffset, b10.minY + y2 + p.yOffset);
      bbox.addPoint(b10.maxX + x2 + p.xOffset, b10.maxY + y2 + p.yOffset);
      x2 += p.xAdvance;
      y2 += p.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction3) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction3 || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features))
      for (let tag2 of features)
        this.features[tag2] = true;
    else if (typeof features === "object")
      this.features = features;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = (name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
];
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i2 = 1; i2 <= 99; i2++)
  $3b6302b64eccc32c$var$OTMapping[`cv${`00${i2}`.slice(-2)}`] = [
    $3b6302b64eccc32c$var$features.characterAlternatives.code,
    i2
  ];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null)
    $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features1) {
  let res = {};
  for (let k in features1) {
    let r;
    if (r = $3b6302b64eccc32c$var$OTMapping[k]) {
      if (res[r[0]] == null)
        res[r[0]] = {};
      res[r[0]][r[1]] = features1[k];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f) {
  let [type, setting] = f;
  if (isNaN(type))
    var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
  else
    var typeCode = type;
  if (isNaN(setting))
    var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
  else
    var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features2) {
  let res = {};
  if (Array.isArray(features2))
    for (let k = 0; k < features2.length; k++) {
      let r;
      let f = $3b6302b64eccc32c$var$mapFeatureStrings(features2[k]);
      if (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]])
        res[r] = true;
    }
  else if (typeof features2 === "object")
    for (let type in features2) {
      let feature1 = features2[type];
      for (let setting in feature1) {
        let r;
        let f = $3b6302b64eccc32c$var$mapFeatureStrings([
          type,
          setting
        ]);
        if (feature1[setting] && (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]]))
          res[r] = true;
      }
    }
  return Object.keys(res);
}
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min4 = 0;
        let max4 = this.table.binarySearchHeader.nUnits - 1;
        while (min4 <= max4) {
          var mid = min4 + max4 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535)
            return null;
          if (glyph < seg.firstGlyph)
            max4 = mid - 1;
          else if (glyph > seg.lastGlyph)
            min4 = mid + 1;
          else {
            if (this.table.version === 2)
              return seg.value;
            else
              return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min4 = 0;
        let max4 = this.table.binarySearchHeader.nUnits - 1;
        while (min4 <= max4) {
          var mid = min4 + max4 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535)
            return null;
          if (glyph < seg.glyph)
            max4 = mid - 1;
          else if (glyph > seg.glyph)
            min4 = mid + 1;
          else
            return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments)
          if (this.table.version === 2 && segment.value === classValue)
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
          else {
            for (let index2 = 0; index2 < segment.values.length; index2++)
              if (segment.values[index2] === classValue)
                res.push(segment.firstGlyph + index2);
          }
        break;
      case 6:
        for (let segment1 of this.table.segments)
          if (segment1.value === classValue)
            res.push(segment1.glyph);
        break;
      case 8:
        for (let i2 = 0; i2 < this.table.values.length; i2++)
          if (this.table.values[i2] === classValue)
            res.push(this.table.firstGlyph + i2);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  process(glyphs, reverse, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index2 = reverse ? glyphs.length - 1 : 0;
    let dir = reverse ? -1 : 1;
    while (dir === 1 && index2 <= glyphs.length || dir === -1 && index2 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index2 === glyphs.length || index2 === -1)
        classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index2];
        if (glyph.id === 65535)
          classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null)
            classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index2);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance)
        index2 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts, state = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state))
      return;
    visited.add(state);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts.enter)
          opts.enter(glyph, entry);
        if (entry.newState !== 0)
          this.traverse(opts, entry.newState, visited);
        if (opts.exit)
          opts.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f;
        if (f = features[feature.featureType]) {
          if (f[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables)
        if (subtable.subFeatureFlags & flags)
          this.processSubtable(subtable, glyphs);
    }
    let index2 = glyphs.length - 1;
    while (index2 >= 0) {
      if (glyphs[index2].id === 65535)
        glyphs.splice(index2, 1);
      index2--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let reverse = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse, process2);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST)
      this.firstGlyph = index2;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST)
      this.lastGlyph = index2;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index2) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid)
        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup);
      glyph = this.glyphs[index2];
      var gid = lookupTable.lookup(glyph.id);
      if (gid)
        this.glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK)
      this.markedGlyph = index2;
  }
  processLigature(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT)
      this.ligatureStack.push(index2);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components2 = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last4 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last4) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last4 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset += this.glyphs[componentGlyph].id;
        let component = components2.getItem(offset);
        ligatureIndex += component;
        if (last4 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else
          this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index2) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid)
          glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore)
      glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK)
      this.markedIndex = index2;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index2, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains)
      for (let feature of chain.features)
        features.push([
          feature.featureType,
          feature.featureSetting
        ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache)
      this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables)
        if (subtable.subFeatureFlags & flags)
          this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2)
      return;
    let reverse = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse)
      throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g1 = this.font.getGlyph(glyph);
        input.push(g1);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i2 = 0; i2 < glyphs.length && count <= 1; i2++)
          if (glyphs[i2].id !== 65535) {
            count++;
            found = glyphs[i2].id;
          }
        if (count === 1) {
          let result = input.map((g) => g.id);
          let cache1 = this.inputCache[found];
          if (cache1)
            cache1.push(result);
          else
            this.inputCache[found] = [
              result
            ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font;
    this.morx = font.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB)
    end.reverse();
  let start = glyphs.splice(rangeA[0], rangeA[1], ...end);
  if (reverseA)
    start.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length3 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl")
      glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings)
      this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index2, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index2]);
    for (let codePoint of codePoints) {
      let s = string + String.fromCodePoint(codePoint);
      if (index2 < glyphs.length - 1)
        this._addStrings(glyphs, index2 + 1, strings, s);
      else
        strings.add(s);
    }
  }
  constructor(font) {
    this.font = font;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features)
      if (this.allFeatures[feature] == null) {
        stage.push(feature);
        this.allFeatures[feature] = stageIndex;
        if (global2)
          this.globalFeatures[feature] = true;
      }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0)
      this.stages.push([]);
    if (typeof arg === "string")
      arg = [
        arg
      ];
    if (Array.isArray(arg))
      this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else
      throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function")
      this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features))
      this.add(features);
    else if (typeof features === "object")
      for (let tag2 in features) {
        if (features[tag2])
          this.add(tag2);
        else if (this.allFeatures[tag2] != null) {
          let stage = this.stages[this.allFeatures[tag2]];
          stage.splice(stage.indexOf(tag2), 1);
          delete this.allFeatures[tag2];
          delete this.globalFeatures[tag2];
        }
      }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs)
      for (let feature in this.globalFeatures)
        glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions)
          stage(this.font, glyphs, this);
      } else if (stage.length > 0)
        processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font, script, direction3) {
    this.font = font;
    this.script = script;
    this.direction = direction3;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let glyph = glyphs[i2];
      if (glyph.codePoints[0] === 8260) {
        let start = i2;
        let end = i2 + 1;
        while (start > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start - 1].codePoints[0])) {
          glyphs[start - 1].features.numr = true;
          glyphs[start - 1].features.frac = true;
          start--;
        }
        while (end < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end].codePoints[0])) {
          glyphs[end].features.dnom = true;
          glyphs[end].features.frac = true;
          end++;
        }
        glyph.features.frac = true;
        i2 = end - 1;
      }
    }
  }
};
(0, _define_property)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("ABABAAAAAACgMQAAAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i2 = 0; i2 < $764eb544bbe1ccf0$var$FEATURES.length; i2++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i2];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state = 0;
    let actions = [];
    for (let i2 = 0; i2 < glyphs.length; i2++) {
      let curAction, prevAction;
      var glyph = glyphs[i2];
      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i2] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state] = $764eb544bbe1ccf0$var$STATE_TABLE[state][type];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1)
        actions[prev] = prevAction;
      actions[i2] = curAction;
      prev = i2;
    }
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let feature;
      var glyph = glyphs[index2];
      if (feature = actions[index2])
        glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res)
    return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf")
    return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  reset(options = {}, index2 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index2;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index]))
      this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length)
      return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--)
      this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  findScript(script) {
    if (this.table.scriptList == null)
      return null;
    if (!Array.isArray(script))
      script = [
        script
      ];
    for (let s of script)
      for (let entry of this.table.scriptList) {
        if (entry.tag === s)
          return entry;
      }
    return null;
  }
  selectScript(script, language, direction3) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry)
        entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry)
        return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction3 || direction3 !== this.direction)
      this.direction = direction3 || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4)
      language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords)
        if (lang.tag === language) {
          this.language = lang.langSys;
          this.languageTag = lang.tag;
          break;
        }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language)
        for (let featureIndex of this.language.featureIndexes) {
          let record = this.table.featureList[featureIndex];
          let substituteFeature = this.substituteFeatureForVariations(featureIndex);
          this.features[record.tag] = substituteFeature || record.feature;
        }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag2 of userFeatures) {
      let feature = this.features[tag2];
      if (!feature)
        continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1)
          continue;
        lookups.push({
          feature: tag2,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a, b10) => a.index - b10.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1)
      return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex)
        return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations)
      return -1;
    let records = variations.featureVariationRecords;
    for (let i2 = 0; i2 < records.length; i2++) {
      let conditions = records[i2].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords))
        return i2;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup.subTables) {
          let res = this.applyLookup(lookup.lookupType, table);
          if (res)
            break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);
      for (let table of lookup.subTables) {
        if (this.applyLookup(lookup.lookupType, table))
          break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null)
      glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range2 of coverage.rangeRecords) {
          if (range2.start <= glyph && glyph <= range2.end)
            return range2.startCoverageIndex + glyph - range2.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched)
        matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length)
      return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features))
        return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i2 = glyph - classDef.startGlyph;
        if (i2 >= 0 && i2 < classDef.classValueArray.length)
          return classDef.classValueArray[i2];
        break;
      case 2:
        for (let range2 of classDef.classRangeRecord) {
          if (range2.start <= glyph && glyph <= range2.end)
            return range2.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index2, set3;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        set3 = table.ruleSets[index2];
        for (let rule of set3) {
          if (this.sequenceMatches(1, rule.input))
            return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1)
          return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index2 === -1)
          return false;
        set3 = table.classSet[index2];
        for (let rule1 of set3) {
          if (this.classSequenceMatches(1, rule1.classes, table.classDef))
            return this.applyLookupList(rule1.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages))
          return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index2;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        let set3 = table.chainRuleSets[index2];
        for (let rule of set3) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead))
            return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1)
          return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index2];
        if (!rules)
          return false;
        for (let rule2 of rules) {
          if (this.classSequenceMatches(-rule2.backtrack.length, rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + rule2.input.length, rule2.lookahead, table.lookaheadClassDef))
            return this.applyLookupList(rule2.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage))
          return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font, table) {
    this.font = font;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id9) {
    this._id = id9;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id9, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id9, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font, id9, codePoints = [], features) {
    this._font = font;
    this.codePoints = codePoints;
    this.id = id9;
    this.features = {};
    if (Array.isArray(features))
      for (let i2 = 0; i2 < features.length; i2++) {
        let feature = features[i2];
        this.features[feature] = true;
      }
    else if (typeof features === "object")
      Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state = 0;
    let i2 = 0;
    while (i2 < glyphs.length) {
      let action;
      let glyph = glyphs[i2];
      let code = glyph.codePoints[0];
      let type = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state][type];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code))
            i2 = $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i2 = $e1c6bbc8cb416f8c$var$compose(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i2 = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, plan.font);
          break;
      }
      i2++;
    }
  }
};
(0, _define_property)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
var $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
var $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
var $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
var $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
var $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
var $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
var $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
var $e1c6bbc8cb416f8c$var$isCombiningT = (code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code))
    return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code))
    return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code))
    return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code))
    return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code))
    return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code))
    return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font, code, features) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, font.glyphForCodePoint(code).id, [
    code
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyph.codePoints[0];
  let s = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t = $e1c6bbc8cb416f8c$var$T_BASE + s % $e1c6bbc8cb416f8c$var$T_COUNT;
  s = s / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l = $e1c6bbc8cb416f8c$var$L_BASE + s / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v = $e1c6bbc8cb416f8c$var$V_BASE + s % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== $e1c6bbc8cb416f8c$var$T_BASE && !font.hasGlyphForCodePoint(t))
    return i2;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font, l, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, v, glyph.features);
  vjmo.features.vjmo = true;
  let insert = [
    ljmo,
    vjmo
  ];
  if (t > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font, t, glyph.features);
    tjmo.features.tjmo = true;
    insert.push(tjmo);
  }
  glyphs.splice(i2, 1, ...insert);
  return i2 + insert.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  let type = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i2 - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i2 - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i2 - 2];
      vjmo = glyphs[i2 - 1];
      tjmo = glyph;
    }
    let l = ljmo.codePoints[0];
    let v = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l) && $e1c6bbc8cb416f8c$var$isCombiningV(v))
      lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t))) {
    let s = lv + (t - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font.hasGlyphForCodePoint(s)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i2 - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font, s, glyph.features));
      return i2 - del + 1;
    }
  }
  if (ljmo)
    ljmo.features.ljmo = true;
  if (vjmo)
    vjmo.features.vjmo = true;
  if (tjmo)
    tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i2 - 1, font);
    return i2 + 1;
  }
  return i2;
}
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.glyphForCodePoint(code).advanceWidth === 0)
    return;
  let prev = glyphs[i2 - 1].codePoints[0];
  let len2 = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i2, 1);
  return glyphs.splice(i2 - len2, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i2, font) {
  let glyph = glyphs[i2];
  let code = glyphs[i2].codePoints[0];
  if (font.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i2 : i2 + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i2++;
  }
  return i2;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,23,0,0,2,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("AAARAAAAAACgwgAAAbENTvLtnX+sHUUVx/f13nd/vHf7bl+FRGL7R0OJMcWYphBrimkVCSJR2xiEaLEGQ7AkBGowbYRSgj8K2B/GkpRYE6wlQSyJKCagrSlGkmqsqUZMY7S2CWkgqQViQSkt4Hfuzrx77tyZ2fm1u+/RPcknuzs7O3PmnDOzs7N73zteS5KXwKvgDTCnniTvBfPBJeAVpP2vFr69GGUtAkvAModyr0DeT4BrwCpwPVgDbga3ga+DjYbyluLcCvBN8F2wGWwHO8Ej4DjyPIbtz0DCeZpvD4CD4E/gb+AoOAFOgtPgLKiNJkkbTIKLwALwfvAh8GGwHFwFPg2uAzeCm8Ft4E5wN7gPPAi+D34AfgR+Ap7kx8+AZ8HvwZ/BEXAMvAheAa+Bc6OpzvVGknTABY30eB62C8GlYDFYCpaDq/n5z2J7PVgDbgG3N1KbrOdbWzby/N/G9i6wlR8/wLebUNcOll7vX7PLsQ4bdpAy92B/L3gK7AO/A38EfwX/AC+AkyT/m3x7mqdtYz7Gfq2ZJOPgPc3UXu/D9uJmmmcRT1uC7TJwZTONJxFL1+J4JbgBrAG3gNv5Nev5dhO2m3l54rqtON7RNLd1V8Z5auMfI+8Wbvv12P4Ux78AvyZl/Bb7fwD34HwH/EVR/t8t6rRlrYgFlHnMsdyXIupRFP+Gzv8Bb4CklSSjrTR9bz21uZx/Nj8v+uIFOJ4HFnJo3kWtNG6WkPSzBl1YbC8jeVfx+q+R9Pg48lxN8jFdhd8+01LrLTCdq6io8GNb1a8qKioqKioqKioc2cbXGcrWQ2Ynf9a9rmV/zVua9Dc16V/gz8pfxvar4A6wAdwL7gdbwUPgh+BR8AR4qpWuLe3D9gA4CA6DI+AoOAFOtdL1nNexfYs937fxDA8ubKf1zmv3dViI/Uvb9m2sqKioqAiHrVtehrH3TK2/3l4WZduioqIiDq+Rd1Jbef9ehnHmSnCtNNf7nOPcr8PHilO8jrfBF9v996lfwf6tUpl3tPvvdSjsvcwGnLt3Gsw/kzkpK8CdYH83my3Id0iT91WkL5xMktXgIfD85OD54zjfmYu5OFgN7h1LkmdBMg5fgbvAChzv49ujfEuZ3xlOk7kReTaSfL/B/jl+fMXsJLkb7AcPj8TlHC/zsgnYcyLd3zSh1vGAJr2ioqKiIn/eKXkMjn3/cWF5t/z6y37+K5urwP2YB36vPfw8yr7zeRjpu8g8cTf2H2+n89EtivLE93fs27Ez/Br2vM2+qWPl/ZyX9StFfQxW5v724PPxzXz7XHu4Pps5Jvtmiq13szmzfP0hlHkYHGn358bHeD0vYvsy+K+kz9vt/jy8gT40G1w4Rua0PN98nnaGf/e1G+mXIO2DY8P6Xz7WPz7Ky/7omJ0PBff4+B91fAqsAp8HXwI3gR04txbbdWDDWDpP/g7Yxs6BXWAP2AueJHo+M5bOpw+Cw+AIOApOgFMW7Xkdec6AkXH1+QfgyzbOTY73jy/C/gJ+/CCOP4D9xfz4I9h+TFMWtf9SRWzZwq7f0yi/L9voWSRbDfV/clx/3TuKfjoT26/iX813URx4tiVG3ay/sfFuJenb7J50A4mr1di/CZzLKZ6y2reunup4qzT+fM0wHp0PUD9+A7bYNJ5fn3eNP/Ft5bc0+S4n9/l1Gj+K82zesd1wfj3fZ79h2YyyVvLj7djfCR4xjJEyuy1+S/FyDt/MPwodn5hB8axrxy9nSBtYjOyHrs+BQ+B58E+u+wsWbWBtpb/hYL8RuA/pJ8fT2GffX+wl+daSa08jz9nxNG2k4963XBG/ZVhpUS573mh3BtPo7x/Eb7pE2yd5XvZssY/M/RZLc9SLeDsfD5gfTidi9//pwrzWu7t9lKcN7dxynthAh8vcKrQu1frHTGKBNF662KfoOXU1FsaFxe6x2kjClkBnGvXxwX0bytZ5unK+S9n2jxabTc5M0HUaIyTrfFa+Ljmflc9Xz7JtNdPa4eKz6WAPlb5l6xfLBzopWxcfncvSf7rHRJk2KSN2bKRsvcu2UZmxVIb9qd551e8rZcTERGuQ+qwIjERkjl2+djOlhWfpibnp/qxmP92FVr1/bc9GYxxuI5o3UzdukzYpj+H6nOxra9nHiaksjhDdsasPe9ca/CvOU1GVwUT4t8P921H4T8gsnkdIh+dn/pXrU0mnOZw21CbJv1P5LP0r4jtkbLH171BbCvavnFfeZ8L8K2wv/CuQRU6n/qWSNSbr2mO8xtK/U+Mq6Y/1yQyFJHHtv8Kn2uOC/Gvbf2VEPxJ9SvhY5d+Q+y21iRxLruOzsY6MWGrOkPHZ1b+jFuPzqEX/VcmoZkyIPT53k36/DZnrMd+K/Dbjs6kv6+6VYl9OU+WT07TplvMvWWhfVo3f4t48S+rbjIZl/1b5Xyd5vJdQiTyf7tUdMlbn0J9d/cn6c7M5DO1TNF0+bmT0Z3qdKaaoXeg1Lv7NEhufzyT/6vIKEeO1jX/psdi38a889qpkStcI/u12U3zE1Re+/Yv6QNwvdTDJGi9t2ps1XtKYDJ0PmcZKcU812sRxvms7J47mZ5c+SWJD5LPRg4qqj+nWL8Q5sRVrGar1EG0sOI6ndH3DVWL7wpeuwaY6O1Nh19N+Oqs5uI7Eto3aICxNrCn5rAuZ7Cn2bdJtfZPlL/k8Ld+ki6v9E56XPUvT52mV/YVvmMj2Zz8TEuNMTxfHuFfFUJ60OLrz1utODnFG47fLbSjXy0xSy4gN63EywlhMxWcNmK71svszi5OGTvdJe3rtd8ifB6I/mKBr1ap7uU/sqqTsMb+H5fxBFyuq+yqLnd7cmj33TwyOVVOwuj3nVXRtQtUGWR9jzI6kecZrKSKPuFakU2hZmXXZMDlsS1W9jBavv6eHpf3EtfJ7mKwYV0lX2g9FVY5N+Ung9aH1590+n3KLgEredfiez6u9svisY/Suk9Jsnkli1a+C1m/T7rzqd5UY9mfiXX9R92ibdZUIawTC96b1GBn6rDG1JsPv/b392SkiXVUGmyN0LO5LYi46Zf/Adc/QMaCo8TtG/bH1Z/TsW1QfUPRjm2cZee5PRaT33lEbnhlMax4qe1o/Y8a0icdaoOv9bsh+Hj6jonueoGtHumcMlX9lxLxXq7/D84fSzznGt6rtUerXxYU47/IcPeG3vqBbJ1StETZqg9fS2Akd/0Ovp+/CxD3P+/6bQwzJtsvyh5w+XjeXH9KfXGH3/VbSX4tS4XoftPZbnvcyxX1G5QvW1wbWTkbs7c3mTco6NWODbdxk3R9lGZo/aGxhiknTmETXLVs1c90u9+mBGCf6hs6fsmTq29sxPv8d82CuhCpNjGNjg31blGHrz1i41hd6nuYzbU3XhLQzj7Jt67Otw0uXUdDoH8e4F/joMdVui2dMJc3E+Tetvr6jEtPnPhJaVwz9Y7TDVlx1qnfitlEbtzlTVD0qX/pcm1esxI65PO3mU4eNrr5SZMz46FDE+aIlb5tntb1o/WOUETsW847pvNpaZH225eUpNnrS9yDy9wTysyr9XVOe63+qd3M6e4X6Ptd1Dpc1SdV53ZqFag1hpP+bE5f4ivY74BzXilzWWW1+S0TjJng91Gd9wmbNgpMVz6W8d7GJZwWtWp8p++c8fpjW0Vzff3dJfzGuoersEtnmpjVLupY48H6o7n8/C+kvJn+Lcd6q3QHx3usvZax3W8apvP6rev+UJSHfiCYe/h2aTwTaRi5DO28ZSd9zNhTfJ8b2je7drOo9HtNNbPMW03zOpq2qNqnKFN+0huhlMye2Pe9TdzfCedfxMlRfG7xjncaJ7fiXMYZk3X+ZvuKbXCGh8y8XH8TybajPTfq4tjG2/qb0RJO3SB19ba2SMuoNbW8R/g653qa9sdsRYsssu+ZxPss+tnayFd94yjofEi+hZdvo73q9jd3yisUYbfEpQ9XmMqUIm2fFZh4xkZeE1BNDL5v+ZcqXh/90bSwjflz8U0QcFWHzPOpy0amM+stqf1ad7LltVPqWmG3p3+GiIvLJf8duYA3NcBwbWRpkDXmo7RP+z5E6+8Xswz512dbrW2aMNrpKaBt9y45VR2j9efhAQL/PF38Xadq907NYC5dpZLy3kMX6PUHgeGGS3nfoPn9rObJ9s/4uMntnSt/J5TX+2ZRhtFcB8ZgVmyZbit8GCd/7/C7EOcYK7LdyjNhIlL81nqN/Xf9mOHt/anovP4X0tyem/OUZF9TmscY2nzEulq96ZeVwv2Bxxnwk3s9njT8m/YWOKl199fe53tTXyu5DLojfKWXej6R3RAPtDf1ex/PvtdJ8Q7aP7Ht6XpdXSJf8/wMdQuS/j0/HtKny9KbT+oT2K2ETuW7Tt09Uss5nCdWhjPuMTXzrztO4FHMy+V6TJaH9I6+2C5HPq9oc8xlKRva5rF8M/7tC26/6BsNFivQ//e1pVsyP19VrNrH1D5Wi7oUDdVp8Q5HVr1ztlzXPtH2Gc30+lMX3edH3ecm3fp0+Ps/IPvWH6OpiV7meEMlbzyIkpi1jtDU0Pmm6nMd0jU8bXK7N0jWkb/joHyNebfWgtrJpc0h7QiQP24aKqcwYPnTRIUmG63fRQ5VXLsekgy5NtVXVadLfpjzV9S6xYnuNri159ZmsmLCpJ8/6XSRGOaH659H+GLYtwhd51xvq31B9Qm0UavM84qhoKaNOnfwf"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      let d = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d) {
        let decomposed = d.map((c) => {
          let g = plan.font.glyphForCodePoint(c);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
var $7826f90f6f0cecc9$var$IndicInfo = class {
  constructor(category, position2, syllableType, syllable) {
    this.category = category;
    this.position = position2;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  let last4 = 0;
  for (let [start, end, tags] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start > last4) {
      ++syllable;
      for (let i2 = last4; i2 < start; i2++)
        glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i2 = start; i2 <= end; i2++)
      glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i2]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i2]), tags[0], syllable);
    last4 = end + 1;
  }
  if (last4 < glyphs.length) {
    ++syllable;
    for (let i2 = last4; i2 < glyphs.length; i2++)
      glyphs[i2].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs)
    glyph.features = {
      [feature]: true
    };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font.glyphForCodePoint(9676).id;
  let virama = font.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, virama, [
      indicConfig.virama
    ]);
    for (let i2 = 0; i2 < glyphs.length; i2++)
      if (glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
        glyphs[i2].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font, glyphs[i2].copy(), info);
  }
  for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {
    let { category, syllableType } = glyphs[start].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster")
      continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
      let i2 = start;
      while (i2 < end && glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha)
        i2++;
      glyphs.splice(i2++, 0, g);
      end++;
    }
    let base = end;
    let limit = start;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g = [
        glyphs[start].copy(),
        glyphs[start + 1].copy(),
        glyphs[start + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g, "rphf")) {
        limit += 2;
        while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
          limit++;
        base = start;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
        limit++;
      base = start;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i2 = end;
        let seenBelow = false;
        do {
          let info = glyphs[--i2].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2])) {
            if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i2;
              break;
            }
            if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C)
              seenBelow = true;
            base = i2;
          } else if (start < i2 && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i2 - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
            break;
        } while (i2 > limit);
        break;
      }
      case "First":
        base = start;
        for (let i2 = base + 1; i2 < end; i2++)
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i2]))
            glyphs[i2].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start && limit - base <= 2)
      hasReph = false;
    for (let i1 = start; i1 < base; i1++) {
      let info = glyphs[i1].shaperInfo;
      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
    }
    if (base < end)
      glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i2 = base + 1; i2 < end; i2++)
      if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
        for (let j = i2 + 1; j < end; j++)
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
            glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
            break;
          }
        break;
      }
    if (hasReph)
      glyphs[start].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i2 = base + 1; i2 < end; i2++)
        if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
          let j;
          for (j = end - 1; j > i2; j--) {
            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
              break;
          }
          if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i2) {
            let t = glyphs[i2];
            glyphs.splice(i2, 0, ...glyphs.splice(i2 + 1, j - i2));
            glyphs[j] = t;
          }
          break;
        }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i3 = start; i3 < end; i3++) {
      let info = glyphs[i3].shaperInfo;
      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
        info.position = lastPos;
        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i3; j > start; j--)
            if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
              info.position = glyphs[j - 1].shaperInfo.position;
              break;
            }
        }
      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
        lastPos = info.position;
    }
    let last4 = base;
    for (let i4 = base + 1; i4 < end; i4++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
        for (let j = last4 + 1; j < i4; j++)
          if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
            glyphs[j].shaperInfo.position = glyphs[i4].shaperInfo.position;
        last4 = i4;
      } else if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
        last4 = i4;
    }
    let arr2 = glyphs.slice(start, end);
    arr2.sort((a, b10) => a.shaperInfo.position - b10.shaperInfo.position);
    glyphs.splice(start, arr2.length, ...arr2);
    for (let i5 = start; i5 < end; i5++)
      if (glyphs[i5].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
        base = i5;
        break;
      }
    for (let i6 = start; i6 < end && glyphs[i6].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i6++)
      glyphs[i6].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i7 = start; i7 < base; i7++) {
      glyphs[i7].features.half = true;
      if (blwf)
        glyphs[i7].features.blwf = true;
    }
    for (let i8 = base + 1; i8 < end; i8++) {
      glyphs[i8].features.abvf = true;
      glyphs[i8].features.pstf = true;
      glyphs[i8].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i2 = start; i2 + 1 < base; i2++)
        if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i2 + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i2 + 1 === base || glyphs[i2 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
          glyphs[i2].features.blwf = true;
          glyphs[i2 + 1].features.blwf = true;
        }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end)
      for (let i9 = base + 1; i9 + prefLen - 1 < end; i9++) {
        let g = [
          glyphs[i9].copy(),
          glyphs[i9 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g, "pref")) {
          for (let j = 0; j < prefLen; j++)
            glyphs[i9++].features.pref = true;
          if (features.cfar)
            for (; i9 < end; i9++)
              glyphs[i9].features.cfar = true;
          break;
        }
      }
    for (let i10 = start + 1; i10 < end; i10++)
      if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i10])) {
        let nonJoiner = glyphs[i10].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
        let j = i10;
        do {
          j--;
          if (nonJoiner)
            delete glyphs[j].features.half;
        } while (j > start && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
      }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font._layoutEngine.engine.GSUBProcessor.features;
  for (let start = 0, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start)) {
    let tryPref = !!features.pref;
    let base = start;
    for (; base < end; base++)
      if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
        if (tryPref && base + 1 < end) {
          for (let i2 = base + 1; i2 < end; i2++)
            if (glyphs[i2].features.pref) {
              if (!(glyphs[i2].substituted && glyphs[i2].isLigated && !glyphs[i2].isMultiplied)) {
                base = i2;
                while (base < end && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base]))
                  base++;
                glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
                tryPref = false;
              }
              break;
            }
        }
        if (plan.unicodeScript === "Malayalam")
          for (let i2 = base + 1; i2 < end; i2++) {
            while (i2 < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2]))
              i2++;
            if (i2 === end || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i2]))
              break;
            i2++;
            while (i2 < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[i2]))
              i2++;
            if (i2 < end && $7826f90f6f0cecc9$var$isConsonant(glyphs[i2]) && glyphs[i2].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
              base = i2;
              glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
            }
          }
        if (start < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
          base--;
        break;
      }
    if (base === end && start < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)
      base--;
    if (base < end)
      while (start < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))
        base--;
    if (start + 1 < end && start < base) {
      let newPos = base === end ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
          newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1]))
            newPos++;
        } else
          newPos = start;
      }
      if (start < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i2 = newPos; i2 > start; i2--)
          if (glyphs[i2 - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            let oldPos = i2 - 1;
            if (oldPos < base && base <= newPos)
              base--;
            let tmp = glyphs[oldPos];
            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
            glyphs[newPos] = tmp;
            newPos--;
          }
      }
    }
    if (start + 1 < end && glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
          newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
            newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main)
            newRephPos++;
          found = newRephPos < end;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)))
            newRephPos++;
          found = newRephPos < end;
        }
      }
      if (!found) {
        newRephPos = start + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
          newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
            newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end - 1;
        while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
          newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i2 = base + 1; i2 < newRephPos; i2++)
            if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
              newRephPos--;
        }
      }
      let reph = glyphs[start];
      glyphs.splice(start, 0, ...glyphs.splice(start + 1, newRephPos - start));
      glyphs[newRephPos] = reph;
      if (start < base && base <= newRephPos)
        base--;
    }
    if (tryPref && base + 1 < end) {
      for (let i2 = base + 1; i2 < end; i2++)
        if (glyphs[i2].features.pref) {
          if (glyphs[i2].isLigated && !glyphs[i2].isMultiplied) {
            let newPos = base;
            if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
              while (newPos > start && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
                newPos--;
              if (newPos > start && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                let oldPos2 = i2;
                for (let j = base + 1; j < oldPos2; j++)
                  if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                    newPos--;
                    break;
                  }
              }
            }
            if (newPos > start && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
              if (newPos < end && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos]))
                newPos++;
            }
            let oldPos = i2;
            let tmp = glyphs[oldPos];
            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
            glyphs[newPos] = tmp;
            if (newPos <= base && base < oldPos)
              base++;
          }
          break;
        }
    }
    if (glyphs[start].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start - 1].codePoints[0]))))
      glyphs[start].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start) {
  if (start >= glyphs.length)
    return start;
  let syllable = glyphs[start].shaperInfo.syllable;
  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable)
    ;
  return start;
}
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, /* @__PURE__ */ $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i2 = glyphs.length - 1; i2 >= 0; i2--) {
      let codepoint = glyphs[i2].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c) => {
          let g = plan.font.glyphForCodePoint(c);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c
          ], glyphs[i2].features);
        });
        glyphs.splice(i2, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
var $7ab494fe977143c6$var$USEInfo = class {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font, glyphs) {
  let syllable = 0;
  for (let [start, end, tags] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i2 = start; i2 <= end; i2++)
      glyphs[i2].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i2])], tags[0], syllable);
    let limit = glyphs[start].shaperInfo.category === "R" ? 1 : Math.min(3, end - start);
    for (let i1 = start; i1 < start + limit; i1++)
      glyphs[i1].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font, glyphs) {
  for (let glyph of glyphs)
    glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font, glyphs) {
  for (let glyph of glyphs)
    if (glyph.substituted && glyph.features.rphf)
      glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font, glyphs) {
  for (let glyph of glyphs)
    if (glyph.substituted)
      glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font, glyphs) {
  let dottedCircle = font.glyphForCodePoint(9676).id;
  for (let start = 0, end = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = $7ab494fe977143c6$var$nextSyllable(glyphs, start)) {
    let i2, j;
    let info = glyphs[start].shaperInfo;
    let type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster")
      continue;
    if (type === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font, dottedCircle, [
        9676
      ]);
      g.shaperInfo = info;
      for (i2 = start; i2 < end && glyphs[i2].shaperInfo.category === "R"; i2++)
        ;
      glyphs.splice(++i2, 0, g);
      end++;
    }
    if (info.category === "R" && end - start > 1)
      for (i2 = start + 1; i2 < end; i2++) {
        info = glyphs[i2].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i2])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i2]))
            i2--;
          glyphs.splice(start, 0, ...glyphs.splice(start + 1, i2 - start), glyphs[i2]);
          break;
        }
      }
    for (i2 = start, j = end; i2 < end; i2++) {
      info = glyphs[i2].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i2]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i2]) ? i2 + 1 : i2;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i2)
        glyphs.splice(j, 1, glyphs[i2], ...glyphs.splice(j, i2 - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start) {
  if (start >= glyphs.length)
    return start;
  let syllable = glyphs[start].shaperInfo.syllable;
  while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable)
    ;
  return start;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // N’Ko
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script))
    script = [
      script
    ];
  for (let s of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s];
    if (shaper)
      return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index2);
            break;
        }
        return true;
      }
      case 2: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let sequence = table.sequences.get(index2);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i2) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i2 + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        for (let ligature of table.ligatureSets.get(index2)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched)
            continue;
          let curGlyph = this.glyphIterator.cur;
          let characters = curGlyph.codePoints.slice();
          for (let index3 of matched)
            characters.push(...this.glyphs[index3].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i2 = 0; i2 < matched.length && isMarkLigature; i2++)
            isMarkLigature = this.glyphs[matched[i2]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature)
              idx = matchIndex;
            else
              while (idx < matchIndex) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                this.glyphs[idx].ligatureComponent = ligatureComponent;
                idx++;
              }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature)
            for (let i1 = idx; i1 < this.glyphs.length; i1++) {
              if (this.glyphs[i1].ligatureID === lastLigID) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i1].ligatureComponent || 1, lastNumComps);
                this.glyphs[i1].ligatureComponent = ligatureComponent;
              } else
                break;
            }
          for (let i2 = matched.length - 1; i2 >= 0; i2--)
            this.glyphs.splice(matched[i2], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyPositionValue(sequenceIndex, value) {
    let position2 = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value.xAdvance != null)
      position2.xAdvance += value.xAdvance;
    if (value.yAdvance != null)
      position2.yAdvance += value.yAdvance;
    if (value.xPlacement != null)
      position2.xOffset += value.xPlacement;
    if (value.yPlacement != null)
      position2.yOffset += value.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value.xPlaDevice)
        position2.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
      if (value.yPlaDevice)
        position2.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
      if (value.xAdvDevice)
        position2.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
      if (value.yAdvDevice)
        position2.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index2));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph)
          return false;
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1)
          return false;
        switch (table.version) {
          case 1:
            let set3 = table.pairSets.get(index2);
            for (let pair of set3)
              if (pair.secondGlyph === nextGlyph.id) {
                this.applyPositionValue(0, pair.value1);
                this.applyPositionValue(1, pair.value2);
                return true;
              }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1)
              return false;
            var pair1 = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair1.value1);
            this.applyPositionValue(1, pair1.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph)
          return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor)
          return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor)
          return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d = entry.x + next.xOffset;
            next.xAdvance -= d;
            next.xOffset -= d;
            break;
          case "rtl":
            d = exit.x + cur.xOffset;
            cur.xAdvance -= d;
            cur.xOffset -= d;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1)
          return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0))
          ;
        if (baseGlyphIndex < 0)
          return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1)
          return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1)
          return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark)
          ;
        if (baseGlyphIndex < 0)
          return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1)
          return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1)
          return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark)
          return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID)
            good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent)
            good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent)
          good = true;
        if (!good)
          return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1)
          return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x2 = anchor.xCoordinate;
    let y2 = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable)
        x2 += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable)
        y2 += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x: x2,
      y: y2
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i2 = 0; i2 < this.glyphs.length; i2++)
      this.fixCursiveAttachment(i2);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i2) {
    let glyph = this.glyphs[i2];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i2].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i2 = 0; i2 < this.glyphs.length; i2++) {
      let glyph = this.glyphs[i2];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i2].xOffset += this.positions[j].xOffset;
        this.positions[i2].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr")
          for (let k = j; k < i2; k++) {
            this.positions[i2].xOffset -= this.positions[k].xAdvance;
            this.positions[i2].yOffset -= this.positions[k].yAdvance;
          }
        else
          for (let k1 = j + 1; k1 < i2 + 1; k1++) {
            this.positions[i2].xOffset += this.positions[k1].xAdvance;
            this.positions[i2].yOffset += this.positions[k1].yAdvance;
          }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor)
      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor)
      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures)
      glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS")
      this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor)
      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS")
      this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i2 = 0; i2 < this.glyphInfos.length; i2++)
      if (this.glyphInfos[i2].isMark) {
        positions[i2].xAdvance = 0;
        positions[i2].yAdvance = 0;
      }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font) {
    this.font = font;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font.GSUB)
      this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font, font.GSUB);
    if (font.GPOS)
      this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font, font.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  layout(string, features, script, language, direction3) {
    if (typeof features === "string") {
      direction3 = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null)
        script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string)
          codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction3);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup)
      this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup)
      this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute)
      this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position)
      positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine)
        this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor)
        this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i2 = 0; i2 < glyphs.length; i2++)
      if (this.isDefaultIgnorable(glyphs[i2].codePoints[0])) {
        glyphs[i2] = space;
        positions[i2].xAdvance = 0;
        positions[i2].yAdvance = 0;
      }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine)
      features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1)
      features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints)
      result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph)
      for (let string of this.engine.stringsForGlyph(gid))
        result.add(string);
    return Array.from(result);
  }
  constructor(font) {
    this.font = font;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx)
      this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS)
      this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx2) => {
      this.commands.forEach((c) => {
        return ctx2[c.command].apply(ctx2, c.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c) => {
      let args = c.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command1 of this.commands)
        for (let i2 = 0; i2 < command1.args.length; i2 += 2)
          cbox.addPoint(command1.args[i2], command1.args[i2 + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox)
      return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx = 0, cy = 0;
    let f = (t) => Math.pow(1 - t, 3) * p0[i2] + 3 * Math.pow(1 - t, 2) * t * p1[i2] + 3 * (1 - t) * Math.pow(t, 2) * p2[i2] + Math.pow(t, 3) * p3[i2];
    for (let c of this.commands)
      switch (c.command) {
        case "moveTo":
        case "lineTo":
          let [x2, y2] = c.args;
          bbox.addPoint(x2, y2);
          cx = x2;
          cy = y2;
          break;
        case "quadraticCurveTo":
        case "bezierCurveTo":
          if (c.command === "quadraticCurveTo") {
            var [qp1x, qp1y, p3x, p3y] = c.args;
            var cp1x = cx + 2 / 3 * (qp1x - cx);
            var cp1y = cy + 2 / 3 * (qp1y - cy);
            var cp2x = p3x + 2 / 3 * (qp1x - p3x);
            var cp2y = p3y + 2 / 3 * (qp1y - p3y);
          } else
            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c.args;
          bbox.addPoint(p3x, p3y);
          var p0 = [
            cx,
            cy
          ];
          var p1 = [
            cp1x,
            cp1y
          ];
          var p2 = [
            cp2x,
            cp2y
          ];
          var p3 = [
            p3x,
            p3y
          ];
          for (var i2 = 0; i2 <= 1; i2++) {
            let b10 = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
            let a = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
            c = 3 * p1[i2] - 3 * p0[i2];
            if (a === 0) {
              if (b10 === 0)
                continue;
              let t = -c / b10;
              if (0 < t && t < 1) {
                if (i2 === 0)
                  bbox.addPoint(f(t), bbox.maxY);
                else if (i2 === 1)
                  bbox.addPoint(bbox.maxX, f(t));
              }
              continue;
            }
            let b2ac = Math.pow(b10, 2) - 4 * c * a;
            if (b2ac < 0)
              continue;
            let t12 = (-b10 + Math.sqrt(b2ac)) / (2 * a);
            if (0 < t12 && t12 < 1) {
              if (i2 === 0)
                bbox.addPoint(f(t12), bbox.maxY);
              else if (i2 === 1)
                bbox.addPoint(bbox.maxX, f(t12));
            }
            let t2 = (-b10 - Math.sqrt(b2ac)) / (2 * a);
            if (0 < t2 && t2 < 1) {
              if (i2 === 0)
                bbox.addPoint(f(t2), bbox.maxY);
              else if (i2 === 1)
                bbox.addPoint(bbox.maxX, f(t2));
            }
          }
          cx = p3x;
          cy = p3y;
          break;
      }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path4 = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c of this.commands) {
      let args = [];
      for (let i2 = 0; i2 < c.args.length; i2 += 2) {
        let [x2, y2] = fn(c.args[i2], c.args[i2 + 1]);
        args.push(x2, y2);
      }
      path4[c.command](...args);
    }
    return path4;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x2, y2) => {
      const tx = m0 * x2 + m2 * y2 + m4;
      const ty = m1 * x2 + m3 * y2 + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x2, y2) {
    return this.transform(1, 0, 0, 1, x2, y2);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle2) {
    let cos = Math.cos(angle2);
    let sin = Math.sin(angle2);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
])
  $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
    this._bbox = this._cbox = null;
    this.commands.push({
      command,
      args
    });
    return this;
  };
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length)
      return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics)
      return this._metrics;
    let { advance: advanceWidth, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx)
      var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null)
        ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR)
      advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyph’s control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyph’s bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size4) {
    let scale3 = 1 / this._font.unitsPerEm * size4;
    return this.path.scale(scale3);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post)
      return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id9 = post.glyphNameIndex[this.id];
        if (id9 < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length)
          return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id9];
        return post.names[id9 - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx2, size4) {
    ctx2.save();
    let scale3 = 1 / this._font.head.unitsPerEm * size4;
    ctx2.scale(scale3, scale3);
    let fn = this.path.toFunction();
    fn(ctx2);
    ctx2.fill();
    ctx2.restore();
  }
  constructor(id9, codePoints, font) {
    this.id = id9;
    this.codePoints = codePoints;
    this._font = font;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x2 = 0, y2 = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x2;
    this.y = y2;
  }
};
var $69aac16029968692$var$Component = class {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal)
      return this.path.cbox;
    let stream = this._font._getTableStream("glyf");
    stream.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream, prev, short, same) {
    if (short) {
      var val = stream.readUInt8();
      if (!same)
        val = -val;
      val += prev;
    } else if (same)
      var val = prev;
    else
      var val = prev + stream.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos)
      return null;
    let stream = this._font._getTableStream("glyf");
    stream.pos += glyfPos;
    let startPos = stream.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream);
    if (glyph.numberOfContours > 0)
      this._decodeSimple(glyph, stream);
    else if (glyph.numberOfContours < 0)
      this._decodeComposite(glyph, stream, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream.readUInt8();
        for (let j = 0; j < count; j++)
          flags.push(flag);
      }
    }
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      let point2 = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i2) >= 0, 0, 0);
      glyph.points.push(point2);
    }
    let px = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].x = px = this._parseGlyphCoord(stream, px, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py = 0;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags[i2];
      glyph.points[i2].y = py = this._parseGlyphCoord(stream, py, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream, offset = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream.readUInt16BE();
      let gPos = stream.pos - offset;
      let glyphID = stream.readUInt16BE();
      if (!haveInstructions)
        haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream.readInt16BE();
        var dy = stream.readInt16BE();
      } else {
        var dx = stream.readInt8();
        var dy = stream.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i2 = 0; i2 < points.length; i2++) {
        let point2 = points[i2];
        glyph.components[i2].dx = point2.x;
        glyph.components[i2].dy = point2.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null)
      this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph)
      return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i2 = 0; i2 < contours2.length; i2++) {
          let contour = contours2[i2];
          for (let j = 0; j < contour.length; j++) {
            let point3 = contour[j];
            let x2 = point3.x * component.scaleX + point3.y * component.scale01 + component.dx;
            let y2 = point3.y * component.scaleY + point3.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point3.onCurve, point3.endContour, x2, y2));
          }
        }
      }
    else
      points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k = 0; k < points.length; k++) {
      var point2 = points[k];
      cur.push(point2);
      if (point2.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics)
      return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path4 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i2 = 0; i2 < contours.length; i2++) {
      let contour = contours[i2];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path4.moveTo(firstPt.x, firstPt.y);
      for (let j = start; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve)
          path4.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve)
          var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path4.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path4.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else
          throw new Error("Unknown TTF path state");
      }
      if (curvePt)
        path4.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path4.closePath();
    }
    return path4;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getName() {
    if (this._font.CFF2)
      return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s) {
    if (s.length < 1240)
      return 107;
    else if (s.length < 33900)
      return 1131;
    else
      return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream } = cff;
    let str3 = cff.topDict.CharStrings[this.id];
    let end = str3.offset + str3.length;
    stream.pos = str3.offset;
    let path4 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width2 = null;
    let nStems = 0;
    let x1 = 0, y1 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width2 == null)
        width2 = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0)
        checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo2(x2, y2) {
      if (open)
        path4.closePath();
      path4.moveTo(x2, y2);
      open = true;
    }
    let parse9 = function() {
      while (stream.pos < end) {
        let op = stream.readUInt8();
        if (op < 32) {
          let index2, subr, phase;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1)
                checkWidth();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 5:
              while (stack.length >= 2) {
                x1 += stack.shift();
                y1 += stack.shift();
                path4.lineTo(x1, y1);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase)
                  x1 += stack.shift();
                else
                  y1 += stack.shift();
                path4.lineTo(x1, y1);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 10:
              index2 = stack.pop() + subrsBias;
              subr = subrs[index2];
              if (subr) {
                usedSubrs[index2] = true;
                var p = stream.pos;
                var e = end;
                stream.pos = subr.offset;
                end = subr.offset + subr.length;
                parse9();
                stream.pos = p;
                end = e;
              }
              break;
            case 11:
              if (cff.version >= 2)
                break;
              return;
            case 14:
              if (cff.version >= 2)
                break;
              if (stack.length > 0)
                checkWidth();
              if (open) {
                path4.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2)
                throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2)
                throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor)
                throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i2 = 0; i2 < numBlends; i2++) {
                let sum = stack[base + i2];
                for (let j = 0; j < blendVector.length; j++)
                  sum += blendVector[j] * stack[delta++];
                stack[base + i2] = sum;
              }
              while (numOperands--)
                stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2)
                checkWidth();
              x1 += stack.shift();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 22:
              if (stack.length > 1)
                checkWidth();
              x1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 24:
              while (stack.length >= 8) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              x1 += stack.shift();
              y1 += stack.shift();
              path4.lineTo(x1, y1);
              break;
            case 25:
              while (stack.length >= 8) {
                x1 += stack.shift();
                y1 += stack.shift();
                path4.lineTo(x1, y1);
              }
              var c1x = x1 + stack.shift();
              var c1y = y1 + stack.shift();
              var c2x = c1x + stack.shift();
              var c2y = c1y + stack.shift();
              x1 = c2x + stack.shift();
              y1 = c2y + stack.shift();
              path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              break;
            case 26:
              if (stack.length % 2)
                x1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1;
                c1y = y1 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x;
                y1 = c2y + stack.shift();
                path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 27:
              if (stack.length % 2)
                y1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1 + stack.shift();
                c1y = y1;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y;
                path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 28:
              stack.push(stream.readInt16BE());
              break;
            case 29:
              index2 = stack.pop() + gsubrsBias;
              subr = gsubrs[index2];
              if (subr) {
                usedGsubrs[index2] = true;
                var p = stream.pos;
                var e = end;
                stream.pos = subr.offset;
                end = subr.offset + subr.length;
                parse9();
                stream.pos = p;
                end = e;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y1 = c2y + stack.shift();
                  x1 = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x1;
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path4.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                phase = !phase;
              }
              break;
            case 12:
              op = stream.readUInt8();
              switch (op) {
                case 3:
                  let a = stack.pop();
                  let b10 = stack.pop();
                  stack.push(a && b10 ? 1 : 0);
                  break;
                case 4:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a || b10 ? 1 : 0);
                  break;
                case 5:
                  a = stack.pop();
                  stack.push(a ? 0 : 1);
                  break;
                case 9:
                  a = stack.pop();
                  stack.push(Math.abs(a));
                  break;
                case 10:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a + b10);
                  break;
                case 11:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a - b10);
                  break;
                case 12:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a / b10);
                  break;
                case 14:
                  a = stack.pop();
                  stack.push(-a);
                  break;
                case 15:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a === b10 ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(a * b10);
                  break;
                case 26:
                  a = stack.pop();
                  stack.push(Math.sqrt(a));
                  break;
                case 27:
                  a = stack.pop();
                  stack.push(a, a);
                  break;
                case 28:
                  a = stack.pop();
                  b10 = stack.pop();
                  stack.push(b10, a);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0)
                    idx = 0;
                  else if (idx > stack.length - 1)
                    idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n2 = stack.pop();
                  let j = stack.pop();
                  if (j >= 0)
                    while (j > 0) {
                      var t = stack[n2 - 1];
                      for (let i2 = n2 - 2; i2 >= 0; i2--)
                        stack[i2 + 1] = stack[i2];
                      stack[0] = t;
                      j--;
                    }
                  else
                    while (j < 0) {
                      var t = stack[0];
                      for (let i2 = 0; i2 <= n2; i2++)
                        stack[i2] = stack[i2 + 1];
                      stack[n2 - 1] = t;
                      j++;
                    }
                  break;
                case 34:
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  let c3x = c2x + stack.shift();
                  let c3y = c2y;
                  let c4x = c3x + stack.shift();
                  let c4y = c3y;
                  let c5x = c4x + stack.shift();
                  let c5y = c4y;
                  let c6x = c5x + stack.shift();
                  let c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path4.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path4.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  let pts = [];
                  for (let i2 = 0; i2 <= 5; i2++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  path4.bezierCurveTo(...pts.slice(0, 6));
                  path4.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x1 + stack.shift();
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path4.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path4.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x1;
                  let starty = y1;
                  pts = [];
                  for (let i1 = 0; i1 <= 4; i1++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  if (Math.abs(x1 - startx) > Math.abs(y1 - starty)) {
                    x1 += stack.shift();
                    y1 = starty;
                  } else {
                    x1 = startx;
                    y1 += stack.shift();
                  }
                  pts.push(x1, y1);
                  path4.bezierCurveTo(...pts.slice(0, 6));
                  path4.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247)
          stack.push(op - 139);
        else if (op < 251) {
          var b12 = stream.readUInt8();
          stack.push((op - 247) * 256 + b12 + 108);
        } else if (op < 255) {
          var b12 = stream.readUInt8();
          stack.push(-(op - 251) * 256 - b12 - 108);
        } else
          stack.push(stream.readInt32BE() / 65536);
      }
    };
    parse9();
    if (open)
      path4.closePath();
    return path4;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t) => t.parent.buflen - t._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size4) {
    for (let i2 = 0; i2 < this._font.sbix.imageTables.length; i2++) {
      var table = this._font.sbix.imageTables[i2];
      if (table.ppem >= size4)
        break;
    }
    let offsets = table.imageOffsets;
    let start = offsets[this.id];
    let end = offsets[this.id + 1];
    if (start === end)
      return null;
    this._font.stream.pos = start;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end - start
    });
  }
  render(ctx2, size4) {
    let img = this.getImageForSize(size4);
    if (img != null) {
      let scale3 = size4 / this._font.unitsPerEm;
      ctx2.image(img.data, {
        height: size4,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale3
      });
    }
    if (this._font.sbix.flags.renderOutlines)
      super.render(ctx2, size4);
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  constructor(glyph, color2) {
    this.glyph = glyph;
    this.color = color2;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i2 = 0; i2 < this.layers.length; i2++) {
      let layer = this.layers[i2];
      let b10 = layer.glyph.bbox;
      bbox.addPoint(b10.minX, b10.minY);
      bbox.addPoint(b10.maxX, b10.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid)
        high = mid - 1;
      else if (this.id > rec.gid)
        low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g = this._font._getBaseGlyph(this.id);
      var color2 = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g, color2)
      ];
    }
    let layers = [];
    for (let i2 = baseLayer.firstLayerIndex; i2 < baseLayer.firstLayerIndex + baseLayer.numLayers; i2++) {
      var rec = colr.layerRecords[i2];
      var color2 = cpal.colorRecords[rec.paletteIndex];
      var g = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g, color2));
    }
    return layers;
  }
  render(ctx2, size4) {
    for (let { glyph, color: color2 } of this.layers) {
      ctx2.fillColor([
        color2.red,
        color2.green,
        color2.blue
      ], color2.alpha / 255 * 100);
      glyph.render(ctx2, size4);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i2 = 0; i2 < this.font.fvar.axis.length; i2++) {
      let axis = this.font.fvar.axis[i2];
      if (coords[i2] < axis.defaultValue)
        normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else
        normalized.push((coords[i2] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar)
      for (var i2 = 0; i2 < this.font.avar.segment.length; i2++) {
        let segment = this.font.avar.segment[i2];
        for (let j = 0; j < segment.correspondence.length; j++) {
          let pair = segment.correspondence[j];
          if (j >= 1 && normalized[i2] < pair.fromCoord) {
            let prev = segment.correspondence[j - 1];
            normalized[i2] = ((normalized[i2] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
            break;
          }
        }
      }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar)
      return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount)
      return;
    let offset = gvar.offsets[gid];
    if (offset === gvar.offsets[gid + 1])
      return;
    let { stream } = this.font;
    stream.pos = offset;
    if (stream.pos >= stream.length)
      return;
    let tupleCount = stream.readUInt16BE();
    let offsetToData = offset + stream.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream.pos;
      stream.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream.pos;
      stream.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i2 = 0; i2 < tupleCount; i2++) {
      let tupleDataSize = stream.readUInt16BE();
      let tupleIndex = stream.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a = 0; a < gvar.axisCount; a++)
          tupleCoords.push(stream.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount)
          throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a = 0; a < gvar.axisCount; a++)
          startCoords.push(stream.readInt16BE() / 16384);
        var endCoords = [];
        for (let a1 = 0; a1 < gvar.axisCount; a1++)
          endCoords.push(stream.readInt16BE() / 16384);
      }
      let factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream.pos;
      stream.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS)
        var points = this.decodePoints();
      else
        var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0)
        for (let i3 = 0; i3 < glyphPoints.length; i3++) {
          var point2 = glyphPoints[i3];
          point2.x += Math.round(xDeltas[i3] * factor);
          point2.y += Math.round(yDeltas[i3] * factor);
        }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i3 = 0; i3 < points.length; i3++) {
          let idx = points[i3];
          if (idx < glyphPoints.length) {
            let point3 = outPoints[idx];
            hasDelta[idx] = true;
            point3.x += Math.round(xDeltas[i3] * factor);
            point3.y += Math.round(yDeltas[i3] * factor);
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i1 = 0; i1 < glyphPoints.length; i1++) {
          let deltaX = outPoints[i1].x - origPoints[i1].x;
          let deltaY = outPoints[i1].y - origPoints[i1].y;
          glyphPoints[i1].x += deltaX;
          glyphPoints[i1].y += deltaY;
        }
      }
      offsetToData += tupleDataSize;
      stream.pos = here;
    }
  }
  decodePoints() {
    let stream = this.font.stream;
    let count = stream.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS)
      count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
    let points = new Uint16Array(count);
    let i2 = 0;
    let point2 = 0;
    while (i2 < count) {
      let run2 = stream.readUInt8();
      let runCount = (run2 & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run2 & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
      for (let j = 0; j < runCount && i2 < count; j++) {
        point2 += fn.call(stream);
        points[i2++] = point2;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream = this.font.stream;
    let i2 = 0;
    let deltas = new Int16Array(count);
    while (i2 < count) {
      let run2 = stream.readUInt8();
      let runCount = (run2 & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run2 & $0bb840cac04e911b$var$DELTAS_ARE_ZERO)
        i2 += runCount;
      else {
        let fn = run2 & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
        for (let j = 0; j < runCount && i2 < count; j++)
          deltas[i2++] = fn.call(stream);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor = 1;
    for (let i2 = 0; i2 < gvar.axisCount; i2++) {
      if (tupleCoords[i2] === 0)
        continue;
      if (normalized[i2] === 0)
        return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i2] < Math.min(0, tupleCoords[i2]) || normalized[i2] > Math.max(0, tupleCoords[i2]))
          return 0;
        factor = (factor * normalized[i2] + Number.EPSILON) / (tupleCoords[i2] + Number.EPSILON);
      } else {
        if (normalized[i2] < startCoords[i2] || normalized[i2] > endCoords[i2])
          return 0;
        else if (normalized[i2] < tupleCoords[i2])
          factor = factor * (normalized[i2] - startCoords[i2] + Number.EPSILON) / (tupleCoords[i2] - startCoords[i2] + Number.EPSILON);
        else
          factor = factor * (endCoords[i2] - normalized[i2] + Number.EPSILON) / (endCoords[i2] - tupleCoords[i2] + Number.EPSILON);
      }
    }
    return factor;
  }
  // Interpolates points without delta values.
  // Needed for the Ø and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0)
      return;
    let point2 = 0;
    while (point2 < points.length) {
      let firstPoint = point2;
      let endPoint = point2;
      let pt = points[endPoint];
      while (!pt.endContour)
        pt = points[++endPoint];
      while (point2 <= endPoint && !hasDelta[point2])
        point2++;
      if (point2 > endPoint)
        continue;
      let firstDelta = point2;
      let curDelta = point2;
      point2++;
      while (point2 <= endPoint) {
        if (hasDelta[point2]) {
          this.deltaInterpolate(curDelta + 1, point2 - 1, curDelta, point2, inPoints, points);
          curDelta = point2;
        }
        point2++;
      }
      if (curDelta === firstDelta)
        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0)
          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point2 = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2)
      return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i2 = 0; i2 < iterable.length; i2++) {
      let k = iterable[i2];
      if (inPoints[ref1][k] > inPoints[ref2][k]) {
        var p = ref1;
        ref1 = ref2;
        ref2 = p;
      }
      let in1 = inPoints[ref1][k];
      let in2 = inPoints[ref2][k];
      let out1 = outPoints[ref1][k];
      let out2 = outPoints[ref2][k];
      if (in1 !== in2 || out1 === out2) {
        let scale3 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p3 = p1; p3 <= p2; p3++) {
          let out = inPoints[p3][k];
          if (out <= in1)
            out += out1 - in1;
          else if (out >= in2)
            out += out2 - in2;
          else
            out = out1 + (out - in1) * scale3;
          outPoints[p3][k] = out;
        }
      }
    }
  }
  deltaShift(p1, p2, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0)
      return;
    for (let p = p1; p <= p2; p++)
      if (p !== ref) {
        outPoints[p].x += deltaX;
        outPoints[p].y += deltaY;
      }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount)
        idx = table.advanceWidthMapping.mapCount - 1;
      let entryFormat = table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length)
      return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length)
      return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++)
      netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData))
      return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord)
          axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0)
          axisScalar = 1;
        else if (axis.peakCoord === 0)
          axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord)
          axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord)
            axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord)
            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else
            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font, coords) {
    this.font = font;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  includeGlyph(glyph) {
    if (typeof glyph === "object")
      glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font) {
    this.font = font;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream, value) {
    if (value >= 0 && value <= 255)
      stream.writeUInt8(value);
    else
      stream.writeInt16BE(value);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  encodeSimple(path4, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i2 = 0; i2 < path4.commands.length; i2++) {
      let c = path4.commands[i2];
      for (let j = 0; j < c.args.length; j += 2) {
        let x2 = c.args[j];
        let y2 = c.args[j + 1];
        let flag = 0;
        if (c.command === "quadraticCurveTo" && j === 2) {
          let next = path4.commands[i2 + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x2 === midX && y2 === midY)
              continue;
          }
        }
        if (!(c.command === "quadraticCurveTo" && j === 0))
          flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x2, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y2, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x2;
        lastY = y2;
        pointCount++;
      }
      if (c.command === "closePath")
        endPtsOfContours.push(pointCount - 1);
    }
    if (path4.commands.length > 1 && path4.commands[path4.commands.length - 1].command !== "closePath")
      endPtsOfContours.push(pointCount - 1);
    let bbox = path4.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size4 = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size4 % 4;
    let stream = new EncodeStream(size4 + tail);
    $807e58506be70005$var$Glyf.encode(stream, glyf);
    if (tail !== 0)
      stream.fill(0, tail);
    return stream.buffer;
  }
  _encodePoint(value, last4, points, flag, shortFlag, sameFlag) {
    let diff = value - last4;
    if (value === last4)
      flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0)
          diff = -diff;
        else
          flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream = this.font._getTableStream("glyf");
    stream.pos += curOffset;
    let buffer = stream.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i2 = 0;
    while (i2 < this.glyphs.length)
      this._addGlyph(this.glyphs[i2++]);
    let maxp = (0, import_clone2.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head2 = (0, import_clone2.default)(this.font.head);
    head2.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone2.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head: head2,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font) {
    super(font);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path4 = glyph.path;
      for (let subr in glyph._usedGsubrs)
        gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i2 = 0; i2 < subrs.length; i2++) {
      let subr = subrs[i2];
      if (used[i2]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else
        res.push(new Uint8Array([
          11
        ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null)
        continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path4 = glyph.path;
      for (let subr in glyph._usedSubrs)
        used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i2 = 0; i2 < topDict.FDArray.length; i2++) {
      let dict = topDict.FDArray[i2];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i2]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path4 = glyph.path;
      for (let subr in glyph._usedSubrs)
        used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs)
      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string)
      return null;
    if (!this.strings)
      this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ])
      topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont)
      this.subsetFontdict(topDict);
    else
      this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font) {
    super(font);
    this.cff = this.font["CFF "];
    if (!this.cff)
      throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let format = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
    return format === "true" || format === "OTTO" || format === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables))
      try {
        this._tables[table.tag] = this._decodeTable(table);
      } catch (e) {
        if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
          console.error(`Error decoding table ${table.tag}`);
          console.error(e.stack);
        }
      }
    return this._tables[table.tag];
  }
  _getTableStream(tag2) {
    let table = this.directory.tables[tag2];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream = this._getTableStream(table.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The font’s [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The font’s [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the font’s internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The font’s bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len2 = string.length;
    let idx = 0;
    let last4 = -1;
    let state = -1;
    while (idx <= len2) {
      let code = 0;
      let nextState = 0;
      if (idx < len2) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len2) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else
        idx++;
      if (state === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last4, code), [
          last4,
          code
        ]));
      else if (state === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last4));
      last4 = code;
      state = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction3) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction3);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf)
        this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2)
        this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix)
        this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL)
        this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters, this);
      else
        this._getBaseGlyph(glyph, characters);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "])
      return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar)
      return res;
    for (let axis of this.fvar.axis)
      res[axis.axisTag.trim()] = {
        name: axis.name.en,
        min: axis.minValue,
        default: axis.defaultValue,
        max: axis.maxValue
      };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar)
      return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i2 = 0; i2 < this.fvar.axis.length; i2++) {
        let axis = this.fvar.axis[i2];
        settings[axis.axisTag.trim()] = instance.coord[i2];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2)))
      throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string")
      settings = this.namedVariations[settings];
    if (typeof settings !== "object")
      throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i2) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings)
        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else
        return axis.defaultValue;
    });
    let stream = new DecodeStream(this.stream.buffer);
    stream.pos = this._directoryPos;
    let font = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream, coords);
    font._tables = this._tables;
    return font;
  }
  get _variationProcessor() {
    if (!this.fvar)
      return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2)
      return null;
    if (!variationCoords)
      variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream, variationCoords = null) {
    (0, _define_property)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag2 in this.directory.tables) {
      let table = this.directory.tables[tag2];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag2] && table.length > 0)
        Object.defineProperty(this, tag2, {
          get: this._getTable.bind(this, table)
        });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables1 = {};
  for (let table of this.tables)
    tables1[table.tag] = table;
  this.tables = tables1;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag2) {
    let table = this.directory.tables[tag2];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else
        return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i2 = iterable[j];
      let code = stream.readUInt8();
      if (result & 3758096384)
        throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0)
        return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t) => (t.flags & 63) === 63),
  tag: (t) => t.customTag || $c28ec7bbb3b8de3a$var$knownTags[t.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t) => t.flags >>> 6 & 3,
  transformed: (t) => t.tag === "glyf" || t.tag === "loca" ? t.transformVersion === 0 : t.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t) => t.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i2 = 0; i2 < this.tables.length; i2++) {
    let table = this.tables[i2];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag2 in this.directory.tables) {
        let entry = this.directory.tables[tag2];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
      if (!decompressed)
        throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs)
          this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters, this);
      } else
        return super._getBaseGlyph(glyph, characters);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index2 = 0; index2 < table.numGlyphs; index2++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i2 = 0; i2 < nContours; i2++) {
          let r1 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r1;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i1 = 0; i1 < nContours; i1++)
          glyph.points[nPoints[i1] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions)
          var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  decode(stream, parent) {
    return new DecodeStream(this._buf.decode(stream, parent));
  }
  constructor(length3) {
    this.length = length3;
    this._buf = new BufferT(length3);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream) {
  let code = stream.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE)
    return stream.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1)
    return stream.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2)
    return stream.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y2;
  let x2 = y2 = 0;
  let res = [];
  for (let i2 = 0; i2 < nPoints; i2++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b02 = flag - 20;
      var b12 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b02 & 48) + (b12 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b02 & 12) << 2) + (b12 & 15));
    } else if (flag < 120) {
      var b02 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b02 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b02 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b12 = glyphs.readUInt8();
      let b22 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b12 << 4) + (b22 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b22 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x2 += dx;
    y2 += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x2, y2));
  }
  return res;
}
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset of this.header.offsets) {
      let stream = new DecodeStream(this.stream.buffer);
      stream.pos = offset;
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i2) => name[i2] === v))
        return font;
    }
    return null;
  }
  get fonts() {
    let fonts3 = [];
    for (let offset of this.header.offsets) {
      let stream = new DecodeStream(this.stream.buffer);
      stream.pos = offset;
      fonts3.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream));
    }
    return fonts3;
  }
  constructor(stream) {
    (0, _define_property)(this, "type", "TTC");
    this.stream = stream;
    if (stream.readString(4) !== "ttcf")
      throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t) => t.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t) => t.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    let stream = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream);
    } catch (e) {
      return false;
    }
    for (let type of header.map.typeList.types) {
      if (type.name === "sfnt")
        return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt)
      return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream = new DecodeStream(this.stream.buffer.slice(pos));
      let font = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream);
      if (font.postscriptName === name || font.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font.postscriptName.every((v, i2) => name[i2] === v))
        return font;
    }
    return null;
  }
  get fonts() {
    let fonts3 = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream = new DecodeStream(this.stream.buffer.slice(pos));
      fonts3.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream));
    }
    return fonts3;
  }
  constructor(stream) {
    (0, _define_property)(this, "type", "DFont");
    this.stream = stream;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type of this.header.map.typeList.types) {
      for (let ref of type.refList)
        if (ref.nameOffset >= 0) {
          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
          ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
        } else
          ref.name = null;
      if (type.name === "sfnt")
        this.sfnt = type;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/config.js
var import_path4 = __toESM(require_path_browserify(), 1);
var _config = { fontFamilyMappings: {} };
var fonts = {};
var getConfig = () => _config;
var getFonts = () => fonts;

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/textUtils.js
var textBBox = function(text, x2, y2, details) {
  if (!text)
    return new NoBox();
  const config2 = getConfig();
  const preloaded = getFonts();
  const families = (details.fontFamily || fontFamily).split(/\s*,\s*/);
  const fontMap = Object.assign({}, fontFamilyMappings, config2.fontFamilyMappings);
  const fontSize2 = details.fontSize || fontSize;
  const fontDir2 = config2.fontDir || fontDir;
  let fontFamily2;
  let font;
  for (let i2 = 0, il = families.length; i2 < il; ++i2) {
    if (fontMap[families[i2]]) {
      fontFamily2 = families[i2];
      break;
    }
  }
  if (!fontFamily2) {
    fontFamily2 = fontFamily;
  }
  if (preloaded[fontFamily2]) {
    font = preloaded[fontFamily2];
  } else {
    const filename = import_node_path2.default.join(fontDir2, fontMap[fontFamily2]);
    try {
      font = (void 0)(filename);
    } catch (e) {
      console.warn(`Could not open font "${fontFamily2}" in file "${filename}". ${e.toString()}`);
      return new NoBox();
    }
    preloaded[fontFamily2] = font;
  }
  const fontHeight = font.ascent - font.descent;
  const lineHeight = fontHeight > font.unitsPerEm ? fontHeight : fontHeight + font.lineGap;
  const height = lineHeight / font.unitsPerEm * fontSize2;
  const width2 = font.layout(text).glyphs.reduce((last4, curr) => last4 + curr.advanceWidth, 0) / font.unitsPerEm * fontSize2;
  let xAdjust = 0;
  if (details.textAnchor === "end") {
    xAdjust = -width2;
  } else if (details.textAnchor === "middle") {
    xAdjust = -width2 / 2;
  }
  let yAdjust = font.ascent;
  if (details.dominantBaseline === "before-edge" || details.dominantBaseline === "text-before-edge") {
    yAdjust = 0;
  } else if (details.dominantBaseline === "hanging") {
    yAdjust = font.ascent - font.xHeight - font.capHeight;
  } else if (details.dominantBaseline === "mathematical") {
    yAdjust = font.ascent - font.xHeight;
  } else if (details.dominantBaseline === "middle") {
    yAdjust = font.ascent - font.xHeight / 2;
  } else if (details.dominantBaseline === "central") {
    yAdjust = font.ascent / 2 + font.descent / 2;
  } else if (details.dominantBaseline === "ideographic") {
    yAdjust = font.ascent + font.descent;
  }
  return new Box(x2 + xAdjust, y2 - yAdjust / font.unitsPerEm * fontSize2, width2, height);
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/utils/bboxUtils.js
var applyTransformation = (segments, node2, applyTransformations) => {
  if (node2.matrixify && applyTransformations) {
    return segments.transform(node2.matrixify());
  }
  return segments;
};
var getSegments2 = (node2, applyTransformations, rbox = false) => {
  const segments = getPathSegments2(node2, rbox);
  return applyTransformation(segments, node2, applyTransformations);
};
var getPathSegments2 = (node2, rbox) => {
  if (node2.nodeType !== 1)
    return new PathSegmentArray();
  switch (node2.nodeName) {
    case "rect":
    case "image":
    case "pattern":
    case "mask":
    case "foreignObject":
      return getPathSegments(pathFrom.rect(node2));
    case "svg":
    case "symbol":
      if (rbox) {
        return getPathSegments(pathFrom.rect(node2));
      }
    case "g":
    case "clipPath":
    case "a":
    case "marker":
      return node2.childNodes.reduce((segments, child) => {
        if (!child.matrixify)
          return segments;
        return segments.merge(getSegments2(child, true).transform(child.generateViewBoxMatrix()));
      }, new PathSegmentArray());
    case "circle":
      return getPathSegments(pathFrom.circle(node2));
    case "ellipse":
      return getPathSegments(pathFrom.ellipse(node2));
    case "line":
      return getPathSegments(pathFrom.line(node2));
    case "polyline":
    case "polygon":
      return getPathSegments(pathFrom.polyline(node2));
    case "path":
    case "glyph":
    case "missing-glyph":
      return getPathSegments(node2.getAttribute("d"));
    case "use": {
      const ref = node2.getAttribute("href") || node2.getAttribute("xlink:href");
      const refNode = node2.getRootNode().querySelector(ref);
      return getSegments2(refNode).transform(node2.generateViewBoxMatrix());
    }
    case "tspan":
    case "text":
    case "altGlyph": {
      const box = getTextBBox(node2);
      if (box instanceof NoBox) {
        return new PathSegmentArray();
      }
      return getPathSegments(pathFrom.box(box));
    }
    default:
      return new PathSegmentArray();
  }
};
var getTextBBox = (node2) => {
  const textRoot = findTextRoot(node2);
  const boxes = getTextBBoxes(node2, textRoot);
  return boxes.filter(isNotEmptyBox).reduce((last4, curr) => last4.merge(curr), new NoBox());
};
var findTextRoot = (node2) => {
  while (node2.parentNode) {
    if (node2.nodeName === "text" && node2.parentNode.nodeName === "text" || (node2.nodeName === "tspan" || node2.nodeName === "textPath") && ["tspan", "text", "textPath"].includes(node2.parentNode.nodeName)) {
      node2 = node2.parentNode;
    } else {
      break;
    }
  }
  return node2;
};
var getTextBBoxes = function(target, textRoot = target, pos = { x: 0, y: 0 }, dx = [0], dy = [0], boxes = []) {
  const iter = new NodeIterator(textRoot, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, (node2) => {
    if (node2.nodeName === "title")
      return NodeFilter.FILTER_IGNORE;
    return NodeFilter.FILTER_ACCEPT;
  });
  for (const node2 of iter) {
    if (node2 === target && node2 !== textRoot) {
      return getTextBBoxes(node2, node2, pos, dx, dy);
    }
    getPositionDetailsFor(node2, pos, dx, dy, boxes);
  }
  return boxes;
};
var isNotEmptyBox = (box) => box.x !== 0 || box.y !== 0 || box.width !== 0 || box.height !== 0;
var getPositionDetailsFor = (node2, pos, dx, dy, boxes) => {
  if (node2.nodeType === node2.ELEMENT_NODE) {
    const x2 = parseFloat(node2.getAttribute("x"));
    const y2 = parseFloat(node2.getAttribute("y"));
    pos.x = isNaN(x2) ? pos.x : x2;
    pos.y = isNaN(y2) ? pos.y : y2;
    const dx0 = (node2.getAttribute("dx") || "").split(delimiter).filter((num) => num !== "").map(parseFloat);
    const dy0 = (node2.getAttribute("dy") || "").split(delimiter).filter((num) => num !== "").map(parseFloat);
    dx.splice(0, dx0.length, ...dx0);
    dy.splice(0, dy0.length, ...dy0);
  } else {
    const data = node2.data;
    let j = 0;
    const jl = data.length;
    const details = getFontDetails(node2);
    if (dy.length || dx.length) {
      for (; j < jl; j++) {
        boxes.push(textBBox(data.substr(j, 1), pos.x, pos.y, details));
        pos.x += dx.shift() || 0;
        pos.y += dy.shift() || 0;
        if (!dy.length && !dx.length)
          break;
      }
    }
    boxes.push(textBBox(data.substr(j), pos.x, pos.y, details));
    pos.x += boxes[boxes.length - 1].width;
  }
};
var getFontDetails = (node2) => {
  if (node2.nodeType === node2.TEXT_NODE)
    node2 = node2.parentNode;
  let fontSize2 = null;
  let fontFamily2 = null;
  let textAnchor = null;
  let dominantBaseline = null;
  const textContentElements = [
    "text",
    "tspan",
    "tref",
    "textPath",
    "altGlyph",
    "g"
  ];
  do {
    if (!fontSize2) {
      fontSize2 = node2.style.fontSize || node2.getAttribute("font-size");
    }
    if (!fontFamily2) {
      fontFamily2 = node2.style.fontFamily || node2.getAttribute("font-family");
    }
    if (!textAnchor) {
      textAnchor = node2.style.textAnchor || node2.getAttribute("text-anchor");
    }
    if (!dominantBaseline) {
      dominantBaseline = node2.style.dominantBaseline || node2.getAttribute("dominant-baseline");
    }
  } while ((node2 = node2.parentNode) && node2.nodeType === node2.ELEMENT_NODE && textContentElements.includes(node2.nodeName));
  return {
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    textAnchor: textAnchor || "start",
    // TODO: use central for writing-mode === horizontal https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dominant-baseline
    dominantBaseline: dominantBaseline || "alphabetical"
    // fontFamilyMappings: this.ownerDocument.fontFamilyMappings,
    // fontDir: this.ownerDocument.fontDir,
    // preloaded: this.ownerDocument._preloaded
  };
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGGraphicsElement.js
function arrayToMatrix(a) {
  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] };
}
var SVGGraphicsElement = class _SVGGraphicsElement extends SVGElement {
  // TODO: https://www.w3.org/TR/SVG2/coords.html#ComputingAViewportsTransform
  generateViewBoxMatrix() {
    if (!["marker", "symbol", "pattern", "svg", "view"].includes(this.nodeName)) {
      return new SVGMatrix();
    }
    let view = (this.getAttribute("viewBox") || "").split(delimiter).map(parseFloat).filter((el) => !isNaN(el));
    const width2 = parseFloat(this.getAttribute("width")) || 0;
    const height = parseFloat(this.getAttribute("height")) || 0;
    const x2 = parseFloat(this.getAttribute("x")) || 0;
    const y2 = parseFloat(this.getAttribute("y")) || 0;
    if (!width2 || !height) {
      return new SVGMatrix().translate(x2, y2);
    }
    if (view.length !== 4) {
      view = [0, 0, width2, height];
    }
    return new SVGMatrix().translate(x2, y2).scale(width2 / view[2], height / view[3]).translate(-view[0], -view[1]);
  }
  getBBox() {
    return getSegments2(this).bbox();
  }
  // TODO: This method actually exists on all Elements
  getBoundingClientRect() {
    let m = this.matrixify();
    if (this.parentNode && this.parentNode.nodeName !== "#document") {
      m = this.parentNode.getScreenCTM().multiply(m);
    }
    return getSegments2(this, false, true).transform(m).bbox();
  }
  getCTM() {
    let m = this.matrixify();
    let node2 = this;
    while (node2 = node2.parentNode) {
      if (["svg", "symbol", "image", "pattern", "marker"].indexOf(node2.nodeName) > -1)
        break;
      m = m.multiply(node2.matrixify());
      if (node2.nodeName === "#document")
        return this.getScreenCTM();
    }
    return node2.generateViewBoxMatrix().multiply(m);
  }
  getInnerMatrix() {
    let m = this.matrixify();
    if (["svg", "symbol", "image", "pattern", "marker"].indexOf(this.nodeName) > -1) {
      m = this.generateViewBoxMatrix().multiply(m);
    }
    return m;
  }
  getScreenCTM() {
    const m = this.getInnerMatrix();
    if (this.parentNode && this.parentNode instanceof _SVGGraphicsElement) {
      return this.parentNode.getScreenCTM().multiply(m);
    }
    return m;
  }
  matrixify() {
    const matrix = (this.getAttribute("transform") || "").trim().split(transforms).slice(0, -1).map(function(str3) {
      const kv = str3.trim().split("(");
      return [kv[0].trim(), kv[1].split(delimiter).map(function(str4) {
        return parseFloat(str4.trim());
      })];
    }).reduce(function(matrix2, transform7) {
      if (transform7[0] === "matrix")
        return matrix2.multiply(arrayToMatrix(transform7[1]));
      return matrix2[transform7[0]].apply(matrix2, transform7[1]);
    }, new SVGMatrix());
    return matrix;
  }
  get transform() {
    throw new Error("Not implemented");
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGSVGElement.js
var SVGSVGElement = class extends SVGGraphicsElement {
  createSVGMatrix() {
    return new SVGMatrix();
  }
  createSVGPoint() {
    return new SVGPoint();
  }
  createSVGRect() {
    return new Box();
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGPathElement.js
var SVGPathElement = class extends SVGGraphicsElement {
  getPointAtLength(len2) {
    return pointAtLength(this.getAttribute("d"), len2);
  }
  getTotalLength() {
    return length2(this.getAttribute("d"));
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGLength.js
var unitTypes = {
  SVG_LENGTHTYPE_UNKNOWN: 0,
  SVG_LENGTHTYPE_NUMBER: 1,
  SVG_LENGTHTYPE_PERCENTAGE: 2,
  SVG_LENGTHTYPE_EMS: 3,
  SVG_LENGTHTYPE_EXS: 4,
  SVG_LENGTHTYPE_PX: 5,
  SVG_LENGTHTYPE_CM: 6,
  SVG_LENGTHTYPE_MM: 7,
  SVG_LENGTHTYPE_IN: 8,
  SVG_LENGTHTYPE_PT: 9,
  SVG_LENGTHTYPE_PC: 10
};
var unitByString = {
  [""]: unitTypes.SVG_LENGTHTYPE_NUMBER,
  ["%"]: unitTypes.SVG_LENGTHTYPE_PERCENTAGE,
  ["em"]: unitTypes.SVG_LENGTHTYPE_EMS,
  ["ex"]: unitTypes.SVG_LENGTHTYPE_EXS,
  ["px"]: unitTypes.SVG_LENGTHTYPE_PX,
  ["cm"]: unitTypes.SVG_LENGTHTYPE_CM,
  ["mm"]: unitTypes.SVG_LENGTHTYPE_MM,
  ["in"]: unitTypes.SVG_LENGTHTYPE_IN,
  ["pt"]: unitTypes.SVG_LENGTHTYPE_PT,
  ["pc"]: unitTypes.SVG_LENGTHTYPE_PC
};
var unitStringByConstant = new Map(
  Object.entries(unitByString).map(([unitString2, unitConstant]) => [
    unitConstant,
    unitString2
  ])
);
var unitFactors = /* @__PURE__ */ new Map([
  [unitTypes.SVG_LENGTHTYPE_NUMBER, 1],
  [unitTypes.SVG_LENGTHTYPE_PERCENTAGE, NaN],
  [unitTypes.SVG_LENGTHTYPE_EMS, NaN],
  [unitTypes.SVG_LENGTHTYPE_EXS, NaN],
  [unitTypes.SVG_LENGTHTYPE_PX, 1],
  [unitTypes.SVG_LENGTHTYPE_CM, 6],
  [unitTypes.SVG_LENGTHTYPE_MM, 96 / 25.4],
  [unitTypes.SVG_LENGTHTYPE_IN, 96],
  [unitTypes.SVG_LENGTHTYPE_PT, 4 / 3],
  [unitTypes.SVG_LENGTHTYPE_PC, 16]
]);
var valuePattern = /^\s*([+-]?[0-9]*[.]?[0-9]+(?:e[+-]?[0-9]+)?)(em|ex|px|in|cm|mm|pt|pc|%)?\s*$/i;
var SVGLength = class {
  element;
  attributeName;
  /**
   * @param {Element} element
   * @param {string} attributeName
   */
  constructor(element, attributeName) {
    this.element = element;
    this.attributeName = attributeName;
  }
  get unitType() {
    return parseValue(this.element.getAttribute(this.attributeName))[1];
  }
  get value() {
    const [value, unit2] = parseValue(
      this.element.getAttribute(this.attributeName)
    );
    return value * getUnitFactor(unit2);
  }
  set value(value) {
    const unitFactor = getUnitFactor(this.unitType);
    this.element.setAttribute(
      this.attributeName,
      value / unitFactor + unitString(this)
    );
  }
  get valueInSpecifiedUnits() {
    return parseValue(this.element.getAttribute(this.attributeName))[0];
  }
  set valueInSpecifiedUnits(value) {
    this.element.setAttribute(this.attributeName, value + unitString(this));
  }
  get valueAsString() {
    return this.valueInSpecifiedUnits + unitString(this);
  }
  set valueAsString(valueString) {
    const [value, unit2] = parseValue(valueString, false);
    const unitString2 = unitStringByConstant.get(unit2) || "";
    this.element.setAttribute(this.attributeName, value + unitString2);
  }
};
function parseValue(valueString, fallback = true) {
  const [, rawValue, rawUnit] = (valueString || "").match(valuePattern) || [];
  const unit2 = unitByString[(rawUnit || "").toLowerCase()];
  if (rawValue !== void 0 && unit2 !== void 0) {
    return [parseFloat(rawValue), unit2];
  }
  if (fallback) {
    return [0, unitTypes.SVG_LENGTHTYPE_NUMBER];
  }
  throw new Error("An invalid or illegal string was specified");
}
function getUnitFactor(unit2) {
  const unitFactor = unitFactors.get(unit2);
  if (unitFactor === void 0) {
    throw new Error(unitFactor + " is not a known unit constant");
  }
  if (isNaN(unitFactor)) {
    throw new Error(`Unit ${unitStringByConstant.get(unit2)} is not supported`);
  }
  return unitFactor;
}
function unitString(svgLength) {
  return unitStringByConstant.get(svgLength.unitType) || "";
}
extendStatic(SVGLength, unitTypes);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGAnimatedLength.js
var SVGAnimatedLength = class {
  baseVal;
  constructor(element, attributeName) {
    this.baseVal = new SVGLength(element, attributeName);
  }
  get animVal() {
    throw new Error("animVal is not implemented");
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGTextContentElement.js
var SVGTextContentElement = class extends SVGGraphicsElement {
  textWidth = new SVGAnimatedLength(this, "textWidth");
  getComputedTextLength() {
    return this.getBBox().width;
  }
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/DocumentType.js
var DocumentType = class extends Node {
  constructor(name, props) {
    super(name, props);
    this.nodeType = Node.DOCUMENT_TYPE_NODE;
    this.name = name;
    const { publicId, systemId } = props;
    this.publicId = publicId || "";
    this.systemId = systemId || "";
  }
};
mixin(ChildNode, DocumentType);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGRectElement.js
var SVGRectElement = class extends SVGGraphicsElement {
  x = new SVGAnimatedLength(this, "x");
  y = new SVGAnimatedLength(this, "y");
  width = new SVGAnimatedLength(this, "width");
  height = new SVGAnimatedLength(this, "height");
  rx = new SVGAnimatedLength(this, "rx");
  ry = new SVGAnimatedLength(this, "ry");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGCircleElement.js
var SVGCircleElement = class extends SVGGraphicsElement {
  cx = new SVGAnimatedLength(this, "cx");
  cy = new SVGAnimatedLength(this, "cy");
  r = new SVGAnimatedLength(this, "r");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGLineElement.js
var SVGLineElement = class extends SVGGraphicsElement {
  x1 = new SVGAnimatedLength(this, "x1");
  y1 = new SVGAnimatedLength(this, "y1");
  x2 = new SVGAnimatedLength(this, "x2");
  y2 = new SVGAnimatedLength(this, "y2");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGEllipseElement.js
var SVGEllipseElement = class extends SVGGraphicsElement {
  cx = new SVGAnimatedLength(this, "cx");
  cy = new SVGAnimatedLength(this, "cy");
  rx = new SVGAnimatedLength(this, "rx");
  ry = new SVGAnimatedLength(this, "ry");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGForeignObjectElement.js
var SVGForeignObjectElement = class extends SVGGraphicsElement {
  x = new SVGAnimatedLength(this, "x");
  y = new SVGAnimatedLength(this, "y");
  width = new SVGAnimatedLength(this, "width");
  height = new SVGAnimatedLength(this, "height");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/svg/SVGImageElement.js
var SVGImageElement = class extends SVGGraphicsElement {
  x = new SVGAnimatedLength(this, "x");
  y = new SVGAnimatedLength(this, "y");
  width = new SVGAnimatedLength(this, "width");
  height = new SVGAnimatedLength(this, "height");
};

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Document.js
function getChildByTagName(parent, name) {
  for (let child = parent.firstChild; child != null; child = child.nextSibling) {
    if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === name) {
      return child;
    }
  }
  return null;
}
var getSVGElementForName = (name) => {
  switch (name.toLowerCase()) {
    case "svg":
      return SVGSVGElement;
    case "path":
      return SVGPathElement;
    case "circle":
      return SVGCircleElement;
    case "ellipse":
      return SVGEllipseElement;
    case "line":
      return SVGLineElement;
    case "rect":
      return SVGRectElement;
    case "foreignObject":
      return SVGForeignObjectElement;
    case "image":
      return SVGImageElement;
    case "text":
    case "tspan":
    case "tref":
    case "altglyph":
    case "textpath":
      return SVGTextContentElement;
    default:
      return SVGGraphicsElement;
  }
};
var getHTMLElementForName = (name) => {
  switch (name.toLowerCase()) {
    case "img":
      return HTMLImageElement;
    case "link":
      return HTMLLinkElement;
    case "script":
      return HTMLScriptElement;
    default:
      return HTMLElement2;
  }
};
var getElementForNamespace = (ns, name) => {
  switch (ns) {
    case svg:
      return getSVGElementForName(name);
    case html:
    case null:
    case "":
    default:
      return getHTMLElementForName(name);
  }
};
var supportedFeatures = {
  xml: { "": true, "1.0": true, "2.0": true },
  core: { "": true, "2.0": true },
  html: { "": true, "1.0": true, "2.0": true },
  xhtml: { "": true, "1.0": true, "2.0": true }
  // HTML
};
var DOMImplementation = {
  hasFeature(feature, version) {
    const f = supportedFeatures[(feature || "").toLowerCase()];
    return f && f[version || ""] || false;
  },
  createDocumentType(qualifiedName, publicId, systemId) {
    return new DocumentType(qualifiedName, { publicId, systemId, ownerDocument: this });
  },
  createDocument(namespace, qualifiedName, doctype) {
    const doc = new Document(namespace);
    if (doctype) {
      if (doctype.ownerDocument) {
        throw new Error("the object is in the wrong Document, a call to importNode is required");
      }
      doctype.ownerDocument = doc;
      doc.appendChild(doctype);
    }
    if (qualifiedName) {
      doc.appendChild(doc.createElementNS(namespace, qualifiedName));
    }
    return doc;
  },
  createHTMLDocument(titleText = "") {
    const d = new Document(html);
    const root3 = d.createElement("html");
    const head2 = d.createElement("head");
    const title = d.createElement("title");
    title.appendChild(d.createTextNode(titleText));
    head2.appendChild(title);
    root3.appendChild(head2);
    root3.appendChild(d.createElement("body"));
    d.appendChild(root3);
    return d;
  }
};
var Document = class extends Node {
  constructor(ns) {
    super("#document", {}, ns);
    this.nodeType = Node.DOCUMENT_NODE;
    this.implementation = DOMImplementation;
    this.defaultView = null;
  }
  // https://dom.spec.whatwg.org/#dom-document-createattribute
  createAttribute(localName) {
    if (this.namespaceURI === html) {
      localName = localName.toLowerCase();
    }
    return this.createAttributeNS(null, localName, true);
  }
  createAttributeNS(ns, qualifiedName, local = false) {
    return new Attr(qualifiedName, { ownerDocument: this, local }, ns);
  }
  createComment(text) {
    return new Comment("#comment", { nodeValue: text, ownerDocument: this });
  }
  createDocumentFragment(name) {
    return new DocumentFragment("#document-fragment", { ownerDocument: this });
  }
  createElement(localName) {
    return this.createElementNS(this.namespaceURI, localName, true);
  }
  createElementNS(ns, qualifiedName, local = false) {
    const Element4 = getElementForNamespace(ns, qualifiedName);
    return new Element4(qualifiedName, {
      ownerDocument: this,
      local
    }, ns);
  }
  createTextNode(text) {
    return new Text2("#text", { nodeValue: text, ownerDocument: this });
  }
  get compatMode() {
    return "CSS1Compat";
  }
  get body() {
    return getChildByTagName(this.documentElement, "BODY");
  }
  get head() {
    return getChildByTagName(this.documentElement, "HEAD");
  }
  get documentElement() {
    return this.lastChild;
  }
};
mixin(elementAccess, Document);
mixin(ParentNode, Document);
mixin(NonElementParentNode, Document);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/dom/Window.js
var Window = class extends EventTarget {
  constructor() {
    super();
    this.document = new Document();
    this.document.defaultView = this;
    this.self = this;
    const doc = this.document;
    this.Image = class {
      constructor(width2, height) {
        const img = doc.createElement("img");
        if (width2 != null)
          img.setAttribute("width", width2);
        if (height != null)
          img.setAttribute("height", height);
        return img;
      }
    };
  }
  getComputedStyle(node2) {
    return {
      // FIXME: Currently this function treats every given attr
      // as inheritable from its parents which is ofc not always true
      // but good enough for svg.js
      getPropertyValue(attr) {
        let value;
        let cur = node2;
        do {
          value = cur.style[attr] || cur.getAttribute(attr);
        } while (value == null && (cur = cur.parentNode) && cur.nodeType === 1);
        return value || defaults_exports[camelCase(attr)] || null;
      }
    };
  }
};
var lastTime = 0;
var requestAnimationFrame2 = (callback) => {
  const now2 = new globalThis.Date().getTime();
  const timeToCall = Math.max(0, 16 - (now2 - lastTime));
  return globalThis.setTimeout(() => {
    lastTime = now2 + timeToCall;
    callback(lastTime);
  }, timeToCall);
};
var nowOffset = globalThis.Date.now();
var performance2 = {
  now: () => Date.now() - nowOffset
};
var winProps = {
  Window,
  Document,
  DocumentFragment,
  Node,
  EventTarget,
  Text: Text2,
  Attr,
  Element: Element3,
  CustomEvent,
  Event,
  HTMLElement: HTMLElement2,
  HTMLLinkElement,
  HTMLScriptElement,
  HTMLImageElement,
  // Image: HTMLImageElement, // is set on construction
  SVGMatrix,
  SVGPoint,
  SVGElement,
  SVGSVGElement,
  SVGPathElement,
  SVGGraphicsElement,
  SVGTextContentElement,
  setTimeout: globalThis.setTimeout,
  clearTimeout: globalThis.clearTimeout,
  pageXOffset: 0,
  pageYOffset: 0,
  Date: globalThis.Date,
  requestAnimationFrame: requestAnimationFrame2,
  cancelAnimationFrame: globalThis.clearTimeout,
  performance: performance2
};
extend2(Window, winProps);

// ../../node_modules/.pnpm/svgdom@0.1.19/node_modules/svgdom/src/factories.js
var { createDocument, createHTMLDocument } = DOMImplementation;
var createHTMLWindow = (title) => {
  const window2 = new Window();
  const document2 = DOMImplementation.createHTMLDocument(title);
  window2.document = document2;
  document2.defaultView = window2;
  return window2;
};

// runtime/render.ts
var DEFAUT_BGS = {
  light: "#FFFFFF",
  dark: "#282A36"
};
function renderPrepare(opts) {
  const { code, backgroundColor, pintoraConfig } = opts;
  const window2 = createHTMLWindow();
  const document2 = window2.document;
  const container = document2.createElement("div");
  container.id = "pintora-container";
  const global2 = globalThis;
  global2.document = document2;
  return {
    container,
    pintorRender(renderOpts) {
      let config2 = pintoraStandalone.getConfig();
      if (pintoraConfig) {
        config2 = pintoraStandalone.configApi.gnernateNewConfig(pintoraConfig);
      }
      const containerSize = opts.width ? { width: opts.width } : void 0;
      if (opts.width) {
        config2 = pintoraStandalone.configApi.gnernateNewConfig({ core: { useMaxWidth: true } });
      }
      return new Promise((resolve, reject) => {
        pintoraStandalone.renderTo(code, {
          container,
          renderer: renderOpts.renderer || "canvas",
          containerSize,
          enhanceGraphicIR(ir) {
            if (!ir.bgColor) {
              const themeVariables = config2.themeConfig.themeVariables || {};
              const newBgColor = backgroundColor || themeVariables.canvasBackground || (themeVariables.isDark ? DEFAUT_BGS.dark : DEFAUT_BGS.light);
              ir.bgColor = newBgColor;
            }
            return ir;
          },
          onRender(renderer) {
            resolve(renderer);
          },
          onError(e) {
            console.error("onError", e);
            reject(e);
          }
        });
      });
    }
  };
}
function doRender(opts) {
  const { pintorRender } = renderPrepare(opts);
  function renderToSvg() {
    return new Promise((resolve, reject) => {
      pintorRender({ renderer: "svg" }).then((renderer) => {
        const rootElement = renderer.getRootElement();
        rootElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        resolve(rootElement.outerHTML);
      }).catch(reject);
    });
  }
  return renderToSvg();
}

// fonts/SourceCodePro-Medium.ttf
var SourceCodePro_Medium_default = __toBinary("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ADUAPQBFAE0AVQBdAGUAbQB1AH0AhQCNAJoAogCqALIAugDCAMoA0gDaAOIA6gDyAPoBAgEKAAD//wAiAAYADgAWAB4AJgAuADYAPgBGAE4AVgBeAGYAbgB2AH4AhgCOAJMAmwCjAKsAswC7AMMAywDTANsA4wDrAPMA+wEDAQsAAP//ACIABwAPABcAHwAnAC8ANwA/AEcATwBXAF8AZwBvAHcAfwCHAI8AlACcAKQArAC0ALwAxADMANQA3ADkAOwA9AD8AQQBDAENY2FzZQZQY2FzZQZWY2FzZQZcY2FzZQZiY2FzZQZoY2FzZQZuY2FzZQZ0Y2FzZQZ6Y2NtcAaAY2NtcAaOY2NtcAacY2NtcAaqY2NtcAa4Y2NtcAbGY2NtcAbUY2NtcAbiY3YwMQbwY3YwMQb2Y3YwMQb8Y3YwMQcCY3YwMQcIY3YwMQcOY3YwMQcUY3YwMQcaY3YwMgcgY3YwMgcmY3YwMgcsY3YwMgcyY3YwMgc4Y3YwMgc+Y3YwMgdEY3YwMgdKY3YwNAdQY3YwNAdWY3YwNAdcY3YwNAdiY3YwNAdoY3YwNAduY3YwNAd0Y3YwNAd6Y3YwNgeAY3YwNgeGY3YwNgeMY3YwNgeSY3YwNgeYY3YwNgeeY3YwNgekY3YwNgeqY3YwNwewY3YwNwe2Y3YwNwe8Y3YwNwfCY3YwNwfIY3YwNwfOY3YwNwfUY3YwNwfaY3YwOAfgY3YwOAfmY3YwOAfsY3YwOAfyY3YwOAf4Y3YwOAf+Y3YwOAgEY3YwOAgKY3YwOQgQY3YwOQgWY3YwOQgcY3YwOQgiY3YwOQgoY3YwOQguY3YwOQg0Y3YwOQg6Y3YxMAhAY3YxMAhGY3YxMAhMY3YxMAhSY3YxMAhYY3YxMAheY3YxMAhkY3YxMAhqY3YxMQhwY3YxMQh2Y3YxMQh8Y3YxMQiCY3YxMQiIY3YxMQiOY3YxMQiUY3YxMQiaY3YxMgigY3YxMgimY3YxMgisY3YxMgiyY3YxMgi4Y3YxMgi+Y3YxMgjEY3YxMgjKY3YxNAjQY3YxNAjWY3YxNAjcY3YxNAjiY3YxNAjoY3YxNAjuY3YxNAj0Y3YxNAj6Y3YxNQkAY3YxNQkGY3YxNQkMY3YxNQkSY3YxNQkYY3YxNQkeY3YxNQkkY3YxNQkqY3YxNgkwY3YxNgk2Y3YxNgk8Y3YxNglCY3YxNglIY3YxNglOY3YxNglUY3YxNglaY3YxNwlgY3YxNwlmY3YxNwlsY3YxNwlyY3YxNwl4Y3YxNwl+Y3YxNwmEY3YxNwmKZG5vbQmQZG5vbQmWZG5vbQmcZG5vbQmiZG5vbQmoZG5vbQmuZG5vbQm0ZG5vbQm6ZnJhYwnAZnJhYwnMZnJhYwnYZnJhYwnkZnJhYwnwZnJhYwn8ZnJhYwoIZnJhYwoUbG9jbAogbG9jbAombG9jbAoubG9jbAo0bG9jbAo6bnVtcgpAbnVtcgpGbnVtcgpMbnVtcgpSbnVtcgpYbnVtcgpebnVtcgpkbnVtcgpqb251bQpwb251bQp2b251bQp8b251bQqCb251bQqIb251bQqOb251bQqUb251bQqab3Jkbgqgb3Jkbgqmb3Jkbgqsb3Jkbgqyb3Jkbgq4b3Jkbgq+b3JkbgrEb3JkbgrKc2FsdArQc2FsdArsc2FsdAsIc2FsdAskc2FsdAtAc2FsdAtcc2FsdAt4c2FsdAuUc2luZguwc2luZgu2c2luZgu8c2luZgvCc2luZgvIc2luZgvOc2luZgvUc2luZgvac3MwMQvgc3MwMQvoc3MwMQvwc3MwMQv4c3MwMQwAc3MwMQwIc3MwMQwQc3MwMQwYc3MwMgwgc3MwMgwoc3MwMgwwc3MwMgw4c3MwMgxAc3MwMgxIc3MwMgxQc3MwMgxYc3MwMwxgc3MwMwxqc3MwMwx0c3MwMwx+c3MwMwyIc3MwMwySc3MwMwycc3MwMwymc3MwNAywc3MwNAy2c3MwNAy8c3MwNAzCc3MwNAzIc3MwNAzOc3MwNAzUc3MwNAzac3MwNQzgc3MwNQzoc3MwNQzwc3MwNQz4c3MwNQ0Ac3MwNQ0Ic3MwNQ0Qc3MwNQ0Yc3MwNg0gc3MwNg0mc3MwNg0sc3MwNg0yc3MwNg04c3MwNg0+c3MwNg1Ec3MwNg1Kc3MwNw1Qc3MwNw1Wc3MwNw1cc3MwNw1ic3MwNw1oc3MwNw1uc3MwNw10c3MwNw16c3Vicw2Ac3Vicw2Gc3Vicw2Mc3Vicw2Sc3Vicw2Yc3Vicw2ec3Vicw2kc3Vicw2qc3Vwcw2wc3Vwcw26c3Vwcw3Ec3Vwcw3Oc3Vwcw3Yc3Vwcw3ic3Vwcw3sc3Vwcw32emVybw4AemVybw4GemVybw4MemVybw4SemVybw4YemVybw4eemVybw4kemVybw4qAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAABQAFAAYABwAIAAkAAAAFAAUABgAHAAgACQAAAAUABQAGAAcACAAJAAAABQAFAAYABwAIAAkAAAAFAAUABgAHAAgACQAAAAUABQAGAAcACAAJAAAABQAFAAYABwAIAAkAAAAFAAUABgAHAAgACQdAAAEAFQc6AAEAFQc0AAEAFQcuAAEAFQcoAAEAFQciAAEAFQccAAEAFQcWAAEAFQceAAEAFgcYAAEAFgcSAAEAFgcMAAEAFgcGAAEAFgcAAAEAFgb6AAEAFgb0AAEAFgb8AAEAFwb2AAEAFwbwAAEAFwbqAAEAFwbkAAEAFwbeAAEAFwbYAAEAFwbSAAEAFwbaAAEAAAbUAAEAAAbOAAEAAAbIAAEAAAbCAAEAAAa8AAEAAAa2AAEAAAawAAEAAAa4AAEAGAayAAEAGAasAAEAGAamAAEAGAagAAEAGAaaAAEAGAaUAAEAGAaOAAEAGAaWAAEAGQaQAAEAGQaKAAEAGQaEAAEAGQZ+AAEAGQZ4AAEAGQZyAAEAGQZsAAEAGQZ0AAEAGgZuAAEAGgZoAAEAGgZiAAEAGgZcAAEAGgZWAAEAGgZQAAEAGgZKAAEAGgZSAAEAAwZMAAEAAwZGAAEAAwZAAAEAAwY6AAEAAwY0AAEAAwYuAAEAAwYoAAEAAwYwAAEAAgYqAAEAAgYkAAEAAgYeAAEAAgYYAAEAAgYSAAEAAgYMAAEAAgYGAAEAAgYOAAEAGwYIAAEAGwYCAAEAGwX8AAEAGwX2AAEAGwXwAAEAGwXqAAEAGwXkAAEAGwXsAAEAHAXmAAEAHAXgAAEAHAXaAAEAHAXUAAEAHAXOAAEAHAXIAAEAHAXCAAEAHAXKAAEAHQXEAAEAHQW+AAEAHQW4AAEAHQWyAAEAHQWsAAEAHQWmAAEAHQWgAAEAHQWoAAEAHgWiAAEAHgWcAAEAHgWWAAEAHgWQAAEAHgWKAAEAHgWEAAEAHgV+AAEAHgWGAAEAHwWAAAEAHwV6AAEAHwV0AAEAHwVuAAEAHwVoAAEAHwViAAEAHwVcAAEAHwAAAAEACwAAAAEACwAAAAEACwAAAAEACwAAAAEACwAAAAEACwAAAAEACwAAAAEACwAA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AaoA3AGsAOwBvADwAcAA8QD2AcYA+AHIAPcBxwGaAR0EVwB3ALIBgQDjAbMAPwEMAIUBUACpAXYA2wGrAN0BrQDeAa4A3wGvAOABsABPARwAdAFAAKoBdwBvATsAmgFnAD4BCwBOARsAugGIAMgBlgDOAZ0B0wHbAdQB1QHWAdcB2AHZAdoB3QHeAd8B4AHtAfAB8QHyAfMCHAHcAesB7gHvAfQEMgQ6BD8EQQTfBPQE9wT1BPkE8QT2BOcESAQ0BDsEQARJBPsE/gUBBQMFBQUHBQkFDQUPBREFFQUXBRkFHAUTBR4FIAUiBS0FLgUvBTAFMgU0BTYFNwT9BQAFQwUjBUoFRQKxArMCdgKtAncCeAJ5AnwCfgKlAnoCfQKcAp0CngKfAqYClwKQApECkgKTApQClQKWAqACowKhAqICpAL/A0oDAANLAwEDTAMCA00DAwNOAwQDTwMFA1ADBgNRAwcDUgMIA1MDCQNUAwoDVQMLA1YDDANXAw0DWAMOA1kDDwMQA1oDWwMRA1wDEgNdAxMDXgMUA18DFQNgAxYDYQMXA2IDGANjAxkDZAQqBCwELQQzBDUEOAQ8BD0AUQEeAFgBJQBZASYAWgEnAG4BOgB1AUEAegFFAHkBRAB7AUcAfAFIAIwBWACNAVkAkQFeAJIBXwCTAWAAlgFjAJcBZACYAWUAngFrAJ8BbACgAW0AuAGAAL4BjQDAAY4AwQGPAMIBkADJAZcAygGYAMYBlADPAZ4A0AGfAOkBuQDqAboA6wG7AO0BvQDyAcIA+QHJAPoBygD7AcsBRgGgAEEBDgBCAQ8AQwEQAEQBEQBFARIARgETAEcBFABIARUASQEWAEoBFwBLARgATAEZAGYBMgBnATMAaAE0AGkBNQBqATYAawE3AGwBOABtATkAhwFSAIgBUwCrAXgArAF5AK0BegCuAXsArwF8ALABfQCxAX4AswGCALQBgwC1AYQAtgGFALcBhgDhAbEA4gGyAOQBtADlAbUA5gG2AOcBtwDoAbgA7gG+APMBwwD0AcQA9QHFArYCtQK3AsECxAK7Ar0CvwK8Ar4CwALCAsMCuQK6ArgDrAOqA6sDrQPQA74DnAOdA6ADogOeA58DoQPMA80DrwYTBGwD0QPVA78DwAPSA9QD0wPuBDED+AP5BDYEZwRZBF0EVQRlBGIEYwNrA+IEeAR9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AgMAAAKHAAACkgAAAggAAAKUAAAClQAAAhcAAAKYAAACmAAAAhwAAAKZAAACmQAAAdwAAAKcAAACnAAAAesAAAKdAAACngAAAe4AAAKfAAACnwAAAfQAAAKhAAACogAAAhkAAAKkAAACpAAAAhQAAAKmAAACpwAAAhUAAAKwAAACsAAABDAAAAKyAAACsgAABDIAAAKzAAACswAABDoAAAK3AAACtwAABD8AAAK4AAACuAAABEEAAAK5AAACuQAABN8AAAK7AAACvAAABOAAAAK+AAACvwAABOIAAALBAAACwQAABOQAAALGAAACzAAABOoAAALQAAAC0QAABOUAAALYAAAC2AAABPQAAALZAAAC2QAABPcAAALaAAAC2gAABPUAAALbAAAC2wAABPkAAALcAAAC3AAABPEAAALdAAAC3QAABPYAAALeAAAC3gAABOcAAALgAAAC4AAABEgAAALhAAAC4QAABDQAAALiAAAC4gAABDsAAALjAAAC4wAABEAAAALkAAAC5AAABEkAAAMAAAADAAAABPsAAAMBAAADAQAABP4AAAMCAAADAgAABQEAAAMDAAADAwAABQMAAAMEAAADBAAABQUAAAMFAAADBQAABQcAAAMGAAADBgAABQkAAAMHAAADBwAABQ0AAAMIAAADCAAABQ8AAAMJAAADCQAABREAAAMKAAADCgAABRUAAAMLAAADCwAABRcAAAMMAAADDAAABRkAAAMPAAADDwAABRwAAAMQAAADEAAABRMAAAMRAAADEQAABR4AAAMSAAADEgAABSAAAAMTAAADEwAABSIAAAMYAAADIAAABSQAAAMjAAADJgAABS0AAAMnAAADJwAABTIAAAMoAAADKAAABTQAAAMpAAADKgAABTYAAAMsAAADLAAABTgAAAMuAAADMQAABTkAAAM0AAADNAAABT0AAAM5AAADPQAABT4AAANAAAADQAAABP0AAANBAAADQQAABQAAAANCAAADQgAABUMAAANDAAADQwAABSMAAANEAAADRAAABUoAAANFAAADRQAABUUAAANfAAADXwAABUYAAANhAAADYQAABUcAAAN0AAADdQAAAq8AAAN6AAADegAAArQAAAN+AAADfgAAAqwAAAOEAAADhAAAArEAAAOFAAADhQAAArMAAAOGAAADhgAAAnYAAAOHAAADhwAAAq0AAAOIAAADigAAAncAAAOMAAADjAAAAnsAAAOOAAADjgAAAnwAAAOPAAADjwAAAn4AAAOQAAADkAAAAqUAAAORAAADoQAAAl4AAAOjAAADqQAAAm8AAAOqAAADqgAAAnoAAAOrAAADqwAAAn0AAAOsAAADrwAAApwAAAOwAAADsAAAAqYAAAOxAAADwQAAAn8AAAPCAAADwgAAApcAAAPDAAADyQAAApAAAAPKAAADygAAAqAAAAPLAAADywAAAqMAAAPMAAADzQAAAqEAAAPOAAADzgAAAqQAAAPQAAAD0QAAApgAAAPVAAAD1QAAApoAAAPXAAAD1wAAAqcAAAPZAAAD2QAAAqgAAAPbAAAD2wAAAqkAAAPdAAAD3QAAAqoAAAPhAAAD4QAAAqsAAAQAAAAEDwAAAu8AAAQQAAAELwAAAs8AAAQwAAAEXwAAAxoAAARiAAAEYgAAAv8AAARjAAAEYwAAA0oAAARyAAAEcgAAAwAAAARzAAAEcwAAA0sAAAR0AAAEdAAAAwEAAAR1AAAEdQAAA0wAAASQAAAEkAAAAwIAAASRAAAEkQAAA00AAASSAAAEkgAAAwMAAASTAAAEkwAAA04AAASWAAAElgAAAwQAAASXAAAElwAAA08AAASYAAAEmAAAAwUAAASZAAAEmQAAA1AAAASaAAAEmgAAAwYAAASbAAAEmwAAA1EAAASgAAAEoAAAAwcAAAShAAAEoQAAA1IAAASiAAAEogAAAwgAAASjAAAEowAAA1MAAASqAAAEqgAAAwkAAASrAAAEqwAAA1QAAASuAAAErgAAAwoAAASvAAAErwAAA1UAAASwAAAEsAAAAwsAAASxAAAEsQAAA1YAAASyAAAEsgAAAwwAAASzAAAEswAAA1cAAAS2AAAEtgAAAw0AAAS3AAAEtwAAA1gAAAS6AAAEugAAAw4AAAS7AAAEuwAAA1kAAATAAAAEwQAAAw8AAATCAAAEwgAAA1oAAATPAAAEzwAAA1sAAATQAAAE0AAAAxEAAATRAAAE0QAAA1wAAATUAAAE1AAAAxIAAATVAAAE1QAAA10AAATWAAAE1gAAAxMAAATXAAAE1wAAA14AAATYAAAE2AAAAxQAAATZAAAE2QAAA18AAATiAAAE4gAAAxUAAATjAAAE4wAAA2AAAATmAAAE5gAAAxYAAATnAAAE5wAAA2EAAAToAAAE6AAAAxcAAATpAAAE6QAAA2IAAATuAAAE7gAAAxgAAATvAAAE7wAAA2MAAATyAAAE8gAAAxkAAATzAAAE8wAAA2QAAB1DAAAdQwAABCkAAB1HAAAdRwAABCoAAB1IAAAdSQAABCwAAB1NAAAdTQAABC8AAB1PAAAdTwAABDMAAB1QAAAdUAAABDUAAB1SAAAdUgAABDcAAB1WAAAdVgAABDgAAB1XAAAdWAAABDwAAB1bAAAdWwAABD4AAB2cAAAdnAAABCsAAB2gAAAdoAAABC4AAB27AAAduwAABEIAAB4GAAAeBgAAAFEAAB4HAAAeBwAAAR4AAB4MAAAeDAAAAFgAAB4NAAAeDQAAASUAAB4OAAAeDgAAAFkAAB4PAAAeDwAAASYAAB4QAAAeEAAAAFoAAB4RAAAeEQAAAScAAB4WAAAeFgAAAG4AAB4XAAAeFwAAAToAAB4gAAAeIAAAAHUAAB4hAAAeIQAAAUEAAB4kAAAeJAAAAHoAAB4lAAAeJQAAAUUAAB4mAAAeJgAAAHkAAB4nAAAeJwAAAUQAAB4oAAAeKAAAAHsAAB4pAAAeKQAAAUcAAB4qAAAeKgAAAHwAAB4rAAAeKwAAAUgAAB4yAAAeMgAAAIwAAB4zAAAeMwAAAVgAAB40AAAeNAAAAI0AAB41AAAeNQAAAVkAAB42AAAeNgAAAJEAAB43AAAeNwAAAV4AAB44AAAeOAAAAJIAAB45AAAeOQAAAV8AAB46AAAeOgAAAJMAAB47AAAeOwAAAWAAAB4+AAAePgAAAJYAAB4/AAAePwAAAWMAAB5AAAAeQAAAAJcAAB5BAAAeQQAAAWQAAB5CAAAeQgAAAJgAAB5DAAAeQwAAAWUAAB5EAAAeRAAAAJ4AAB5FAAAeRQAAAWsAAB5GAAAeRgAAAJ8AAB5HAAAeRwAAAWwAAB5IAAAeSAAAAKAAAB5JAAAeSQAAAW0AAB5SAAAeUgAAALgAAB5TAAAeUwAAAYAAAB5YAAAeWAAAAL4AAB5ZAAAeWQAAAY0AAB5aAAAeWgAAAMAAAB5bAAAeWwAAAY4AAB5cAAAeXAAAAMEAAB5dAAAeXQAAAY8AAB5eAAAeXgAAAMIAAB5fAAAeXwAAAZAAAB5gAAAeYAAAAMkAAB5hAAAeYQAAAZcAAB5iAAAeYgAAAMoAAB5jAAAeYwAAAZgAAB5mAAAeZgAAAMYAAB5nAAAeZwAAAZQAAB5sAAAebAAAAM8AAB5tAAAebQAAAZ4AAB5uAAAebgAAANAAAB5vAAAebwAAAZ8AAB5+AAAefgAAAOkAAB5/AAAefwAAAbkAAB6AAAAegAAAAOoAAB6BAAAegQAAAboAAB6CAAAeggAAAOsAAB6DAAAegwAAAbsAAB6EAAAehAAAAO0AAB6FAAAehQAAAb0AAB6OAAAejgAAAPIAAB6PAAAejwAAAcIAAB6QAAAekAAAAPkAAB6RAAAekQAAAckAAB6SAAAekgAAAPoAAB6TAAAekwAAAcoAAB6UAAAelAAAAPsAAB6VAAAelQAAAcsAAB6WAAAelgAAAUYAAB6XAAAelwAAAaAAAB6eAAAengAAAMsAAB6gAAAeoAAAAEEAAB6hAAAeoQAAAQ4AAB6iAAAeogAAAEIAAB6jAAAeowAAAQ8AAB6kAAAepAAAAEMAAB6lAAAepQAAARAAAB6mAAAepgAAAEQAAB6nAAAepwAAAREAAB6oAAAeqAAAAEUAAB6pAAAeqQAAARIAAB6qAAAeqgAAAEYAAB6rAAAeqwAAARMAAB6sAAAerAAAAEcAAB6tAAAerQAAARQAAB6uAAAergAAAEgAAB6vAAAerwAAARUAAB6wAAAesAAAAEkAAB6xAAAesQAAARYAAB6yAAAesgAAAEoAAB6zAAAeswAAARcAAB60AAAetAAAAEsAAB61AAAetQAAARgAAB62AAAetgAAAEwAAB63AAAetwAAARkAAB64AAAeuAAAAGYAAB65AAAeuQAAATIAAB66AAAeugAAAGcAAB67AAAeuwAAATMAAB68AAAevAAAAGgAAB69AAAevQAAATQAAB6+AAAevgAAAGkAAB6/AAAevwAAATUAAB7AAAAewAAAAGoAAB7BAAAewQAAATYAAB7CAAAewgAAAGsAAB7DAAAewwAAATcAAB7EAAAexAAAAGwAAB7FAAAexQAAATgAAB7GAAAexgAAAG0AAB7HAAAexwAAATkAAB7IAAAeyAAAAIcAAB7JAAAeyQAAAVIAAB7KAAAeygAAAIgAAB7LAAAeywAAAVMAAB7MAAAezAAAAKsAAB7NAAAezQAAAXgAAB7OAAAezgAAAKwAAB7PAAAezwAAAXkAAB7QAAAe0AAAAK0AAB7RAAAe0QAAAXoAAB7SAAAe0gAAAK4AAB7TAAAe0wAAAXsAAB7UAAAe1AAAAK8AAB7VAAAe1QAAAXwAAB7WAAAe1gAAALAAAB7XAAAe1wAAAX0AAB7YAAAe2AAAALEAAB7ZAAAe2QAAAX4AAB7aAAAe2gAAALMAAB7bAAAe2wAAAYIAAB7cAAAe3AAAALQAAB7dAAAe3QAAAYMAAB7eAAAe3gAAALUAAB7fAAAe3wAAAYQAAB7gAAAe4AAAALYAAB7hAAAe4QAAAYUAAB7iAAAe4gAAALcAAB7jAAAe4wAAAYYAAB7kAAAe5AAAAOEAAB7lAAAe5QAAAbEAAB7mAAAe5gAAAOIAAB7nAAAe5wAAAbIAAB7oAAAe6AAAAOQAAB7pAAAe6QAAAbQAAB7qAAAe6gAAAOUAAB7rAAAe6wAAAbUAAB7sAAAe7AAAAOYAAB7tAAAe7QAAAbYAAB7uAAAe7gAAAOcAAB7vAAAe7wAAAbcAAB7wAAAe8AAAAOgAAB7xAAAe8QAAAbgAAB7yAAAe8gAAAO4AAB7zAAAe8wAAAb4AAB70AAAe9AAAAPMAAB71AAAe9QAAAcMAAB72AAAe9gAAAPQAAB73AAAe9wAAAcQAAB74AAAe+AAAAPUAAB75AAAe+QAAAcUAAB+9AAAfvQAAArYAAB++AAAfvgAAArUAAB+/AAAfvwAAArcAAB/AAAAfwAAAAsEAAB/BAAAfwQAAAsQAAB/NAAAfzQAAArsAAB/OAAAfzgAAAr0AAB/PAAAfzwAAAr8AAB/dAAAf3QAAArwAAB/eAAAf3gAAAr4AAB/fAAAf3wAAAsAAAB/tAAAf7gAAAsIAAB/vAAAf7wAAArkAAB/9AAAf/QAAAroAAB/+AAAf/gAAArgAACAHAAAgBwAABXAAACAQAAAgEAAAA6kAACASAAAgEgAAA6wAACATAAAgFAAAA6oAACAVAAAgFQAAA60AACAWAAAgFgAAA9AAACAXAAAgFwAAA74AACAYAAAgGQAAA5wAACAaAAAgGgAAA6AAACAbAAAgGwAAA6IAACAcAAAgHQAAA54AACAeAAAgHgAAA6EAACAgAAAgIQAAA8wAACAiAAAgIgAAA68AACAmAAAgJgAAA5UAACAvAAAgLwAABhMAACAwAAAgMAAABGwAACAyAAAgMwAABJYAACA1AAAgNQAABJgAACA5AAAgOgAAA6MAACA8AAAgPAAAA9EAACA9AAAgPQAAA9UAACA+AAAgPwAAA78AACBEAAAgRAAABGgAACBHAAAgRwAAA9IAACBIAAAgSAAAA9QAACBJAAAgSQAAA9MAACBwAAAgcAAAA+4AACBxAAAgcQAABDEAACB0AAAgeQAAA/IAACB9AAAgfgAAA/gAACB/AAAgfwAABDYAACCAAAAgiQAAA/wAACCNAAAgjgAABAYAACCUAAAglAAABEYAACChAAAgoQAABFgAACCjAAAgowAABGcAACCkAAAgpAAABFkAACCmAAAgpwAABFoAACCpAAAgqQAABFwAACCrAAAgqwAABF0AACCsAAAgrAAABFUAACCuAAAgrgAABGQAACCxAAAgsgAABF4AACC0AAAgtQAABGAAACC4AAAguAAABGUAACC5AAAgugAABGIAACC9AAAgvQAABGYAACEFAAAhBQAABKYAACETAAAhEwAABKcAACEWAAAhFgAAA2sAACEXAAAhFwAAA+IAACEgAAAhIAAAA+UAACEiAAAhIgAAA+QAACEmAAAhJgAABKAAACEuAAAhLgAABKgAACFQAAAhUAAABHgAACFRAAAhUgAABH0AACFTAAAhWgAABHAAACFbAAAhXgAABHkAACGJAAAhiQAABH8AACGQAAAhkwAABKkAACGUAAAhlQAABLUAACGWAAAhmQAABK0AACGoAAAhqAAABLcAACHQAAAh0wAABLEAACIAAAAiAAAABKEAACICAAAiAgAABJoAACIDAAAiAwAABKIAACIGAAAiBgAABJ8AACIPAAAiDwAABKUAACIRAAAiEQAABKQAACISAAAiEgAABIEAACIVAAAiFQAABGkAACIZAAAiGQAABIQAACIaAAAiGgAABJ4AACIeAAAiHgAABJQAACIfAAAiHwAABJMAACIpAAAiKQAABJIAACIrAAAiKwAABJsAACI3AAAiNwAABKMAACJIAAAiSAAABI8AACJgAAAiYAAABI0AACJhAAAiYQAABIYAACJkAAAiZQAABIkAACMCAAAjAgAABN4AACMQAAAjEAAABJEAACMcAAAjHwAAA9cAACMgAAAjIQAABJwAACUAAAAlnwAABXMAACWgAAAloQAABLoAACWqAAAlqwAAA7EAACWsAAAlrAAAA7wAACWyAAAlswAABL4AACW0AAAltQAA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EREEBhgrNxEzETMVz7r+zwMZ/aG6AAAAAAH/0QD9AVsD6AAFAB5AGwACAQKFAAEAAAFXAAEBAF8AAAEATxEREAMGGSslITUhETMBW/52ASxe/V4CjQAAAAAB/9EAzwFbA+gABQAeQBsAAgEChQABAAABVwABAQBfAAABAE8RERADBhkrJSE1IREzAVv+dgEsXs+6Al8AAAAAAf/RAP0BiQPoAAUAJEAhAAEAAYUAAAICAFcAAAACXwMBAgACTwAAAAUABRERBAYYKyc1MxEzES/+uv1eAo39FQAAAAAB/9EAzwGJA+gABQAkQCEAAQABhQAAAgIAVwAAAAJfAwECAAJPAAAABQAFEREEBhgrJzUzETMRL/66z7oCX/znAAAAAAEA/f5wAocD6AAHACRAIQACAwKFAAEAAYYAAwAAA1cAAwMAXwAAAwBPEREREAQGGislIREjETMRIQKH/tReXgEs/f1zBXj9cwAAAAABAP3+cAKHA+gABwAkQCEAAgMChQABAAGGAAMAAANXAAMDAF8AAAMATxERERAEBhorJSERIxEzESECh/7UXl4BLM/9oQV4/aEAAAAAAQDP/nAChwPoAAkAJkAjAAMEA4UAAQABhgAEAAAEVwAEBABfAgEABABPERERERAFBhsrJSERIxEjETMRMwKH/tReLrr+/f1zAo0C6/1zAAABAM/+cAKHA+gACQAnQCQAAwIDhQABAAGGBAECAAACVwQBAgIAXwAAAgBPERERERAFBhsrJSMRIxEzETMRIQKH/rouXgEs/f1zAusCjf1zAAEAz/5wAocD6AAHACRAIQACAwKFAAEAAYYAAwAAA1cAAwMAXwAAAwBPEREREAQGGislIxEjETMRMwKH/rq6/v39cwV4/XMAAAEAz/5wAocD6AAJACZAIwADBAOFAAEAAYYABAAABFcABAQAXwIBAAQATxEREREQBQYbKyUhESMRIxEzETMCh/7UXi66/s/9oQJfAxn9oQAAAQDP/nAChwPoAAkAJ0AkAAMCA4UAAQABhgQBAgAAAlcEAQICAF8AAAIATxEREREQBQYbKyUjESMRMxEzESECh/66Ll4BLM/9oQMZAl/9oQABAM/+cAKHA+gABwAkQCEAAgMChQABAAGGAAMAAANXAAMDAF8AAAMATxERERAEBhorJSMRIxEzETMCh/66uv7P/aEFeP2hAAAB/9H+cAFbA+gABwAkQCEAAwIDhQAAAQCGAAIBAQJXAAICAV8AAQIBTxERERAEBhorASMRITUhETMBW17+1AEsXv5wAo1eAo0AAAAAAf/R/nABWwPoAAcAJEAhAAMCA4UAAAEAhgACAQECVwACAgFfAAECAU8REREQBAYaKwEjESE1IREzAVte/tQBLF7+cAJfugJfAAAAAAH/0f5wAYkD6AAJACZAIwADAgOFAAABAIYAAgEBAlcAAgIBXwQBAQIBTxEREREQBQYbKwEjESE1MxEzESMBW17+1P66Lv5wAo1eAo39FQAAAf/R/nABiQPoAAkAJ0AkAAMCA4UAAAEAhgQBAgEBAlcEAQICAV8AAQIBTxEREREQBQYbKwEjESM1IREzETMBibr+ASxeLv5wAo1eAo39cwAB/9H+cAGJA+gABwAkQCEAAwIDhQAAAQCGAAIBAQJXAAICAV8AAQIBTxERERAEBhorASMRIzUzETMBibr+/rr+cAKNXgKNAAAB/9H+cAGJA+gACQAmQCMAAwIDhQAAAQCGAAIBAQJXAAICAV8EAQECAU8REREREAUGGysBIxEhNTMRMxEjAVte/tT+ui7+cAJfugJf/OcAAAH/0f5wAYkD6AAJACdAJAADAgOFAAABAIYEAQIBAQJXBAECAgFfAAECAU8REREREAUGGysBIxEjNSERMxEzAYm6/gEsXi7+cAJfugJf/aEAAf/R/nABiQPoAAcAJEAhAAMCA4UAAAEAhgACAQECVwACAgFfAAECAU8REREQBAYaKwEjESM1MxEzAYm6/v66/nACX7oCXwAAAf/R/nAChwFbAAcAIEAdAAEAAYYAAwAAA1cAAwMAXwIBAAMATxERERAEBhorJSERIxEhNSECh/7UXv7UArb9/XMCjV4AAAAAAf/R/nAChwGJAAkAKEAlAAABAIYAAgMBAlcAAwAEAQMEZwACAgFfAAECAU8REREREAUGGysBIxEhNSEVIRUhAVte/tQBigEs/tT+cAJfui5eAAAAAf/R/nAChwGJAAkAKEAlAAEAAYYABAMABFcAAwACAAMCZwAEBABfAAAEAE8REREREAUGGyslIREjESE1ITUhAof+1F7+1AEsAYrP/aECjV4uAAAAAf/R/nAChwGJAAcAIEAdAAEAAYYAAwAAA1cAAwMAXwIBAAMATxERERAEBhorJSERIxEhNSECh/7UXv7UArbP/aECX7oAAAAAAf/R/nAChwFbAAcAIEAdAAEAAYYAAwAAA1cAAwMAXwIBAAMATxERERAEBhorJSMRIxEjNSECh/66/gK2/f1zAo1eAAAB/9H+cAKHAYkACQAoQCUAAQIBhgADBAIDVwAEAAACBABnAAMDAl8AAgMCTxEREREQBQYbKyUjESMRIzUhFTMCh/66/gG4/v39cwJfui4AAAH/0f5wAocBiQAJAChAJQABAAGGAAQDAARXAAMAAgADAmcABAQAXwAABABPERERERAFBhsrJSMRIxEjNTM1IQKH/rr+/gG4z/2hAo1eLgAAAf/R/nAChwGJAAcAIEAdAAEAAYYAAwAAA1cAAwMAXwIBAAMATxERERAEBhorJSMRIxEjNSECh/66/gK2z/2hAl+6AAAB/9EA/QKHA+gABwAhQB4AAgEChQMBAQAAAVcDAQEBAF8AAAEATxERERAEBhorJSE1IREzESECh/1KASxeASz9XgKN/XMAAAAB/9EAzwKHA+gACQAoQCUAAwIDhQACBAECVwAEAAABBABnAAICAV8AAQIBTxEREREQBQYbKyUhFSE1IREzESECh/7U/nYBLF4BLP0uugJf/XMAAAAB/9EAzwKHA+gACQAoQCUAAwQDhQAEAgAEVwACAAEAAgFnAAQEAF8AAAQATxEREREQBQYbKyUhNSE1IREzESECh/52/tQBLF4BLM8uXgKN/aEAAAAB/9EAzwKHA+gABwAhQB4AAgEChQMBAQAAAVcDAQEBAF8AAAEATxERERAEBhorJSE1IREzESECh/1KASxeASzPugJf/aEAAAAB/9EA/QKHA+gABwAhQB4AAgEChQMBAQAAAVcDAQEBAF8AAAEATxERERAEBhorJSE1MxEzETMCh/1K/rr+/V4Cjf1zAAH/0QDPAocD6AAJAC5AKwABAAGFAAACBABXAAIAAwQCA2cAAAAEXwUBBAAETwAAAAkACREREREGBhorJzUzETMRMxUjFS/+uv7+z7oCX/1zXi4AAAH/0QDPAocD6AAJAC5AKwACAwKFAAMBBANXAAEAAAQBAGcAAwMEXwUBBAMETwAAAAkACREREREGBhorNzUjNTMRMxEzFc/+/rr+zy5eAo39oboAAAH/0QDPAocD6AAHACFAHgACAQKFAwEBAAABVwMBAQEAXwAAAQBPEREREAQGGislITUzETMRMwKH/Ur+uv7PugJf/aEAAf/R/nAChwPoAAsAKUAmAAQDBIUAAQABhgUBAwAAA1cFAQMDAF8CAQADAE8RERERERAGBhwrJSERIxEhNSERMxEhAof+1F7+1AEsXgEs/f1zAo1eAo39cwAAAAAB/9H+cAKHA+gACwAuQCsABAMEhQABAgGGAAMFAgNXAAUAAAIFAGcAAwMCXwACAwJPEREREREQBgYcKyUhESMRITUhETMRIQKH/tRe/tQBLF4BLP39cwJfugJf/XMAAAAB/9H+cAKHA+gACwAuQCsABAUEhQABAAGGAAUDAAVXAAMAAgADAmcABQUAXwAABQBPEREREREQBgYcKyUhESMRITUhETMRIQKH/tRe/tQBLF4BLM/9oQKNXgKN/aEAAAAB/9H+cAKHA+gACwApQCYABAMEhQABAAGGBQEDAAADVwUBAwMAXwIBAAMATxEREREREAYGHCslIREjESE1IREzESECh/7UXv7UASxeASzP/aECX7oCX/2hAAAAAAH/0f5wAocD6AALAClAJgAEAwSFAAEAAYYFAQMAAANXBQEDAwBfAgEAAwBPEREREREQBgYcKyUhESMRITUzETMRMwKH/tRe/tT+uv79/XMCjV4Cjf1zAAAB/9H+cAKHA+gACwApQCYABAMEhQABAAGGBQEDAAADVwUBAwMAXwIBAAMATxEREREREAYGHCslIxEjESM1IREzESECh/66/gEsXgEs/f1zAo1eAo39cwAAAf/R/nAChwPoAAsAKUAmAAQDBIUAAQABhgUBAwAAA1cFAQMDAF8CAQADAE8RERERERAGBhwrJSMRIxEjNTMRMxEzAof+uv7+uv79/XMCjV4Cjf1zAAAAAAH/0f5wAocD6AANADBALQAEAwSFAAEAAYYAAwUAA1cABQAGAAUGZwADAwBfAgEAAwBPEREREREREAcGHSslIxEjESE1MxEzETMVIwGJLl7+1P66/v7P/aECX7oCX/1zXgAAAAAB/9H+cAKHA+gADQAwQC0ABQYFhQABAAGGAAYEAAZXAAQAAwAEA2cABgYAXwIBAAYATxERERERERAHBh0rJSERIxEjNSM1MxEzETMCh/7UXi7+/rr+z/2hAl8uXgKN/aEAAAAAAf/R/nAChwPoAA0AMUAuAAMCA4UAAAEAhgQBAgUBAlcABQAGAQUGZwQBAgIBXwABAgFPEREREREREAcGHSsBIxEjNSERMxEzFTMVIwGJuv4BLF4u/v7+cAJfugJf/aEuXgAAAAH/0f5wAocD6AANADFALgAFBAWFAAEAAYYGAQQDAARXAAMAAgADAmcGAQQEAF8AAAQATxERERERERAHBh0rJSMRIxEjNTM1MxEzESECh/66/v4uXgEsz/2hAo1eLgJf/aEAAAAB/9H+cAKHA+gACwApQCYABAMEhQABAAGGBQEDAAADVwUBAwMAXwIBAAMATxEREREREAYGHCslIREjESE1MxEzETMCh/7UXv7U/rr+z/2hAl+6Al/9oQAAAf/R/nAChwPoAAsAKUAmAAQDBIUAAQABhgUBAwAAA1cFAQMDAF8CAQADAE8RERERERAGBhwrJSMRIxEjNSERMxEhAof+uv4BLF4BLM/9oQJfugJf/aEAAAH/0f5wAocD6AALAC5AKwAEAwSFAAECAYYAAwUCA1cABQAAAgUAZwADAwJfAAIDAk8RERERERAGBhwrJSMRIxEjNTMRMxEzAof+uv7+uv79/XMCX7oCX/1zAAAAAf/R/nAChwPoAAsALkArAAQFBIUAAQABhgAFAwAFVwADAAIAAwJnAAUFAF8AAAUATxEREREREAYGHCslIxEjESM1MxEzETMCh/66/v66/s/9oQKNXgKN/aEAAAAB/9H+cAKHA+gACwApQCYABAMEhQABAAGGBQEDAAADVwUBAwMAXwIBAAMATxEREREREAYGHCslIxEjESM1MxEzETMCh/66/v66/s/9oQJfugJf/aEAAAAAAgBLAP0CDQFbAAMABwAqQCcCAQABAQBXAgEAAAFfBQMEAwEAAU8EBAAABAcEBwYFAAMAAxEGBhcrJTUzFSE1MxUBd5b+Ppb9Xl5eXgAAAAACAEsAzwINAYkAAwAHACpAJwIBAAEBAFcCAQAAAV8FAwQDAQABTwQEAAAEBwQHBgUAAwADEQYGFyslNTMVITUzFQF3lv4+ls+6urq6AAAAAAIA/f9qAVsC7gADAAcAKkAnAAABAIUEAQECAYUAAgMChQUBAwN2BAQAAAQHBAcGBQADAAMRBgYXKxMRMxEDETMR/V5eXgHCASz+1P2oASz+1AAAAAIAz/9qAYkC7gADAAcAKkAnAAABAIUEAQECAYUAAgMChQUBAwN2BAQAAAQHBAcGBQADAAMRBgYXKxMRMxEDETMRz7q6ugHCASz+1P2oASz+1AAAAAL/0QCgAocBuAADAAcAL0AsAAAEAQECAAFnAAIDAwJXAAICA18FAQMCA08EBAAABAcEBwYFAAMAAxEGBhcrAzUhFQU1IRUvArb9SgK2AVtdXbtdXQAAAAACAKD+cAG4A+gAAwAHACJAHwIBAAEAhQUDBAMBAXYEBAAABAcEBwYFAAMAAxEGBhcrAREzESERMxEBW13+6F3+cAV4+ogFePqIAAAAAQD9/nAChwG4AAkAKEAlAAEAAYYAAgADBAIDZwAEAAAEVwAEBABfAAAEAE8REREREAUGGyslIREjESEVIRUhAof+1F4Biv7UASyg/dADSF1eAAAAAQCg/nAChwFbAAkAKEAlBQQCAQABhgACAAACVwACAgBfAwEAAgBPAAAACQAJEREREQYGGisBESMRIxEhFSMRAVteXQHnz/5wAo39cwLrXv1zAAAAAgCg/nAChwG4AAUACwAqQCcEAQEDAYYAAgAABQIAZwAFAwMFVwAFBQNfAAMFA08RERERERAGBhwrASERIxEhESMRIxEhAof+dl0B589dASwBW/0VA0j+6P3QAo0AAAAAAf/R/nABWwG4AAkAKEAlAAABAIYABAADAgQDZwACAQECVwACAgFfAAECAU8REREREAUGGysBIxEhNSE1ITUhAVte/tQBLP7UAYr+cAIwXV5dAAAAAf/R/nABuAFbAAkAKEAlBQQCAQABhgADAAADVwADAwBfAgEAAwBPAAAACQAJEREREQYGGisBESMRIxEjNSERAVteXc8B5/5wAo39cwKNXv0VAAAAAv/R/nABuAG4AAUACwAqQCcDAQAEAIYAAgABBQIBZwAFBAQFVwAFBQRfAAQFBE8RERERERAGBhwrASMRITUhAyMRIzUhAbhd/nYB57tdzwEs/nAC6138uAIwXQABAP0AoAKHA+gACQAuQCsAAAEAhQABAAIDAQJnAAMEBANXAAMDBF8FAQQDBE8AAAAJAAkRERERBgYaKzcRMxEhFSEVIRX9XgEs/tQBLKADSP3QXV5dAAAAAQCgAP0ChwPoAAkAKUAmAgEAAQCFAwEBBAQBVwMBAQEEXwUBBAEETwAAAAkACREREREGBhorNxEzETMRMxEz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BiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgHQFQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUBOA4KCg4OCgoOyA4KCg4OCgoOyA4KCg4OCgoOAegVDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQE4DgoKDg4KCg7IDgoKDg4KCg7IDgoKDg4KCg4B6BUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VATgOCgoODgoKDsgOCgoODgoKDsgOCgoODgoKDgHoFQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUBOA4KCg4OCgoOyA4KCg4OCgoOyA4KCg4OCgoOAegVDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQE4DgoKDg4KCg7IDgoKDg4KCg7IDgoKDg4KCg4B6BUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VATgOCgoODgoKDsgOCgoODgoKDsgOCgoODgoKDgHoFQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUBOA4KCg4OCgoOyA4KCg4OCgoOyA4KCg4OCgoOA4QPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODloPFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUKDg4KCg4OCgoODgoKDg4KCg4OCgoODgAAAAAq/9z+TAIqA7oACwAXACMALwA7AEcAUwBfAGsAdwCDAI8AmwCnALMAvwDLANcA4wDvAPsBBwETAR8BKwE3AUMBTwFbAWcBcwF/AYsBlwGjAa8BuwHHAdMB3wHrAfcAAAE0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgG+IBYXHx8XFiDIIBYXHx8XFiDIIBYXHx8XFiABPhUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VAeIgFhcfHxcWIMggFhcfHxcWIMggFhcfHxcWIAE+FQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUB4iAWFx8fFxYgyCAWFx8fFxYgyCAWFx8fFxYgAT4VDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQHiIBYXHx8XFiDIIBYXHx8XFiDIIBYXHx8XFiABPhUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VAeIgFhcfHxcWIMggFhcfHxcWIMggFhcfHxcWIAE+FQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUB4iAWFx8fFxYgyCAWFx8fFxYgyCAWFx8fFxYgAT4VDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQHiIBYXHx8XFiDIIBYXHx8XFiDIIBYXHx8XFiABPhUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VA4QXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFVUXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4PFRUPDxUVDw8VFQ8PFRUPDxUVDw8VFQAAAAAq/8r+OgJFA9UACwAXACMALwA7AEcAUwBfAGsAdwCDAI8AmwCnALMAvwDLANcA4wDvAPsBBwETAR8BKwE3AUMBTwFbAWcBcwF/AYsBlwGjAa8BuwHHAdMB3wHrAfcAAAE0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgU0NjMyFhUUBiMiJic0NjMyFhUUBiMiJic0NjMyFhUUBiMiJgGjLyIiLy8iIi/ILyIiLy8iIi/ILyIiLy8iIi8BRyAWFx8fFxYgyCAWFx8fFxYgyCAWFx8fFxYgAdkvIiIvLyIiL8gvIiIvLyIiL8gvIiIvLyIiLwFHIBYXHx8XFiDIIBYXHx8XFiDIIBYXHx8XFiAB2S8iIi8vIiIvyC8iIi8vIiIvyC8iIi8vIiIvAUcgFhcfHxcWIMggFhcfHxcWIMggFhcfHxcWIAHZLyIiLy8iIi/ILyIiLy8iIi/ILyIiLy8iIi8BRyAWFx8fFxYgyCAWFx8fFxYgyCAWFx8fFxYgAdkvIiIvLyIiL8gvIiIvLyIiL8gvIiIvLyIiLwFHIBYXHx8XFiDIIBYXHx8XFiDIIBYXHx8XFiAB2S8iIi8vIiIvyC8iIi8vIiIvyC8iIi8vIiIvAUcgFhcfHxcWIMggFhcfHxcWIMggFhcfHxcWIAHZLyIiLy8iIi/ILyIiLy8iIi/ILyIiLy8iIi8BRyAWFx8fFxYgyCAWFx8fFxYgyCAWFx8fFxYgA4QiLy8iIi8vIiIvLyIiLy8iIi8vIiIvL0IXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4iLy8iIi8vIiIvLyIiLy8iIi8vIiIvL0IXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4iLy8iIi8vIiIvLyIiLy8iIi8vIiIvL0IXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4iLy8iIi8vIiIvLyIiLy8iIi8vIiIvL0IXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4iLy8iIi8vIiIvLyIiLy8iIi8vIiIvL0IXHx8XFiAgFhcfHxcWICAWFx8fFxYgIE4iLy8iIi8vIiIv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AEQARABEABoANAA0ADQAWABYAFgAWABYAFgAWABY/+MAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgALAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOQA5AAsAigBhAIoAigB6AHoAOwBDAEMAQwBDAEMAQwBDAEMAUQBiAEAAQABAAEAAQABAAEAASQBJAEkASQBJAEkASQBJAEkASQBJAEkASQBJAEkASQBJAEkASQBJAEkASQBJAC4ABwAHAAcABwAtAC0ALQAtAC0ALQAtAC0ARwBHAEcARwBHAEcAOQBYAFgANABW//MATABZAFgAWAA6AEwAOAA4AD0AOAByAEEAEQBWADoAOQA0ADkAOABKAC4ANQBJAFgAWABYAFcAVAAwABgARABDAEQARQCNACYAJgA0//gAWABaADkAHQAnADwAPAA8AIoAigBcAFwAQwA0ADQANQBA//8ALwBJAC4ABwAsADMARwBHADn//gAVACUAQgBUAEIATABQADgATgA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAMQA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOABfAF8AXwBfAF8AXwBfAF8AXwBfAF8AXwBfAF8AVwBfAFcAXwAwAF8AXwBfAF8AXwBfAF8AXwAp//kAXwBfABoAXACAACgAbQA/AEsALQBaAFoAIwBEAE4ARQAtAEsAXwBIACcAIQAXAC0AJgAkABwAEgASABIAWgASACEAIQASADUAWAApAD4AVgBsAFYARABMAF0AMgBPACkAUwA8ABcAWAA4AD4ASwAnADQALAAfAFYAWABJACcAIQA1AFYAVgBMAEwAPABLAEsAHwBMAEsAXQA6AFcAigA9AMEA0gDSAPsA5gEEAOkAggEFAPIA4wDjANgAyQEEAIYAgQCGAIsAmwCbAHsAiACCAJEA4ADfAO8A6QCfAJ4AnwChALIAsgAaAFwAXACAABMAbQABADoASgBKAF0AAABEAEsALQBLAF8APgAnACkAFwAtAEsAPAAlACQAFQAyAFwAKgApABcAbQBtAAkAgAA/AD8AWgBaAEv/9gAlAAkAXQBKACkASAAVAC0AHgCAADkAAQA6AF0AFQBLAD4AIQAhAC0APABTAFoAAQAa//4AbQA4AEoALQAtACkAKQBMAEcAYwCKACQAQQAFADoAXQBdAGUAGQA5AFgAOABYAFgATAA+AC0AHQA5AFgAUgA0ADQAIgA+AHIAOwApADIAQQBBABAAigBNAEMAVwBXADT/9wA0ABAAZQBdAC0AXwAmADkAPQCXAEIABQA6AGUAIABYAEwALgAuADkAUgBYAAUARABMABEAQQBBAF0AOAA5AC0ALQA4ADgAUABfAF8AX//7ACUAQwBdAEAANQAmADUASQBEAEIAPwBDAF0AQwBdAEAANQAmADUASgBEAEIAPwBDAF0AQwBdAEAANQAmADUASQBEAEIAPwBDAF0A0gDBANIAwQAXANwA3ABqAHUA7QB2AMsA1QBUAF4A1QBeAM0AvwDOAEgAVwBRAFEAUQBQAAAAUAAAANIAkwCGAKIAlACHAG4AogCUAIcAbgCGAG4AlQAAADwAPAA+/2UAyQB7ANsAZAB0AGQAXQEAAF0BAABPAHUAdQBWAEIAkgBVAAwAUAAMAFYAbgDbAGQA2wBkALAAZADbAGQA2wBkABsAGwBt//kACQAtAC0AUwBjAIMAgwCDAFAAiQCsAI4AigCRAIoAkwCbAJQAjwDoAM4A9wDwAIkArACOAIoAkQCKAJMAmwCUAI8A6ADOAPcA8ACeAM0AqQCqAKkAqgCsALUArACqAOcA0QD3APAAngDNAKkAqgCpAKoArAC1AKwAqgDnANEA9wDwAJ8AhwCMAJ8ApwCyAIcAjwDCAJEAqgCuAIoAtQDAAEEAqgCMAKcAhwDsAJ4AoACbAIUAMACWAIkAkwCPAI8AjwCNAKoAjgCcAIcAhwCrAPcA3ACmAD0ANABQAEsALwA2AG0AMQBcAEsAKQAlABcAaQAkAFAAOwBcAGcAJgAyADIAJQBBABkAGQAZABkALAAZABkAHAAZABkAGQAZABkAGQAZABkAGQAZABkAGQAZABkASwAZAFEAUQBhAFEAzwBRAFEAdwBoAFEAUQBRAGkAUQBGAEYAUQBRAFoAUf/6AKoA+gCaAOYATwBIALABAgCSADcAKAAkABoARQBGAEMALQAaAGkAGgAQACAAHgAgAGAATABSAGcAEAAgAB4AIP/0AFIAPABGADgAUwBEAEQAHgA/AD8AQABAAD8APwAsACwAE//mAD4ANP/m/+b/9wBHAAAABgAGAAIABgAFABn/vf/f//n/4gApADj/8f/6AFsALQD6AMsA1QDhALsAnADAAMAAdgCaAOgAigCKAPIAowDoAJoA8gB7AIoAowCMALkAvgDiAMkAzgAzAJoAqwDJAOgA4QEEAIoAkwB7AHYAowCiAKMAogCMAIsAlgCOAOIA6QCKAJMA4wDjAIYAjAC5AMcAvgCzAIoAkwD6AGAAXgCMAJYA8QDYAPMA4wDdAMsA3QEjANsAtQC1ALUAtQDiAIoAuQDJANoAyQDJAM4AzwEDAK8AigCMAIwAewCjAGUA7ACvAK8AfADJAHsAdgEF/zv/ZQCXAJIAggCXAJIAiACRAJcAkgCXAJIAogClACwATgCiAKUAoACZAIwAlgCMAJYAjACWAJkAmQCoAJ8AowCiAIoAjgCLAIEAmwCGAIYAmwAAAAAAAAAA/9H/0QD9AM8AIQAhAP0AzwATABMA/QDPAP0A/QDPAM//0f/R/9H/0QD9AP0AzwDP/9H/0f/R/9EA/QD9AM8AzwDPAM8AzwDP/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9EASwBLAP0Az//RAKAA/QCgAKD/0f/R/9EA/QCgAKD/0f/R/9EA/QCgAKD/0f/R/9H/0f/R/9H/0f/R/9H/0f/R/9EA/f/R/9EA/QAAAAAAAP/RAP0A/QD9/9EAzwD9AM//0QDP/9EAzwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASz/6P/c/8oAAAINAAABLAAAAAAAAAAAAAABLAAAAAAAAAAAAEcAAAAoAC0AWQBPACkAAP/2AAD/8QAAAAAAAAAAAIgAAACIAAAA+AAAAZwAAAIoAAACjAAAAugAAAM8AAAD6AAABDwAAASQAAAFBAAABVwAAAWYAAAGIAAABogAAAcMAAAHfAAACDAAAAiwAAAJbAAACbAAAAoQAAAKbAAACwgAAAuIAAAL6AAADEQAAA04AAAOWAAADugAABAIAAAQuAAAEWQAABMYAAATsAAAE8gAABPgAAAUYAAAFPAAABWwAAAWQAAAFsQAABecAAAYkAAAGSAAABnUAAAajAAAGyQAABuAAAAcIAAAHJwAAB0kAAAdgAAAHZgAAB2wAAAdyAAAHeAAAB34AAAeEAAAHigAAB5AAAAfVAAAH2wAACBYAAAgcAAAIIgAACCgAAAguAAAINAAACDoAAAhBAAAIRwAACE0AAAhTAAAIWQAACGAAAAiEAAAIigAACJAAAAjDAAAIyQAACM8AAAjVAAAI2wAACOEAAAjnAAAI7QAACPMAAAj5AAAI/wAACQMAAAkmAAAJLAAACTIAAAk4AAAJPgAACUQAAAlKAAAJUAAACVYAAAmQAAAJlgAACZwAAAmiAAAJqAAACa4AAAm0AAAJugAACcEAAAnHAAAJzQAACdMAAAnZAAAJ3wAACeUAAAnrAAAJ8QAACfcAAAouAAAKNAAACjoAAApAAAAKRgAACkwAAApvAAAKdQAACnsAAAqBAAAKhwAACo0AAAqTAAAKmQAACp8AAArUAAAK2gAACuAAAArmAAAK7AAACvIAAAr4AAAK/gAACwQAAAsNAAALEwAACxkAAAsgAAALJgAACz4AAAtHAAALTQAAC1MAAAtZAAALXwAAC2UAAAtrAAALcQAAC3cAAAt9AAALgwAAC4kAAAuPAAALlQAAC5sAAAuhAAALpwAAC60AAAuzAAALuQAAC78AAAv8AAAMAgAADAgAAAwOAAAMFAAADBoAAAwgAAAMJwAADFQAAAxaAAAMYAAADGYAAAxsAAAMcgAADHgAAAypAAAMrwAADNEAAAzXAAAM3QAADOMAAAzpAAAM7wAADPYAAAz8AAANAgAADQgAAA0OAAANFAAADRoAAA0gAAANJgAADSwAAA1oAAANbgAADXQAAA16AAANgAAADYYAAA2fAAANpQAADasAAA2xAAANtwAADb0AAA3DAAANyQAADc8AAA3VAAAN2wAADhAAAA4WAAAOHAAADiIAAA4oAAAOLgAADjQAAA5YAAAOXgAADmQAAA5qAAAOcAAADnYAAA58AAAOggAADogAAA6OAAAOlAAADpoAAA6gAAAOpgAADqwAAA6yAAAOuAAADr4AAA7EAAAOygAADtAAAA7WAAAO3AAADuIAAA7oAAAPCwAADykAAA9VAAAPjwAAD64AAA/RAAAP2QAAD98AAA/lAAAP6wAAD/EAAA/3AAAP/QAAEAMAABAJAAAQZwAAEG0AABC2AAAQvAAAEMIAABDIAAAQzgAAENQAABDaAAAQ4QAAEOcAABDtAAAQ8wAAEPkAABEAAAARSQAAEU8AABFVAAARqgAAEbAAABG2AAARvAAAEcIAABHIAAARzgAAEiUAABIrAAASMQAAEjcAABKQAAASlgAAEpwAABKiAAASqAAAEq4AABK0AAASugAAEwUAABMLAAATEQAAExcAABMdAAATIwAAEykAABMvAAATNQAAEzwAABNCAAATSAAAE04AABNUAAATWgAAE2AAABNmAAATbAAAE3IAABN7AAAThAAAE4oAABOQAAATlgAAE5wAABPOAAAT1AAAE9oAABPgAAAT5gAAE+wAABPyAAAT+AAAE/4AABQEAAAUCgAAFBAAABQgAAAUJgAAFCwAABQyAAAUOAAAFE4AABRWAAAUXAAAFGIAABRoAAAUcgAAFHgAABSjAAAUrAAAFLQAABS8AAAUwgAAFMgAABTOAAAU1AAAFNoAABTgAAAU5gAAFOwAABTyAAAVNQAAFTsAABVBAAAVRwAAFU0AABVTAAAVWQAAFV8AABVlAAAVowAAFakAABWvAAAVtQAAFbsAABXBAAAVxwAAFc4AABXUAAAV2gAAFggAABYOAAAWFAAAFhoAABYgAAAWJgAAFlUAABZbAAAWmgAAFqAAABamAAAWrAAAFrIAABa4AAAWvwAAFsUAABbLAAAW0QAAFtcAABbdAAAW4wAAFukAABbvAAAW9QAAFzwAABdjAAAXaQAAF28AABd1AAAXewAAF4EAABeKAAAXwwAAF8kAABfPAAAX1QAAF9sAABfhAAAX5wAAF+0AABfzAAAX+QAAF/8AABg3AAAYPQAAGEMAABhJAAAYTwAAGFUAABhbAAAYiwAAGJEAABiXAAAYnQAAGKMAABipAAAYrwAAGLUAABi7AAAYwQAAGMcAABjNAAAY0wAAGNkAABjfAAAY5QAAGO4AABj0AAAY+gAAGQAAABkGAAAZDAAAGRIAABkYAAAZHgAAGVIAABmKAAAZyAAAGeQAABooAAAaYQAAGooAABrAAAAa/AAAG1MAABt4AAAbsAAAG/QAABxLAAAcdwAAHLMAABy3AAAc4wAAHR4AAB1NAAAdUQAAHYAAAB2kAAAd9QAAHkIAAB5sAAAelwAAHswAAB7pAAAfGwAAH2cAAB9rAAAfcQAAH4YAAB+MAAAfpAAAH60AAB/vAAAgGwAAIFcAACBmAAAglgAAIL4AACEJAAAhRwAAIYUAACGiAAAhywAAIg8AACJCAAAiZgAAIpgAACLKAAAjBAAAIx0AACM9AAAjXQAAI6QAACPQAAAkCAAAJCsAACRhAAAklwAAJMAAACTzAAAlCgAAJTMAACVcAAAldAAAJaUAACXWAAAmAgAAJpgAACbpAAAnOAAAJ10AACeCAAAnrwAAJ9wAACgEAAAoPQAAKGYAAChqAAAocAAAKHYAACh8AAAoggAAKIgAACiOAAAolAAAKJoAACj2AAAo/AAAKQIAACkIAAApDgAAKRQAACkaAAApIAAAKScAACktAAApMwAAKTkAACk/AAApRgAAKaIAACmmAAAprAAAKbIAACm4AAApvgAAKcQAACnKAAAp0AAAKdYAACncAAAp7wAAKfUAACn7AAAqAQAAKgcAACoNAAAqEwAAKhkAACofAAAqJQAAKisAACoxAAAqNwAAKmMAACqWAAAqrQAAKsgAACr0AAArBwAAKw8AACsVAAArGwAAKyEAACsrAAArMQAAK00AACtWAAArgAAAK4kAACvFAAAryQAAK80AACvkAAAsBgAALAoAACwOAAAsEgAALDwAACxAAAAsRAAALGEAACxlAAAsaQAALI8AACyTAAAsrAAALLAAACzRAAAs1QAALNkAAC0RAAAtFQAALToAAC1qAAAtlAAALbsAAC3fAAAuAwAALgcAAC4tAAAuUQAALlUAAC6JAAAuyAAALv8AAC8eAAAvTwAAL4EAAC+mAAAv2gAAMAMAADAhAAAwTAAAMHAAADClAAAwxAAAMPsAADEcAAAxVwAAMX8AADGnAAAxxwAAMeoAADIUAAAyKgAAMlQAADKDAAAyqQAAMuEAADMRAAAzFQAAM0wAADNSAAAzWAAAM14AADNkAAAzagAAM3AAADN2AAAzfAAAM4IAADOIAAAzjgAAM74AADPlAAA0BAAANBoAADQ1AAA0OQAANEEAADRJAAA0XgAANHMAADR3AAA0gAAANIQAADSIAAA0pQAANKkAADStAAA0sQAANLUAADS5AAA0vQAANMEAADTFAAA0yQAANM0AADTRAAA01QAANNkAADTdAAA04QAANPQAADUHAAA1EAAANRQAADUrAAA1QgAANVkAADVvAAA1nQAANcsAADXPAAA17QAANfEAADX1AAA2JgAANioAADZzAAA2pAAANr4AADbEAAA2+QAANysAADcvAAA3MwAANzcAADc7AAA3PwAAN0MAADdHAAA3ZwAAN5EAADeVAAA3tQAAN9IAADfnAAA4CwAAOCkAADhKAAA4ZgAAOI8AADjFAAA45wAAOOsAADjvAAA5LgAAOTQAADleAAA5YgAAOWYAADlqAAA5bgAAObAAADnoAAA6CAAAOg4AADoUAAA6GgAAOjgAADpcAAA6hQAAOrQAADrHAAA63wAAOz4AADt6AAA7wwAAO/gAADwdAAA8SwAAPE8AADxtAAA8mwAAPMgAADzkAAA86AAAPO4AADz0AAA8+AAAPP4AAD0CAAA9CAAAPQ4AAD0SAAA9GAAAPR4AAD0iAAA9WQAAPYIAAD2SAAA9swAAPbcAAD35AAA+KAAAPkUAAD5LAAA+fwAAPq8AAD7WAAA+6gAAPu4AAD7/AAA/AwAAPwcAAD8YAAA/HAAAP10AAD9hAAA/dwAAP5MAAD+oAAA/wQAAP94AAD/+AABAGAAAQEIAAEB2AABAlwAAQJsAAECfAABA0wAAQNkAAEEDAABBBwAAQQsAAEEPAABBEwAAQWAAAEGCAABBhgAAQYwAAEGSAABBmAAAQa4AAEHPAABB0wAAQgIAAEIUAABCLQAAQnYAAEKlAABC3wAAQxIAAEMrAABDUAAAQ2gAAEOJAABDrQAAQ84AAEPSAABD2AAAQ9wAAEPiAABD5gAAQ+wAAEPwAABD9gAAQ/wAAEQAAABEBgAARAwAAEQQAABEFgAAREUAAERJAABETQAARFEAAESgAABE4gAARQwAAEUsAABFTQAARX0AAEWkAABF2QAARgsAAEYoAABGXwAARo8AAEa2AABG0gAARvwAAEcTAABHMwAAR2UAAEeGAABHsQAAR7UAAEfNAABH0QAASAIAAEgqAABIPwAASGkAAEiBAABIogAASNIAAEjxAABJGwAASU0AAElkAABJmwAAScsAAEn1AABKCgAAShwAAEozAABKPAAASkUAAEprAABKjwAASrIAAErnAABLEwAASysAAEsxAABLSgAAS2gAAEtuAABLdAAAS3wAAEuIAABLpgAAS7EAAEu7AABLwQAAS8cAAEvLAABLzwAAS9MAAEvhAABL7wAAS/0AAEwBAABMCQAATB8AAExBAABMTgAATGIAAExvAABMgwAATI0AAEyaAABMpQAATLYAAEzAAABMzQAATOgAAEz2AABNBgAATR0AAE0tAABNSQAATVgAAE1nAABNgQAATZsAAE3VAABODwAATiIAAE4vAABOQgAATlgAAE5tAABOjgAATrsAAE8DAABPHQAATyMAAE8pAABPfgAAT9gAAFAyAABQawAAUJoAAFCrAABQvAAAUM0AAFDeAABQ9gAAUQ4AAFEmAABRPgAAUU8AAFFgAABRpQAAUeAAAFIhAABSSQAAUo4AAFLpAABTNgAAU20AAFODAABTkQAAU5UAAFOZAABT2gAAU+IAAFPqAABT8gAAU/oAAFQCAABUCgAAVBIAAFQaAABUIgAAVCoAAFQyAABUOgAAVEIAAFRKAABUaAAAVIAAAFSeAABUzAAAVOUAAFUNAABVPQAAVVMAAFWFAABVswAAVcQAAFXVAABV7gAAVgoAAFYoAABWPAAAVloAAFaHAABWoAAAVsgAAFb2AABXCwAAVzwAAFdoAABXdwAAV4YAAFeYAABXrQAAV7UAAFe9AABXxQAAV80AAFfVAABX3QAAV+UAAFftAABX9QAAV/0AAFgFAABYDQAAWBUAAFgdAABYIQAAWCUAAFgpAABYZgAAWKEAAFjDAABY/wAAWSgAAFlJAABZwQAAWd4AAFn7AABaJAAAWjsAAFpXAABahgAAWqsAAFrNAABbAgAAWz8AAFtkAABbkAAAW7MAAFveAABb9QAAXBIAAFwxAABcVAAAXGoAAFyYAABcxgAAXRAAAF05AABdYQAAXZIAAF2wAABd7QAAXjkAAF5aAABeZgAAXnQAAF6CAABekAAAXsMAAF7wAABfHgAAX08AAF+KAABftQAAX+UAAGAlAABgWwAAYKAAAGDhAABhJQAAYXgAAGHCAABh7wAAYi4AAGJXAABirAAAYtwAAGMEAABjJgAAY1kAAGOAAABjjAAAY5AAAGOUAABjnwAAY/EAAGP8AABkBwAAZBIAAGQdAABkKAAAZDMAAGQ+AABkSQAAZFQAAGRfAABkagAAZHUAAGSAAABkiwAAZJYAAGShAABkrAAAZQwAAGUXAABlLAAAZToAAGVIAABlbwAAZXcAAGWCAABljwAAZZsAAGWmAABlvgAAZdYAAGXyAABmBwAAZjQAAGZZAABmZAAAZnUAAGaGAABmnwAAZrAAAGbrAABnEAAAZyUAAGcrAABnQAAAZ0QAAGd0AABnmwAAZ7QAAGfOAABn5gAAZ+oAAGfuAABoCwAAaCMAAGguAABoSgAAaF0AAGikAABo0gAAaQkAAGkfAABpMgAAaUcAAGlYAABpbgAAaYQAAGmdAABptQAAadIAAGnoAABqBAAAahsAAGo2AABqRwAAamUAAGp5AABqngAAaqsAAGrAAABq2QAAauMAAGrwAABrBAAAaw4AAGscAABrJwAAazkAAGtDAABrUQAAa1sAAGtlAABrkwAAa8kAAGviAABsDQAAbB8AAGxGAABscAAAbIcAAGy9AABsyQAAbOwAAG1JAABtnwAAbbgAAG4eAABueAAAbukAAG8bAABvTgAAb4QAAG/DAABv3AAAb/cAAG/7AABv/wAAcAMAAHAcAABwNAAAcFUAAHBtAABwfgAAcJsAAHCfAABwowAAcKcAAHCrAABwvAAAcMAAAHDEAABwyAAAcNkAAHDdAABw4QAAcOUAAHDpAABw7QAAcPEAAHD1AABw+QAAcP0AAHGNAABxlgAAcZ8AAHGoAABxsQAAcboAAHHDAABx0wAAceEAAHIbAAByPAAAckwAAHJaAAByXgAAcmIAAHJ9AABylwAAcq8AAHLJAABy3gAAcvEAAHMRAABzLwAAc0UAAHNYAABzfwAAc6MAAHPFAABz5QAAc/IAAHP/AAB0EQAAdCEAAHQyAAB0PwAAdEwAAHRkAAB0eQAAdJUAAHSpAAB0wwAAdMcAAHTbAAB07wAAdQoAAHUaAAB1MgAAdU8AAHVsAAB1gwAAdZMAAHWbAAB1owAAdasAAHXCAAB13AAAdfcAAHYYAAB2OAAAdl0AAHZuAAB2igAAdpIAAHaaAAB2ogAAdqoAAHayAAB21gAAdu8AAHcLAAB3IAAAd0UAAHdUAAB3WAAAd1wAAHeBAAB3kQAAd6cAAHfQAAB38wAAeBgAAHhBAAB4ZAAAeI8AAHjQAAB4/gAAeSMAAHlUAAB5fQAAeZAAAHmjAAB5tgAAeckAAHnlAAB6AQAAeisAAHpVAAB6eAAAepQAAHq3AAB60wAAewEAAHsmAAB7WAAAe4kAAHuqAAB7ywAAe+QAAHv3AAB8IAAAfEkAAHxkAAB8fwAAfKoAAHzFAAB84AAAfQ4AAH0OAAB9DgAAfQ4AAH0OAAB9HAAAfSoAAH03AAB9RAAAfV0AAH12AAB9kwAAfbAAAH3PAAB97gAAfhIAAH42AAB+RgAAflYAAH5mAAB+dgAAfoYAAH6WAAB+pgAAfrY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A7oDvwPCACADsQPDA8QDtQPBA68DwwO6A78DwgAgAFsAKgBdA8MDzQO8A7IDvwO7A78AIAPEA78DxQAgA7QDvwO7A7EDwQOvA78DxQAgA7wDtQAgA7oDrAO4A7UDxAO/ACAAWwAkAF0DxAPFA8ADvwOzA8EDsQPGA7kDugOsACADtQO9A7EDuwO7A7EDugPEA7kDugOsACAAWwAtACwAKgBdA8EDrQPJA70AIAOyACwAIAOxA8ADuwPMACAAYQPBA60DyQO9ACADuAAsACADsQPAA7sDzAAgAGcALAAgA6MDrQPBA7IDuQO6A78AIAQxAGkAIAAmACAAbAAgA7wDtQAgA7EDugPBA7UDvAPMA70DtQPCA8EDrQPJA70AIAPGACwAIAOjA6wDvAO3ACABSgPDA80DvAOyA78DuwO/ACADxAO/A8UAIAO0A78DuwOxA8EDrwO/A8UAIAO8A7UAIAO6A6wDuAO1A8QDvwAgAFsAJABdAKkAIAAyADAAMgAzACAAQQBkAG8AYgBlACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApACwAIAB3AGkAdABoACAAUgBlAHMAZQByAHYAZQBkACAARgBvAG4AdAAgAE4AYQBtAGUAICAYAFMAbwB1AHIAYwBlIBkAUwBvAHUAcgBjAGUAIABDAG8AZABlACAAUAByAG8AIABNAGUAZABpAHUAbQBSAGUAZwB1AGwAYQByADIALgAwADQAMgA7AEEARABCAE8AOwBTAG8AdQByAGMAZQBDAG8AZABlAFAAcgBvAC0ATQBlAGQAaQB1AG0AOwBBAEQATwBCAEUAUwBvAHUAcgBjAGUAIABDAG8AZABlACAAUAByAG8AIABNAGUAZABpAHUAbQBWAGUAcgBzAGkAbwBuACAAMgAuADAANAAyADsAaABvAHQAYwBvAG4AdgAgADEALgAxAC4AMAA7AG0AYQBrAGUAbwB0AGYAZQB4AGUAIAAyAC4ANgAuADAAUwBvAHUAcgBjAGUAQwBvAGQAZQBQAHIAbwAtAE0AZQBkAGkAdQBtAFMAbwB1AHIAYwBlACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAAQQBkAG8AYgBlACAAaQBuACAAdABoAGUAIABVAG4AaQB0AGUAZAAgAFMAdABhAHQAZQBzACAAYQBuAGQALwBvAHIAIABvAHQAaABlAHIAIABjAG8AdQBuAHQAcgBpAGUAcwAuAEEAZABvAGIAZQBQAGEAdQBsACAARAAuACAASAB1AG4AdAAsACAAVABlAG8AIABUAHUAbwBtAGkAbgBlAG4AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AdAB5AHAAZQBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAuACAAVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABvAG4AIABhAG4AICAYAEEAUwAgAEkAUyAZACAAQgBBAFMASQBTACwAIABXAEkAVABIAE8AVQBUACAAVwBBAFIAUgBBAE4AVABJAEUAUwAgAE8AUgAgAEMATwBOAEQASQBUAEkATwBOAFMAIABPAEYAIABBAE4AWQAgAEsASQBOAEQALAAgAGUAaQB0AGgAZQByACAAZQB4AHAAcgBlAHMAcwAgAG8AcgAgAGkAbQBwAGwAaQBlAGQALgAgAFMAZQBlACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAgAGYAbwByACAAdABoAGUAIABzAHAAZQBjAGkAZgBpAGMAIABsAGEAbgBnAHUAYQBnAGUALAAgAHAAZQByAG0AaQBzAHMAaQBvAG4AcwAgAGEAbgBkACAAbABpAG0AaQB0AGEAdABpAG8AbgBzACAAZwBvAHYAZQByAG4AaQBuAGcAIAB5AG8AdQByACAAdQBzAGUAIABvAGYAIAB0AGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAuAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATABTAG8AdQByAGMAZQAgAEMAbwBkAGUAIABQAHIAbwBNAGUAZABpAHUAbQBzAGkAbQBwAGwAZQAgAGEAcwBpAG0AcABsAGUAIABnAHMAZQByAGkAZgBlAGQAIABpACAAJgAgAGwAUwBhAG0AaQAgAUoAYwB1AHIAcwBpAHYAZQAgA7IAYwB1AHIAcwBpAHYAZQAgA7gAYwB1AHIAcwBpAHYAZQAgA8YAUwBlAHIAYgBpAGEAbgAgA8YAQwB5AHIAaQBsAGwAaQBjACAAYgByAGUAdgBlACAAWwLYAF0AcwBsAGEAcwBoAGUAZAAgAHoAZQByAG8AIABbADAAXQB0AHkAcABvAGcAcgBhAHAAaABpAGMAIABoAHkAcABoAGUAbgAgAFsALQBdAHQAeQBwAG8AZwByAGEAcABoAGkAYwAgAGEAcwB0AGUAcgBpAHMAawAgAFsAKgBdAHMAbABhAHMAaABlAGQAIABkAG8AbABsAGEAcgAgAHMAaQBnAG4AIABbACQAXQBhAGwAdABlAHIAbgBhAHQAZQAgAG4AdQBtAGUAcgBhAGwAIABvAG4AZQAgAFsAMQBdAHQAeQBwAG8AZwByAGEAcABoAGkAYwAgAGEAbAB0AGUAcgBuAGEAdABlAHMAIABbAC0ALAAqAF0AcwBpAG0AcABsAGUAIABhACwAIABjAHUAcgBzAGkAdgBlACADsgBzAGkAbQBwAGwAZQAgAGcALAAgAGMAdQByAHMAaQB2AGUAIAO4ACwAIABTAGUAcgBiAGkAYQBuACAEMQBzAGUAcgBpAGYAZQBkACAAaQAgACYAIABsAFMAYQBtAGkAIAFKACwAIABjAHUAcgBzAGkAdgBlACADxgBzAGwAYQBzAGgAZQBkACAAZABvAGwAbABhAHIAIABzAGkAZwBuACAAWwAkAF0AYQBsAHQAZQByAG4AYQB0AGUAIABuAHUAbQBlAHIAYQBsACAAbwBuAGUAIABbADEAXQQ/BEAEPgRBBEIEPgQ5ACAEMAQ/BEAEPgRBBEIEPgQ5ACAAZwRWACAEOAAgBM8AIARBACAENwQwBEEENQRHBDoEMAQ8BDgEQQQwBDAEPARBBDoEOAQ5ACABSgRBBDoEPgRABD4EPwQ4BEEEPQRLBDkAIAOyBEEEOgQ+BEAEPgQ/BDgEQQQ9BEsEOQAgA7gEQQQ6BD4EQAQ+BD8EOARBBD0ESwQ5ACADxgRBBDUEQAQxBEEEOgQ4BDkAIAQxBDoEOARABDgEOwQ7BDgERwQ1BEEEOgQwBE8AIAQ6BEAEMARCBDoEMAAgAFsC2ABdBDcEMARHBDUEQAQ6BD0EQwRCBEsEOQAgBD0EPgQ7BEwAIABbADAAXQRCBDgEPwQ+BDMEQAQwBEQEQQQ6BDgEOQAgBDQENQREBDgEQQAgAFsALQBdBEIEOAQ/BD4EMwRABDAERARBBDoEMARPACAENwQyBDUENwQ0BD4ERwQ6BDAAIABbACoAXQQ3BDAERwQ1BEAEOgQ9BEMEQgRLBDkAIAQ3BD0EMAQ6ACAENAQ+BDsEOwQwBEAEMAAgAFsAJABdBEIEOAQ/BD4EMwRABDAERARBBDoEOAQ1ACAENwQwBDwENQRBBEIEOARCBDUEOwQ4ACAAWwAtACwAKgBdBD8EQAQ+BEEEQgQ+BDkAIAQwACwAIARBBDoEPgRABD4EPwQ4BEEEPQRLBDkAIAOyBEEENQRABDEEQQQ6BDgEOQAgBDEALAAgBD8EQAQ+BEEEQgQ+BDkAIABnACwAIARBBDoEPgRABD4EPwQ4BEEEPQRLBDkAIAO4BFYAIAQ4ACAEzwAgBEEAIAQ3BDAEQQQ1BEcEOgQwBDwEOARBBDAEMAQ8BEEEOgQ4BDkAIAFKACwAIARBBDoEPgRABD4EPwQ4BEEEPQRLBDkAIAPGBDcEMARHBDUEQAQ6BD0EQwRCBEsEOQAgBDcEPQQwBDoAIAQ0BD4EOwQ7BDAEQAQwACAAWwAkAF0AAgAAAAAAAP/OADIAAAABAAAAAAAAAAAAAAAAAAAAAAYgAAAAAwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0ARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAK0AyQDHAK4AYgECAQMAYwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgCQARMBFAEVARYAZAD9ARcA/wEYARkBGgEbARwBHQEeAMsAZQDIAR8AygEgASEBIgEjASQBJQEmAScBKAEpASoBKwEsAS0BLgD4AS8BMAExATIBMwE0ATUBNgE3ATgBOQE6AM8AzADNATsAzgE8APoBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsA4gFMAU0BTgFPAVABUQFSAGYBUwFUAVUBVgDTANAA0QCvAGcBVwFYAVkBWgFbAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQCRAWoAsAFrAWwBbQFuAW8BcAFxAXIBcwDkAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/ANYA1ADVAYAAaAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmADrAZkAuwGaAZsBnAGdAZ4A5gGfAaABoQGiAOkA7QGjAaQBpQGmAacAagBpAGsAbQBsAagBqQBuAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AKABuQG6AbsBvABvAP4BvQEAAb4BvwHAAcEBwgEBAHEAcAByAcMAcwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gD5AdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAHUAdAB2Ad8AdwHgAeEB4gHjAeQB5QDXAeYB5wHoAekB6gHrAewB7QHuAe8B8ADjAfEB8gHzAfQB9QH2AfcAeAH4AfkB+gH7AfwAegB5AHsAfQB8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8AoQIQALECEQISAhMCFAIVAhYCFwIYAhkA5QIaAhsCHAIdAh4AiQIfAiACIQIiAiMCJAIlAiYAfwB+AIACJwCBAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AOwCQAC6AkECQgJDAkQCRQDnAkYCRwJIAkkA6gDuAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAJsDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQOeA58DoAOhA6IDowOkA6UDpgOnA6gDqQOqA6sDrAOtA64DrwOwA7EDsgOzA7QDtQO2A7cDuAO5A7oDuwO8A70DvgO/A8ADwQPCA8MDxAPFA8YDxwPIA8kDygPLA8wDzQPOA88D0APRA9ID0wPUA9UD1gPXA9gD2QPaA9sD3APdA94D3wPgA+ED4gPjA+QD5QPmAAkAEwAUABUAFgAXABgAGQAaABsAHAPnA+gD6QPqA+sD7APtA+4D7wPwA/ED8gPzA/QD9QP2A/cD+AP5A/oD+wP8A/0D/gP/BAAAEQAPAB0AHgCrAAQAowAiAKIACgAFALYAtwC0ALUAxADFBAEAvgC/AKkAqgAQBAIEAwCyALMEBAQFAMMAhwQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSAEIEEwQUBBUACwAMAD4AQABeAGAAEgBfAD8A6AANAIIAwgCGAIgEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmAIsEJwCKAIwEKAAjBCkABgQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmAJ0EZwCeBGgEaQRqBGsEbARtBG4EbwRwBHEEcgRzBHQEdQR2BHcEeAR5BHoEewR8BH0EfgR/BIAEgQSCBIMEhASFBIYEhwSIBIkEigSLBIwEjQSOBI8AvQAHAIUAlgSQAIQEkQSSBJMElASVBJYElwSYBJkEmgSbBJwEnQSeBJ8EoAD3ALwEoQSiAAgAxgD1APQA9gSjBKQEpQSmBKcEqASpBKoEqwSsBK0ErgSvBLAEsQSyAA4A7wDwALgEswAgBLQAHwAhAJQAlQCTAEEAjwBhAKcApAS1BLYEtwCSAIMEuAS5BLoEuwCYAJwEvAS9AKUEvgS/BMAEwQTCAJkAmgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5ALkE+gT7BPwE/QT+BP8FAAUBBQIFAwBDAI0A2ADhBQQFBQUGBQcFCADZAI4A2gDbAN0A3wDcAN4A4AUJBQoFCwUMBQ0FDgUPBRAFEQUSBRMFFAUVBRYFFwUYBRkFGgUbBRwFHQUeBR8FIAUhBSIFIwUkBSUFJgUnBSgFKQUqBSsFLAUtBS4FLwUwBTEFMgUzBTQFNQU2BTcFOAU5BToFOwU8BT0FPgU/BUAFQQVCBUMFRAVFBUYFRwVIBUkFSgVLBUwFTQVOBU8FUAVRBVIFUwVUBVUFVgVXBVgFWQVaBVsFXAVdBV4FXwVgBWEFYgVjBWQFZQVmBWcFaAVpBWoFawVsBW0FbgVvBXAFcQVyBXMFdAV1BXYFdwV4BXkFegV7BXwFfQV+BX8FgAWBBYIFgwWEBYUFhgWHBYgFiQWKBYsFjAWNBY4FjwWQBZEFkgWTBZQFlQWWBZcFmAWZBZoFmwWcBZ0FngWfBaAFoQWiBaMFpAWlBaYFpwWoBakFqgWrBawFrQWuBa8FsAWxBbIFswW0BbUFtgW3BbgFuQW6BbsFvAW9Bb4FvwXABcEFwgXDBcQFxQXGBccFyAXJBcoFywXMBc0FzgXPBdAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBesF7AXtBe4F7wXwBfEF8gXzBfQF9QX2BfcF+AX5BfoF+wX8Bf0F/gX/BgAGAQYCBgMGBAYFBgYGBwYIBgkGCgYLBgwGDQYOBg8GEAYRBhIGEwYUBhUGFgYXBhgGGQYaBhsGHAYdBh4GHwYgBiEGIgYjBiQGJQYmBicGKAYpBioGKwYsBi0GLgdBbWFjcm9uBkFicmV2ZQpBcmluZ2FjdXRlB3VuaTAxQ0QHQW9nb25lawd1bmkxRUEwB3VuaTFFQTIHdW5pMUVBNAd1bmkxRUE2B3VuaTFFQTgHdW5pMUVBQQd1bmkxRUFDB3VuaTFFQUUHdW5pMUVCMAd1bmkxRUIyB3VuaTFFQjQHdW5pMUVCNgdBRWFjdXRlB3VuaTAxRTIHdW5pMDI0Mwd1bmkxRTA2C0NjaXJjdW1mbGV4CkNkb3RhY2NlbnQGRGNhcm9uB3VuaTFFMEMHdW5pMUUwRQd1bmkxRTEwBkRjcm9hdAd1bmkwMThBBkVjYXJvbgdFbWFjcm9uBkVicmV2ZQpFZG90YWNjZW50B0VvZ29uZWsHdW5pMUVCOAd1bmkxRUJBB3VuaTFFQkMHdW5pMUVCRQd1bmkxRUMwB3VuaTFFQzIHdW5pMUVDNAd1bmkxRUM2B3VuaTFFMTYHdW5pMDFGNAtHY2lyY3VtZmxleApHZG90YWNjZW50B3VuaTAxMjIGR2Nhcm9uB3VuaTFFMjALdW5pMDA0NzAzMDMHdW5pMDE5MwtIY2lyY3VtZmxleAd1bmkxRTI2B3VuaTFFMjQHdW5pMUUyOAd1bmkxRTJBBEhiYXIGSXRpbGRlB0ltYWNyb24HdW5pMDFDRgdJb2dvbmVrB3VuaTFFQzgHdW5pMUVDQQZJYnJldmULSmNpcmN1bWZsZXgHdW5pMDEzNgd1bmkxRTMyB3VuaTFFMzQGTGFjdXRlBkxjYXJvbgd1bmkwMTNCB3VuaTFFMzYHdW5pMUUzOAd1bmkxRTNBBExkb3QHdW5pMUUzRQd1bmkxRTQwB3VuaTFFNDIGTmFjdXRlB3VuaTAxRjgGTmNhcm9uB3VuaTAxNDUHdW5pMUU0NAd1bmkxRTQ2B3VuaTFFNDgHT21hY3Jvbg1PaHVuZ2FydW1sYXV0Bk9icmV2ZQd1bmkwMUQxB3VuaTAxRUEHdW5pMUVDQwd1bmkxRUNFB3VuaTFFRDAHdW5pMUVEMgd1bmkxRUQ0B3VuaTFFRDYHdW5pMUVEOAVPaG9ybgd1bmkxRURBB3VuaTFFREMHdW5pMUVERQd1bmkxRUUwB3VuaTFFRTIHdW5pMUU1MgtPc2xhc2hhY3V0ZQZSYWN1dGUGUmNhcm9uB3VuaTFFNTgHdW5pMDE1Ngd1bmkxRTVBB3VuaTFFNUMHdW5pMUU1RQZTYWN1dGULU2NpcmN1bWZsZXgHdW5pMUU2Ngd1bmkwMTVFB3VuaTAyMTgHdW5pMUU2MAd1bmkxRTYyB3VuaTFFOUUGVGNhcm9uB3VuaTAxNjIHdW5pMDIxQQd1bmkxRTZDB3VuaTFFNkUEVGJhcgZVdGlsZGUHVW1hY3JvbgZVYnJldmUFVXJpbmcNVWh1bmdhcnVtbGF1dAd1bmkwMUQzB1VvZ29uZWsHdW5pMDFENQd1bmkwMUQ3B3VuaTAxRDkHdW5pMDFEQgd1bmkxRUU0B3VuaTFFRTYFVWhvcm4HdW5pMUVFOAd1bmkxRUVBB3VuaTFFRUMHdW5pMUVFRQd1bmkxRUYwB3VuaTFFN0UGV2dyYXZlBldhY3V0ZQtXY2lyY3VtZmxleAlXZGllcmVzaXMGWWdyYXZlC1ljaXJjdW1mbGV4B3VuaTFFOEUHdW5pMUVGNAd1bmkxRUY2B3VuaTFFRjgGWmFjdXRlClpkb3RhY2NlbnQHdW5pMUU5MAd1bmkxRTkyB3VuaTFFOTQHdW5pMDE4RgNFbmcCSUoPdW5pMDA0QzAwQjcwMDRDC3VuaTAxMzIwMzAxB2FtYWNyb24GYWJyZXZlCmFyaW5nYWN1dGUHdW5pMDFDRQdhb2dvbmVrB3VuaTFFQTEHdW5pMUVBMwd1bmkxRUE1B3VuaTFFQTcHdW5pMUVBOQd1bmkxRUFCB3VuaTFFQUQHdW5pMUVBRgd1bmkxRUIxB3VuaTFFQjMHdW5pMUVCNQd1bmkxRUI3B2FlYWN1dGUHdW5pMDFFMwd1bmkwMTgwB3VuaTFFMDcLY2NpcmN1bWZsZXgKY2RvdGFjY2VudAZkY2Fyb24HdW5pMUUwRAd1bmkxRTBGB3VuaTFFMTEGZWNhcm9uB2VtYWNyb24GZWJyZXZlB2VvZ29uZWsKZWRvdGFjY2VudAd1bmkxRUI5B3VuaTFFQkIHdW5pMUVCRAd1bmkxRUJGB3VuaTFFQzEHdW5pMUVDMwd1bmkxRUM1B3VuaTFFQzcHdW5pMUUxNwd1bmkwMUY1C2djaXJjdW1mbGV4Cmdkb3RhY2NlbnQHdW5pMDEyMwZnY2Fyb24HdW5pMUUyMQt1bmkwMDY3MDMwMwtoY2lyY3VtZmxleAd1bmkxRTI3B3VuaTFFMjUHdW5pMUU5Ngd1bmkxRTI5B3VuaTFFMkIEaGJhcgZpdGlsZGUHaW1hY3Jvbgd1bmkwMUQwB2lvZ29uZWsHdW5pMUVDOQd1bmkxRUNCBmlicmV2ZQtqY2lyY3VtZmxleAd1bmkwMTM3B3VuaTFFMzMHdW5pMUUzNQxrZ3JlZW5sYW5kaWMGbGFjdXRlBmxjYXJvbgd1bmkwMTNDB3VuaTFFMzcHdW5pMUUzOQd1bmkxRTNCBGxkb3QHdW5pMUUzRgd1bmkxRTQxB3VuaTFFNDMGbmFjdXRlB3VuaTAxRjkGbmNhcm9uB3VuaTAxNDYHdW5pMUU0NQd1bmkxRTQ3B3VuaTFFNDkLbmFwb3N0cm9waGUHb21hY3Jvbg1vaHVuZ2FydW1sYXV0B3VuaTAxRDIHdW5pMDFFQgd1bmkxRUNEB3VuaTFFQ0YHdW5pMUVEMQd1bmkxRUQzB3VuaTFFRDUHdW5pMUVENwd1bmkxRUQ5Bm9icmV2ZQd1bmkxRTUzBW9ob3JuB3VuaTFFREIHdW5pMUVERAd1bmkxRURGB3VuaTFFRTEHdW5pMUVFMwtvc2xhc2hhY3V0ZQZyYWN1dGUHdW5pMDE1NwZyY2Fyb24HdW5pMUU1OQd1bmkxRTVCB3VuaTFFNUQHdW5pMUU1RgZzYWN1dGULc2NpcmN1bWZsZXgHdW5pMUU2Nwd1bmkwMTVGB3VuaTAyMTkHdW5pMUU2MQd1bmkxRTYzBWxvbmdzBnRjYXJvbgd1bmkwMTYzB3VuaTAyMUIHdW5pMUU2RAd1bmkxRTZGB3VuaTFFOTcEdGJhcgZ1dGlsZGUHdW1hY3JvbgZ1YnJldmUFdXJpbmcNdWh1bmdhcnVtbGF1dAd1bmkwMUQ0B3VvZ29uZWsHdW5pMDFENgd1bmkwMUQ4B3VuaTAxREEHdW5pMDFEQwd1bmkxRUU1B3VuaTFFRTcFdWhvcm4HdW5pMUVFOQd1bmkxRUVCB3VuaTFFRUQHdW5pMUVFRgd1bmkxRUYxB3VuaTFFN0YGd2dyYXZlBndhY3V0ZQt3Y2lyY3VtZmxleAl3ZGllcmVzaXMGeWdyYXZlC3ljaXJjdW1mbGV4B3VuaTFFOEYHdW5pMUVGNQd1bmkxRUY3B3VuaTFFRjkGemFjdXRlCnpkb3RhY2NlbnQHdW5pMUU5MQd1bmkxRTkzB3VuaTFFOTUDZW5nB3VuaTAyMzcCaWoPdW5pMDA2QzAwQjcwMDZDC3VuaTAxMzMwMzAxB3VuaTAyNTAHdW5pMDI1Mgd1bmkwMjUzB3VuaTAyNTQHdW5pMDI1NQd1bmkwMjU2B3VuaTAyNTcHdW5pMDI1OAd1bmkwMjUxB3VuaTAyOTkHdW5pMDI1OQd1bmkwMjVBB3VuaTAyNUIHdW5pMDI1Qwd1bmkwMjVFB3VuaTAyNUYHdW5pMDI2MAd1bmkwMjYxB3VuaTAyNjIHdW5pMDI2Mwd1bmkwMjY0B3VuaTAyNjUHdW5pMDI2Ngd1bmkwMjY3B3VuaTAyOUMHdW5pMDI2OAd1bmkwMjZBB3VuaTAyOUQHdW5pMDI5RQd1bmkwMjZCB3VuaTAyNkMHdW5pMDI2RAd1bmkwMjZFB3VuaTAyOUYHdW5pMDI2Rgd1bmkwMjcwB3VuaTAyNzEHdW5pMDI3Mgd1bmkwMjczB3VuaTAyNzQHdW5pMDI3NQd1bmkwMjc2B3VuaTAyNzgHdW5pMDI3OQd1bmkwMjdBB3VuaTAyN0IHdW5pMDI3RAd1bmkwMjdFB3VuaTAyODAHdW5pMDI4MQd1bmkwMjgyB3VuaTAyODMHdW5pMDI4NAd1bmkwMjg3B3VuaTAyODgHdW5pMDI4OQd1bmkwMjhBB3VuaTAyOEIHdW5pMDI4Qwd1bmkwMjhEB3VuaTAyOEUHdW5pMDI4Rgd1bmkwMjkwB3VuaTAyOTEHdW5pMDI5Mgd1bmkwMkE0B3VuaTAyQTYHdW5pMDJBNwd1bmkwMjk0B3VuaTAyOTUHdW5pMDJBMQd1bmkwMkEyB3VuaTAxQzIHdW5pMDI5OAl1bmkwMTRBLmEDYS5hCGFncmF2ZS5hCGFhY3V0ZS5hDWFjaXJjdW1mbGV4LmEIYXRpbGRlLmELYWRpZXJlc2lzLmEJYW1hY3Jvbi5hCGFicmV2ZS5hB2FyaW5nLmEMYXJpbmdhY3V0ZS5hCXVuaTAxQ0UuYQl1bmkxRUExLmEJdW5pMUVBMy5hCXVuaTFFQTUuYQl1bmkxRUE3LmEJdW5pMUVBOS5hCXVuaTFFQUIuYQl1bmkxRUFELmEJdW5pMUVBRi5hCXVuaTFFQjEuYQl1bmkxRUIzLmEJdW5pMUVCNS5hCXVuaTFFQjcuYQlhb2dvbmVrLmEDZy5hCXVuaTAxRjUuYQ1nY2lyY3VtZmxleC5hCGdicmV2ZS5hDGdkb3RhY2NlbnQuYQl1bmkwMTIzLmEIZ2Nhcm9uLmEJdW5pMUUyMS5hDXVuaTAwNjcwMzAzLmEDaS5hCmRvdGxlc3NpLmEIaWdyYXZlLmEIaWFjdXRlLmENaWNpcmN1bWZsZXguYQhpdGlsZGUuYQtpZGllcmVzaXMuYQlpbWFjcm9uLmEJdW5pMDFEMC5hCWlvZ29uZWsuYQl1bmkxRUM5LmEJdW5pMUVDQi5hCXVuaTAxMkQuYQl1bmkwMjY4LmEJaW9nb25lay5kCmlvZ29uZWsuZGEJdW5pMDI2OC5kCnVuaTAyNjguZGEJdW5pMDI5RC5kA2wuYQhsYWN1dGUuYQhsY2Fyb24uYQl1bmkwMTNDLmEJdW5pMUUzNy5hCXVuaTFFMzkuYQl1bmkxRTNCLmEIbHNsYXNoLmEGbGRvdC5hEXVuaTAwNkMwMEI3MDA2Qy5hCXVuaTAyNkIuYQl1bmkwMjZDLmEFQWxwaGEEQmV0YQVHYW1tYQd1bmkwMzk0B0Vwc2lsb24EWmV0YQNFdGEFVGhldGEESW90YQVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kHdW5pMDNBOQpBbHBoYXRvbm9zDEVwc2lsb250b25vcwhFdGF0b25vcwlJb3RhdG9ub3MMSW90YWRpZXJlc2lzDE9taWNyb250b25vcwxVcHNpbG9udG9ub3MPVXBzaWxvbmRpZXJlc2lzCk9tZWdhdG9ub3MFYWxwaGEEYmV0YQVnYW1tYQVkZWx0YQdlcHNpbG9uBHpldGEDZXRhBXRoZXRhBGlvdGEFa2FwcGEGbGFtYmRhB3VuaTAzQkMCbnUCeGkHb21pY3JvbgNyaG8Fc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EHdW5pMDNDMgd1bmkwM0QwB3VuaTAzRDEHdW5pMDNENQVwaGkuYQphbHBoYXRvbm9zDGVwc2lsb250b25vcwhldGF0b25vcwlpb3RhdG9ub3MMaW90YWRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MPdXBzaWxvbmRpZXJlc2lzCm9tZWdhdG9ub3MRaW90YWRpZXJlc2lzdG9ub3MUdXBzaWxvbmRpZXJlc2lzdG9ub3MHdW5pMDNENwd1bmkwM0Q5B3VuaTAzREIHdW5pMDNERAd1bmkwM0UxB3VuaTAzN0UJYW5vdGVsZWlhDWFub3RlbGVpYS5jYXAHdW5pMDM3NAd1bmkwMzc1BXRvbm9zCXRvbm9zLmNhcA1kaWVyZXNpc3Rvbm9zB3VuaTAzN0EHdW5pMUZCRQd1bmkxRkJEB3VuaTFGQkYHdW5pMUZGRQd1bmkxRkVGB3VuaTFGRkQHdW5pMUZDRAd1bmkxRkREB3VuaTFGQ0UHdW5pMUZERQd1bmkxRkNGB3VuaTFGREYHdW5pMUZDMAd1bmkxRkVEB3VuaTFGRUUHdW5pMUZDMQt1bmkxRkJELmNhcAt1bmkxRkZFLmNhcAt1bmkxRkVGLmNhcAt1bmkxRkZELmNhcAt1bmkxRkNELmNhcAt1bmkxRkRELmNhcAt1bmkxRkNFLmNhcAt1bmkxRkRFLmNhcAt1bmkxRkNGLmNhcAt1bmkxRkRGLmNhcAd1bmkwNDEwB3VuaTA0MTEHdW5pMDQxMgd1bmkwNDEzB3VuaTA0MTQHdW5pMDQxNQd1bmkwNDE2B3VuaTA0MTcHdW5pMDQxOAd1bmkwNDE5B3VuaTA0MUEHdW5pMDQxQgd1bmkwNDFDB3VuaTA0MUQHdW5pMDQxRQd1bmkwNDFGB3VuaTA0MjAHdW5pMDQyMQd1bmkwNDIyB3VuaTA0MjMHdW5pMDQyNAd1bmkwNDI1B3VuaTA0MjYHdW5pMDQyNwd1bmkwNDI4B3VuaTA0MjkHdW5pMDQyQQd1bmkwNDJCB3VuaTA0MkMHdW5pMDQyRAd1bmkwNDJFB3VuaTA0MkYHdW5pMDQwMAd1bmkwNDAxB3VuaTA0MDIHdW5pMDQwMwd1bmkwNDA0B3VuaTA0MDUHdW5pMDQwNgd1bmkwNDA3B3VuaTA0MDgHdW5pMDQwOQd1bmkwNDBBB3VuaTA0MEIHdW5pMDQwQwd1bmkwNDBEB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDYyB3VuaTA0NzIHdW5pMDQ3NAd1bmkwNDkwB3VuaTA0OTIHdW5pMDQ5Ngd1bmkwNDk4B3VuaTA0OUEHdW5pMDRBMAd1bmkwNEEyB3VuaTA0QUEHdW5pMDRBRQd1bmkwNEIwB3VuaTA0QjIHdW5pMDRCNgd1bmkwNEJBB3VuaTA0QzAHdW5pMDRDMQd1bmkwNEQwB3VuaTA0RDQHdW5pMDRENgd1bmkwNEQ4B3VuaTA0RTIHdW5pMDRFNgd1bmkwNEU4B3VuaTA0RUUHdW5pMDRGMgd1bmkwNDMwB3VuaTA0MzEHdW5pMDQzMgd1bmkwNDMzB3VuaTA0MzQHdW5pMDQzNQd1bmkwNDM2B3VuaTA0MzcHdW5pMDQzOAd1bmkwNDM5B3VuaTA0M0EHdW5pMDQzQgd1bmkwNDNDB3VuaTA0M0QHdW5pMDQzRQd1bmkwNDNGB3VuaTA0NDAHdW5pMDQ0MQd1bmkwNDQyB3VuaTA0NDMHdW5pMDQ0NAd1bmkwNDQ1B3VuaTA0NDYHdW5pMDQ0Nwd1bmkwNDQ4B3VuaTA0NDkHdW5pMDQ0QQd1bmkwNDRCB3VuaTA0NEMHdW5pMDQ0RAd1bmkwNDRFB3VuaTA0NEYHdW5pMDQ1MAd1bmkwNDUxB3VuaTA0NTIHdW5pMDQ1Mwd1bmkwNDU0B3VuaTA0NTUHdW5pMDQ1Ngd1bmkwNDU3B3VuaTA0NTgHdW5pMDQ1OQd1bmkwNDVBB3VuaTA0NUIHdW5pMDQ1Qwd1bmkwNDVEB3VuaTA0NUUHdW5pMDQ1Rgd1bmkwNDYzB3VuaTA0NzMHdW5pMDQ3NQd1bmkwNDkxB3VuaTA0OTMHdW5pMDQ5Nwd1bmkwNDk5B3VuaTA0OUIHdW5pMDRBMQd1bmkwNEEzB3VuaTA0QUIHdW5pMDRBRgd1bmkwNEIxB3VuaTA0QjMHdW5pMDRCNwd1bmkwNEJCB3VuaTA0QzIHdW5pMDRDRgd1bmkwNEQxB3VuaTA0RDUHdW5pMDRENwd1bmkwNEQ5B3VuaTA0RTMHdW5pMDRFNwd1bmkwNEU5B3VuaTA0RUYHdW5pMDRGMwl1bmkwNDMwLmEJdW5pMDREMS5hC3VuaTA0MzEuc3JiCXVuaTA0NTYuYQl1bmkwNDU3LmEJdW5pMDRDRi5hB3VuaTIxMTYGemVyby5hBW9uZS5hCXplcm8ub251bQhvbmUub251bQh0d28ub251bQp0aHJlZS5vbnVtCWZvdXIub251bQlmaXZlLm9udW0Ic2l4Lm9udW0Kc2V2ZW4ub251bQplaWdodC5vbnVtCW5pbmUub251bQZ6ZXJvLmIFb25lLmIIemVyby5jYXAHb25lLmNhcAd0d28uY2FwCXRocmVlLmNhcAhmb3VyLmNhcAhmaXZlLmNhcAdzaXguY2FwCXNldmVuLmNhcAllaWdodC5jYXAIbmluZS5jYXAGemVyby5jBW9uZS5jDXF1b3RlcmV2ZXJzZWQHdW5pMDBBRAd1bmkyMDEwCmZpZ3VyZWRhc2gHdW5pMjAxNQd1bmkyNUU2B3VuaTI1QUEHdW5pMjVBQgd1bmkyNUI0B3VuaTI1QjUHdW5pMjVCOAd1bmkyNUI5B3VuaTI1QkUHdW5pMjVCRgd1bmkyNUMyB3VuaTI1QzMJaW52YnVsbGV0CmZpbGxlZHJlY3QNdW5kZXJzY29yZWRibAd1bmkyMDNFB3VuaTIwM0YHdW5pMjAxNglleGNsYW1kYmwHdW5pMjA0Nwd1bmkyMDQ5B3VuaTIwNDgHdW5pMjAzRAd1bmkyRTE4B3VuaTIzMUMHdW5pMjMxRAd1bmkyMzFFB3VuaTIzMUYHdW5pMjdFNgd1bmkyN0U3B3VuaTJFMjIHdW5pMkUyMwd1bmkyRTI0B3VuaTJFMjUHdW5pMjExNwd1bmkyMTIwB2F0LmNhc2UKYXN0ZXJpc2suYQhoeXBoZW4uYQl1bmkwMEFELmEJdW5pMjAxMC5hCGRvbGxhci5hCXplcm8uc3VwcwhvbmUuc3Vwcwh0d28uc3Vwcwp0aHJlZS5zdXBzCWZvdXIuc3VwcwlmaXZlLnN1cHMIc2l4LnN1cHMKc2V2ZW4uc3VwcwplaWdodC5zdXBzCW5pbmUuc3Vwcw5wYXJlbmxlZnQuc3Vwcw9wYXJlbnJpZ2h0LnN1cHMLcGVyaW9kLnN1cHMKY29tbWEuc3Vwcwl6ZXJvLnN1YnMIb25lLnN1YnMIdHdvLnN1YnMKdGhyZWUuc3Vicwlmb3VyLnN1YnMJZml2ZS5zdWJzCHNpeC5zdWJzCnNldmVuLnN1YnMKZWlnaHQuc3VicwluaW5lLnN1YnMOcGFyZW5sZWZ0LnN1YnMPcGFyZW5yaWdodC5zdWJzC3BlcmlvZC5zdWJzCmNvbW1hLnN1YnMJemVyby5kbm9tCG9uZS5kbm9tCHR3by5kbm9tCnRocmVlLmRub20JZm91ci5kbm9tCWZpdmUuZG5vbQhzaXguZG5vbQpzZXZlbi5kbm9tCmVpZ2h0LmRub20JbmluZS5kbm9tDnBhcmVubGVmdC5kbm9tD3BhcmVucmlnaHQuZG5vbQtwZXJpb2QuZG5vbQpjb21tYS5kbm9tCXplcm8ubnVtcghvbmUubnVtcgh0d28ubnVtcgp0aHJlZS5udW1yCWZvdXIubnVtcglmaXZlLm51bXIIc2l4Lm51bXIKc2V2ZW4ubnVtcgplaWdodC5udW1yCW5pbmUubnVtcg5wYXJlbmxlZnQubnVtcg9wYXJlbnJpZ2h0Lm51bXILcGVyaW9kLm51bXIKY29tbWEubnVtcg1vcmRmZW1pbmluZS5hBmEuc3VwcwZiLnN1cHMGYy5zdXBzBmQuc3VwcwZlLnN1cHMGZi5zdXBzBmcuc3VwcwZoLnN1cHMGaS5zdXBzBmouc3VwcwZrLnN1cHMGbC5zdXBzBm0uc3VwcwZuLnN1cHMGby5zdXBzBnAuc3VwcwZxLnN1cHMGci5zdXBzBnMuc3VwcwZ0LnN1cHMGdS5zdXBzBnYuc3VwcwZ3LnN1cHMGeC5zdXBzBnkuc3VwcwZ6LnN1cHMLZWdyYXZlLnN1cHMLZWFjdXRlLnN1cHMMZW9nb25lay5zdXBzDHVuaTAyNTkuc3Vwcwx1bmkwMjY2LnN1cHMHdW5pMDJFMAd1bmkwMkU0BmEuc3VwYQZnLnN1cGEGaS5zdXBhCmNvbG9uLnN1cHMLaHlwaGVuLnN1cHMLZW5kYXNoLnN1cHMLZW1kYXNoLnN1cHMERXVybwd1bmkwMTkyDWNvbG9ubW9uZXRhcnkEbGlyYQd1bmkyMEE2BnBlc2V0YQd1bmkyMEE5BGRvbmcHdW5pMjBCMQd1bmkyMEIyB3VuaTIwQjQHdW5pMjBCNQd1bmkyMEI5B3VuaTIwQkEHdW5pMjBBRQd1bmkyMEI4B3VuaTIwQkQHdW5pMjIxNQpzbGFzaC5mcmFjCG9uZXRoaXJkCXR3b3RoaXJkcwd1bmkyMTU1B3VuaTIxNTYHdW5pMjE1Nwd1bmkyMTU4B3VuaTIxNTkHdW5pMjE1QQd1bmkyMTUwCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaTIxNTEHdW5pMjE1Mgd1bmkyMTg5B3VuaTIyMTkLZXF1aXZhbGVuY2UNcmV2bG9naWNhbG5vdAxpbnRlcnNlY3Rpb24Kb3J0aG9nb25hbAd1bmkyMDMyB3VuaTIwMzMHdW5pMjAzNQd1bmkwMEI1CmludGVncmFsdHAKaW50ZWdyYWxidAd1bmkyMjA2B3VuaTIxMjYHdW5pMjIwMAd1bmkyMjAzB3VuaTIyMzcHdW5pMjEwNQd1bmkyMTEzCWVzdGltYXRlZAd1bmkyMTkwB2Fycm93dXAHdW5pMjE5MglhcnJvd2Rvd24HdW5pMjE5Ngd1bmkyMTk3B3VuaTIxOTgHdW5pMjE5OQd1bmkyMUQwB3VuaTIxRDEHdW5pMjFEMgd1bmkyMUQzCWFycm93Ym90aAlhcnJvd3VwZG4MYXJyb3d1cGRuYnNlB3VuaTI1Q0YHdW5pMjVDQgd1bmkyNUEwB3VuaTI1QTEHdW5pMjc1Mgd1bmkyNUM2B3RyaWFndXAHdW5pMjVCMwd1bmkyNUI2B3VuaTI1QjcHdHJpYWdkbgd1bmkyNUJEB3VuaTI1QzAHdW5pMjVDMQd0cmlhZ3J0B3RyaWFnbGYJaW52Y2lyY2xlB3VuaTI1QzkHdW5pMjYxMAd1bmkyNjExB3VuaTI3MTMLbXVzaWNhbG5vdGUObXVzaWNhbG5vdGVkYmwFaGVhcnQEY2x1YgdkaWFtb25kBXNwYWRlCXNtaWxlZmFjZQxpbnZzbWlsZWZhY2UHdW5pMjc2NAd1bmkyNjE1BnUxRjRBOQZ1MUY5MTYGdTFGNTEyBmZlbWFsZQRtYWxlA3N1bgVob3VzZQd1bmkwMkI5B3VuaTAyQkIHdW5pMDJCQwd1bmkwMkJFB3VuaTAyQkYHdW5pMDJDMQd1bmkwMkQwB3VuaTAyRDEHdW5pMDJERQd1bmkwMkM4B3VuaTAyQzkHdW5pMDJDQQd1bmkwMkNCB3VuaTAyQ0MHdW5pMjVDQwd1bmkwMzAwC3VuaTAzMDAuY2FwB3VuaTAzNDAHdW5pMDMwMQt1bmkwMzAxLmNhcAl1bmkwMzAxLmcHdW5pMDMwMgt1bmkwMzAyLmNhcAd1bmkwMzAzC3VuaTAzMDMuY2FwB3VuaTAzMDQLdW5pMDMwNC5jYXAHdW5pMDMwNQt1bmkwMzA1LmNhcAd1bmkwMzA2CXVuaTAzMDYuYwt1bmkwMzA2LmNhcAx1bmkwMzA2LmNjYXAHdW5pMDMwNwt1bmkwMzA3LmNhcAd1bmkwMzA4C3VuaTAzMDguY2FwB3VuaTAzMDkLdW5pMDMwOS5jYXAHdW5pMDMxMAt1bmkwMzEwLmNhcAd1bmkwMzBBC3VuaTAzMEEuY2FwB3VuaTAzMEILdW5pMDMwQi5jYXAHdW5pMDMwQwt1bmkwMzBDLmNhcAl1bmkwMzBDLmEHdW5pMDMwRgt1bmkwMzBGLmNhcAd1bmkwMzExC3VuaTAzMTEuY2FwB3VuaTAzMTIJdW5pMDMxMi5nB3VuaTAzMTMHdW5pMDM0Mwd1bmkwMzE4B3VuaTAzMTkHdW5pMDMxQQd1bmkwMzFCB3VuaTAzMUMHdW5pMDMxRAd1bmkwMzFFB3VuaTAzMUYHdW5pMDMyMAd1bmkwMzIzB3VuaTAzMjQHdW5pMDMyNQd1bmkwMzI2CXVuaTAzMjYuYQd1bmkwMzI3C3VuaTAzMjcuY2FwB3VuaTAzMjgLdW5pMDMyOC5jYXAHdW5pMDMyOQd1bmkwMzJBB3VuaTAzMkMHdW5pMDMyRQd1bmkwMzJGB3VuaTAzMzAHdW5pMDMzMQd1bmkwMzM0B3VuaTAzMzkHdW5pMDMzQQd1bmkwMzNCB3VuaTAzM0MHdW5pMDMzRAd1bmkwMzQyC3VuaTAzNDIuY2FwB3VuaTAzNDUHdW5pMDM1Rgd1bmkwMzYxC3VuaTAzMDgwMzAxD3VuaTAzMDgwMzAxLmNhcA11bmkwMzA4MDMwMS5nC3VuaTAzMDgwMzAwD3VuaTAzMDgwMzAwLmNhcA11bmkwMzA4MDMwMC5nC3VuaTAzMDgwMzAzC3VuaTAzMDgwMzA0D3VuaTAzMDgwMzA0LmNhcAt1bmkwMzA4MDMwQw91bmkwMzA4MDMwQy5jYXALdW5pMDMwMjAzMDEPdW5pMDMwMjAzMDEuY2FwC3VuaTAzMDIwMzAwD3VuaTAzMDIwMzAwLmNhcAt1bmkwMzAyMDMwOQ91bmkwMzAyMDMwOS5jYXALdW5pMDMwMjAzMDMPdW5pMDMwMjAzMDMuY2FwC3VuaTAzMDYwMzAxD3VuaTAzMDYwMzAxLmNhcAt1bmkwMzA2MDMwMA91bmkwMzA2MDMwMC5jYXALdW5pMDMwNjAzMDkPdW5pMDMwNjAzMDkuY2FwC3VuaTAzMDYwMzAzD3VuaTAzMDYwMzAzLmNhcAt1bmkwMzAyMDMwNg91bmkwMzAyMDMwNi5jYXALdW5pMDMwNDAzMDEPdW5pMDMwNDAzMDEuY2FwC3VuaTAzMEMwMzA3D3VuaTAzMEMwMzA3LmNhcAt1bmkwMzEyMDMwMQt1bmkwMzEyMDMwMAt1bmkwMzEyMDMwMwt1bmkwMzEzMDMwMQt1bmkwMzEzMDMwMAt1bmkwMzEzMDMwMwd1bmkwMEEwB3VuaTIwMDcKc3BhY2UuZnJhYwxuYnNwYWNlLmZyYWMHdW5pMjUwMAd1bmkyNTAxB3VuaTI1MDIHdW5pMjUwMwd1bmkyNTA0B3VuaTI1MDUHdW5pMjUwNgd1bmkyNTA3B3VuaTI1MDgHdW5pMjUwOQd1bmkyNTBBB3VuaTI1MEIHdW5pMjUwQwd1bmkyNTBEB3VuaTI1MEUHdW5pMjUwRgd1bmkyNTEwB3VuaTI1MTEHdW5pMjUxMgd1bmkyNTEzB3VuaTI1MTQHdW5pMjUxNQd1bmkyNTE2B3VuaTI1MTcHdW5pMjUxOAd1bmkyNTE5B3VuaTI1MUEHdW5pMjUxQgd1bmkyNTFDB3VuaTI1MUQHdW5pMjUxRQd1bmkyNTFGB3VuaTI1MjAHdW5pMjUyMQd1bmkyNTIyB3VuaTI1MjMHdW5pMjUyNAd1bmkyNTI1B3VuaTI1MjYHdW5pMjUyNwd1bmkyNTI4B3VuaTI1MjkHdW5pMjUyQQd1bmkyNTJCB3VuaTI1MkMHdW5pMjUyRAd1bmkyNTJFB3VuaTI1MkYHdW5pMjUzMAd1bmkyNTMxB3VuaTI1MzIHdW5pMjUzMwd1bmkyNTM0B3VuaTI1MzUHdW5pMjUzNgd1bmkyNTM3B3VuaTI1MzgHdW5pMjUzOQd1bmkyNTNBB3VuaTI1M0IHdW5pMjUzQwd1bmkyNTNEB3VuaTI1M0UHdW5pMjUzRgd1bmkyNTQwB3VuaTI1NDEHdW5pMjU0Mgd1bmkyNTQzB3VuaTI1NDQHdW5pMjU0NQd1bmkyNTQ2B3VuaTI1NDcHdW5pMjU0OAd1bmkyNTQ5B3VuaTI1NEEHdW5pMjU0Qgd1bmkyNTRDB3VuaTI1NEQHdW5pMjU0RQd1bmkyNTRGB3VuaTI1NTAHdW5pMjU1MQd1bmkyNTUyB3VuaTI1NTMHdW5pMjU1NAd1bmkyNTU1B3VuaTI1NTYHdW5pMjU1Nwd1bmkyNTU4B3VuaTI1NTkHdW5pMjU1QQd1bmkyNTVCB3VuaTI1NUMHdW5pMjU1RAd1bmkyNTVFB3VuaTI1NUYHdW5pMjU2MAd1bmkyNTYxB3VuaTI1NjIHdW5pMjU2Mwd1bmkyNTY0B3VuaTI1NjUHdW5pMjU2Ngd1bmkyNTY3B3VuaTI1NjgHdW5pMjU2OQd1bmkyNTZBB3VuaTI1NkIHdW5pMjU2Qwd1bmkyNTZEB3VuaTI1NkUHdW5pMjU2Rgd1bmkyNTcwB3VuaTI1NzEHdW5pMjU3Mgd1bmkyNTczB3VuaTI1NzQHdW5pMjU3NQd1bmkyNTc2B3VuaTI1NzcHdW5pMjU3OAd1bmkyNTc5B3VuaTI1N0EHdW5pMjU3Qgd1bmkyNTdDB3VuaTI1N0QHdW5pMjU3RQd1bmkyNTdGB3VuaTI1ODAHdW5pMjU4MQd1bmkyNTgyB3VuaTI1ODMHdW5pMjU4NAd1bmkyNTg1B3VuaTI1ODYHdW5pMjU4Nwd1bmkyNTg4B3VuaTI1ODkHdW5pMjU4QQd1bmkyNThCB3VuaTI1OEMHdW5pMjU4RAd1bmkyNThFB3VuaTI1OEYHdW5pMjU5MAd1bmkyNTkxB3VuaTI1OTIHdW5pMjU5Mwd1bmkyNTk0B3VuaTI1OTUHdW5pMjU5Ngd1bmkyNTk3B3VuaTI1OTgHdW5pMjU5OQd1bmkyNTlBB3VuaTI1OUIHdW5pMjU5Qwd1bmkyNTlEB3VuaTI1OUUHdW5pMjU5Rgd1bmkyMDJGB3VuaUZFRkYGdTFGM0I1BnUxRjNCNgNmX2kDZl9sB3VuaUUwQTAHdW5pRTBBMQd1bmlFMEEy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");

// runtime/text-metric.ts
var import_buffer = __toESM(require_buffer());
var b = import_buffer.Buffer.from(SourceCodePro_Medium_default);
var defaultFont = $d636bc798e7178db$export$185802fd694ee1f5(b);
var fonts2 = {
  "sans-serif": defaultFont,
  "Source Code Pro": defaultFont
};
var FontkitCalculator = class {
  name = "fontkit";
  getLineMetric(text, fontConfig) {
    const fontSize2 = fontConfig?.fontSize || 14;
    const fontName = fontConfig?.fontFamily || "sans-serif";
    const font = fonts2[fontName] || defaultFont;
    const glyph = font.layout(text);
    const sizeUnit = fontSize2 / font.unitsPerEm;
    const width2 = glyph.bbox.width * sizeUnit;
    const glyphActualMaxHeight = glyph.glyphs.reduce((last4, curr) => Math.max(last4, curr.cbox.height), 0) * sizeUnit;
    const height = glyphActualMaxHeight;
    const actualBoundingBoxAscent = height;
    const actualBoundingBoxDescent = 0;
    return {
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      width: width2
    };
  }
  calculateTextDimensions(text, font) {
    const lines = text.split("\n");
    let width2 = 0;
    let height = 0;
    const fontSize2 = font?.fontSize || 14;
    lines.forEach((line, i2) => {
      const lineMetric = this.getLineMetric(line, font);
      const w = lineMetric.width;
      width2 = Math.max(w, width2);
      let lineHeight = fontSize2;
      if ("actualBoundingBoxDescent" in lineMetric) {
        lineHeight = lineMetric.actualBoundingBoxAscent + lineMetric.actualBoundingBoxDescent;
      }
      height += lineHeight;
    });
    return {
      width: width2,
      height
    };
  }
};
textMetrics.setImpl(new FontkitCalculator());

// runtime/index.ts
async function render2(opts) {
  const svg2 = await doRender({
    ...opts,
    code: opts.code
  });
  const pintoraOutput = {
    type: "svg",
    data: svg2
  };
  return pintoraOutput;
}
var runtime_default = pintoraStandalone;
export {
  runtime_default as default,
  render2 as render
};
/*! Bundled license information:

shallow-clone/index.js:
  (*!
   * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
